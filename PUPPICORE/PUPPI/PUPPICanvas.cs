using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Media.Media3D;
using HelixToolkit.Wpf;
using System.Collections;
using System.Collections.ObjectModel;
using System.Collections.Concurrent;
using System.Xml;
using System.Xml.Linq;
using PUPPIModel;
using Mehroz;
using PUPPIFormUtils;
using PUPPIDEBUG;
//to get class names
using System.Reflection;
using System.Data;
//for threading to get visuals to update while also continuing processing
using System.Threading;
//using System.Threading.Tasks;
using System.Windows.Threading;
using System.Security.Permissions;
using System.ComponentModel;
using System.IO;
using System.Text.RegularExpressions;
using System.Diagnostics;


namespace PUPPIGUI
{
    //this is a static class for  variable related to runtime operations
    internal static class PUPPIruntimesettings
    {
        internal static bool PUPPICurrentlySavingStatusForServer = false;
        internal static bool PUPPICanvasTCPServerIsRunning = false;
        internal static bool PUPPICanvasHTTPServerIsRunning = false;

        internal static bool PUPPICADTCPServerIsRunning = false;
        internal static bool PUPPICADHTTPServerIsRunning = false;

        internal static bool PUPPICanvasServerUpdatingFully = false;
        //drop on
        internal static PUPPIModule savedAddNodeModule = null;
        //drop on event
        internal static event EventHandler moduleButtonWasDoubleClicked;
        internal static void fireUpModuleDblClicked()
        {
            if (moduleButtonWasDoubleClicked != null)
                moduleButtonWasDoubleClicked(null, EventArgs.Empty);
        }
        //with live update, every time anything happens the module is processed
        internal static bool liveupdate = true;

        //executing assembly
        internal static Assembly mycallerassembly;

        //this is the actual variable which tells process() to not process
        //they are not the same thing
        internal static bool processyesno = true;
        //node caption and in outs update state
        //this has multiple options
        internal enum graphicalnodeupdatestates { IsNotReady, DoUpdate };
        internal static graphicalnodeupdatestates currentstate = graphicalnodeupdatestates.DoUpdate;
        internal static void check_all_security()
        {

        }
        //makes sure extension has dot
        internal static void extensionvalidate()
        {
            string pg = PUPPIGUISettings.saveFileExtension;
            pg = pg.Replace("/", "");
            if (pg == "") pg = ".xml";
            if (pg.Substring(0, 1) != ".") pg = "." + pg;
            PUPPIGUISettings.saveFileExtension = pg;

        }

    }
    /// <summary>
    /// Class containing values that can be set to alter the appearance of the PUPPI canvas GUI. Default values already set.
    /// </summary>
    public static class PUPPIGUISettings
    {
        /// <summary>
        /// The size of the manipulator that can be displayed in the CAD window
        /// </summary>
        public static double CADViewManipulatorSize = 0.1;

        /// <summary>
        /// CAD Window manipulator positioning
        /// </summary>
        public enum CADWindowManipulatorPosition { Exact, Center, BoxCorner }

        /// <summary>
        /// When CADWindowManipulatorPosition is Exact, how much to offset (X,Y,Z) the manipulator from point clicked to allow double clicking. Default is 0.1;
        /// </summary>
        public static double CADManipExactDisplacement = 0.1;

        /// <summary>
        /// If true, button to export geometry displayed
        /// </summary>
        public static bool CADWindowsShowExportButton = true;

        /// <summary>
        /// If true, button to zoom extents displayed
        /// </summary>
        public static bool CADWindowsShowZEButton = true;

        /// <summary>
        /// If true, button to hide show coord arrows displayed
        /// </summary>
        public static bool CADWindowsShowCoordArrowsButton = true;



        /// <summary>
        /// If true, button to hide add object displayed
        /// </summary>
        public static bool CADWindowsShowAddObjButton = true;

        /// <summary>
        /// These are generated for the CAD window so that clients can retrieve a 3D object only knowing its GUID.
        /// </summary>
        public static long CADMaxGUIDs = 10000;
        /// <summary>
        /// If true, connection lines go through nodes.This makes canvas regeneration faster.
        /// </summary>
        public static bool connsCanIntersectNodes = false;

        /// <summary>
        /// Solid nodes cannot intersect. This is a global overriding setting which when set to true allows solid nodes to intersect as well.
        /// </summary>
        public static bool nodesCanIntersect = false;

        /// <summary>
        /// Width of the border drawn around menus holding draggable modules.Default is one pixel;
        /// </summary>
        public static double moduleMenuBorderWidth = 1.0;

        /// <summary>
        /// Spacing between dragging buttons. Default is 5 pixels;
        /// </summary>
        public static double moduleButtonSpacing = 5.0;


        ///// <summary>
        ///// If true, in server mode node custom renderer images are exported on own thread, therefore faster.
        ///// Can mess with imported node custom renderer models that have lines and points.
        ///// </summary>
        //public static bool allowServerMultiThreadNCRsave = true;

        /// <summary>
        /// Extension when saving node custom renderer files from the server. . png and .jpg are valied.
        /// </summary>
        public static string NCRImageSaveExtension = ".png";

        /// <summary>
        /// If true, string ASCII STL representations of nodes with custom renderers are stored.
        /// This only happens for servers who update fully (oflag set when starting server)
        /// STL text directly retrieved by client with getnoderendererSTLstring_|_nodeID
        /// </summary>
        public static bool ServerexportSTLA = false;

        /// <summary>
        /// If true,  3D OBJ (folder) representations of nodes with custom renderers are saved.
        /// This only happens for servers who update fully (oflag set when starting server)
        /// OBJ files data retrieved by client with getnoderendererOBJ_|_nodeID
        /// </summary>
        internal static bool ServerExportOBJ = false;

        /// <summary>
        /// If false, hidden nodes and connections are not exported. This is independent of the canvas state (locked or unlocked). Default is false.
        /// </summary>
        public static bool serverExportHiddenNodes = false;

        /// <summary>
        /// If true, image files representations of nodes with custom renderers are saved.
        /// This only happens for servers who update fully (flag set when starting server)
        /// Image data retrieved by client directly with getnoderendererimage_|_nodeID
        /// Set image file extension with PUPPIGUISettings.NCRImageSaveExtension variable
        /// </summary>
        public static bool ServerExportImage = true;


        /// <summary>
        /// If true, Model3D representations of nodes with custom renderers are saved.
        /// This only happens for servers who update fully (flag set when starting server)
        /// STL text rendered by server and retrieved with getnoderendererSTLstring_|_nodeID
        /// The server canvas runs faster when ServerSaveModel3D is true and ServerexportSTLA and ServerExportImage are false but data retrieval by client takes longer
        /// </summary>
        public static bool ServerSaveModel3D = true;

        /// <summary>
        /// Built-in delay for handling async requests in ms.Minimum is 100 ms.
        /// </summary>
        public static int HTTPServerProcessDelay = 100;

        /// <summary>
        /// Sets how many sides circular elements in custom renderers are created with.
        /// </summary>
        public static int customRendererCircleSides = 16;

        //for for loops mostly
        internal static double numberMatchToler = 0.0000001;
        /// <summary>
        /// When rendering node custom renderers as images for client-server operations, this controls the number of pixels/ canvas unit of the image.
        /// </summary>
        public static int nodeImagePixelPerUnit = 100;

        /// <summary>
        /// Node and IO captions. Requires valid FontFamily friendly name.Default is Arial
        /// </summary>
        public static string canvasCaptionsFontName = "Arial";

        internal static FontFamily cacaFoFa = null;


        /// <summary>
        /// Buttom menu title and captions.Requires valid FontFamily friendly name.Default is Helvetica
        /// </summary>
        public static string buttonMenuFontName = "Helvetica";

        internal static FontFamily bumeFoFa = null;

        /// <summary>
        /// If set to true, node inputs and outputs are enlarged depending on camera distance when mouse goes over them.
        /// </summary>
        public static bool popInputsOutputs = true;

        /// <summary>
        /// If true, PUPPIModules which are constructors are shown slightly different than regular menu drag buttons. Default is true.
        /// </summary>
        internal static bool highlightConstructorsInMenus = true;

        /// <summary>
        /// If using splineConnections, how many segments/ node spacing value each straight segment is split in for generating spline.
        /// </summary>
        internal static int numberSplineSegments = 20;
        /// <summary>
        /// if true, short connections and start and end portions of connections on base are drawn as splines
        /// </summary>
        public static bool splineConnections = true;

        /// <summary>
        /// If set to true, base level regions where connections change direction are not blocked off. Set to false for faster but messier rendering of connection lines.
        /// </summary>
        public static bool connectionFreeCorners = false;

        /// <summary>
        /// Using multi threading will make rendering and running programs faster. Disable only for debugging.
        /// </summary>
        internal static bool useMultiThreading = false;

        /// <summary>
        /// If true, when the user drags a module onto the canvas, the cursor will be followed by a drawing of the module button. Default is true.
        /// </summary>
        internal static bool drawModuleDragToCanvas = true;

        /// <summary>
        /// If true, the user can double click on an output and then double click on inputs to make connections.
        /// </summary>
        public static bool doubleClickIOConnect = false;

        /// <summary>
        /// If enabled, the user will see a line when dragging from an output to an input. Default is true;
        /// </summary>
        public static bool drawLineWhenConnecting = true;

        /// <summary>
        /// If true, the user will see a line from the start point of the gesture to the end point of the gesture over a node. Default is true;
        /// </summary>
        public static bool drawGestureLine = true;

        /// <summary>
        /// If true, status updates are displayed on the bottom left corner of the canvas
        /// </summary>
        public static bool displayStatusOnCanvas = true;

        /// <summary>
        /// If true, hovering over nodes and inputs brings up a semi-transparent large caption
        /// </summary>
        public static bool displayInfoHover = true;


        /// <summary>
        /// Hover Info Red color fraction. Default is 0.5
        /// </summary>
        public static double hoverInfo_Red = 0.5;
        /// <summary>
        /// Hover Info Green color fraction. Default is 0.7
        /// </summary>
        public static double hoverInfo_Green = 0.8;
        /// <summary>
        /// Hover Info Blue color fraction. Default is 0.5
        /// </summary>
        public static double hoverInfo_Blue = 0.5;
        /// <summary>
        /// Hover Info Alpha (transparency) fraction. Default is 0.3 (Semi Transparent)
        /// </summary>
        public static double hoverInfo_Alpha = 0.25;

        /// <summary>
        /// Hover Info Font size. Default is 40;
        /// </summary>
        public static double hoverInfo_Size = 40;

        /// <summary>
        /// If true, the user can double click on a module and then use right click to add node on canvas or other nodes.
        /// Default is false. Setting this to true is recommended for tablets or trackpad devices.
        /// </summary>
        public static bool addNodeOnModuleDoubleClick = false;

        /// <summary>
        /// Number of pixels around detected touch which to find hits on a tablet, since finger is not as accurate as mouse pointer. Default is 10px.
        /// </summary>
        public static int tabletTouchRange = 10;


        /// <summary>
        /// this key plus delete deletes the whole stack, plus copy key copies selection, plus paste key pastes on canvas or node.Deafult is Left Ctrl
        /// </summary>
        public static Key operationModifierKey = Key.LeftCtrl;


        /// <summary>
        /// When user pushes this key over a node it gets deleted. Default is DEL key.
        /// </summary>
        public static Key deleteNodeKey = Key.Delete;

        /// <summary>
        /// When user pushes this key selection gets copied. Only works with modifier key. Default is C.
        /// </summary>
        public static Key copySelKey = Key.C;

        /// <summary>
        /// When user pushes this key selection gets pasted. Only works with modifier key.
        /// </summary>
        public static Key pasteKey = Key.V;

        /// <summary>
        /// When user pushes this key the last action is undone. Only works with modifier key.
        /// </summary>
        public static Key undoKey = Key.Z;

        /// <summary>
        /// When user pushes this key all nodes on canvas selected. Only works with modifier key.
        /// </summary>
        public static Key selectAllKey = Key.A;

        /// <summary>
        /// When user pushes this key file open dialog appears. Only works with modifier key.
        /// </summary>
        public static Key openFileKey = Key.O;


        /// <summary>
        /// When user pushes this key file save dialog appears. Only works with modifier key.
        /// </summary>
        public static Key saveFileKey = Key.S;

        /// <summary>
        /// When user pushes this key all nodes on canvas deselected. Only works with modifier key.
        /// </summary>
        public static Key selectNoneKey = Key.N;

        /// <summary>
        /// When user pushes this key the last action is redone. Only works with modifier key.
        /// </summary>
        public static Key redoKey = Key.Y;

        /// <summary>
        ///If set to true it Post-processes connections to remove overlapping connections going opposite ways; Default is true.
        /// </summary>
        public static bool removeOverlaps = true;
        /// <summary>
        ///Smoothes small wiggles in conenctions. might cause connection overlap, see offsetSmallConnections. Default is true.
        /// </summary>
        public static bool smoothConnections = true;
        /// <summary>
        /// If enabled, small connection line regions are offset at random to prevent overlap. Default is true.
        /// </summary>
        internal static bool offsetSmallConnections = false;

        /// <summary>
        /// The distance at which the camera stops rendering;Only has effect  in 3D mode.
        /// </summary>
        public static double cameraFarPlaneDistance = 1000;
        /// <summary>
        /// if enabled, panning buttons displayed on screen. Automatically enabled for tablet mode.
        /// </summary>
        public static bool displayCameraControlButtons = false;
        /// <summary>
        /// if enabled, left click can be forced to perform as right click from a button on the canvas.Panning buttons displayed on screen.
        /// </summary>
        public static bool tabletMode = false;
        /// <summary>
        /// Canvas rendering mode.
        /// </summary>
        public enum CanvasModeEnum { ThreeDimensional, TwoDimensional }


        /// <summary>
        /// Model fit inside default node box size mode. To be used with custom renderers and ModelVisual3D objects. If enabled various scaling can occur when adding models to renderer. 
        /// </summary>
        public enum ModelFitInNodeMode { OriginalSize, FitOnlyBase, Fit }


        /// <summary>
        /// Connection rendering mode.
        /// </summary>
        public enum ConnModeEnum { Solid, Wire }

        /// <summary>
        /// If true, the grid based on which nodes are aligned will be displayed on the XY plane.
        /// </summary>
        public static bool showGridOnCanvas = true;

        /// <summary>
        /// Grid lines thickness. Default is 0.01;
        /// </summary>
        public static double gridThickness = 0.01;

        /// <summary>
        /// Grid Red color fraction. Default is 0.2
        /// </summary>
        public static double grid_Red = 0.2;
        /// <summary>
        /// Grid Green color fraction. Default is 0.2
        /// </summary>
        public static double grid_Green = 0.2;
        /// <summary>
        /// Grid Blue color fraction. Default is 0.2
        /// </summary>
        public static double grid_Blue = 0.2;
        /// <summary>
        /// Grid Alpha (transparency) fraction. Default is 1 (Opaque)
        /// </summary>
        public static double grid_Alpha = 1;


        /// <summary>
        /// Fraction of node diagonal drag distance that causes a drag gesture to be recorded as such. Default is 0.05 (20 gradations);
        /// </summary>
        public static double dragGestureRecordFraction = 0.05;
        /// <summary>
        /// Number of runs of a module before it stops the code and throws a stack overflow which will abort the PUPPI Program.
        /// </summary>
        public static long stackOverflowGuard = 1000;
        /// <summary>
        /// The visual programming files will be saved with this extension.
        /// </summary>
        public static string saveFileExtension = ".xml";
        /// <summary>
        /// WHen the canvas runs in 2d mode: 
        /// -camera is locked and bases don't accept children.
        /// -loading models saved in 3D while in 2d mode might yield errors.
        ///  -automatically sets maxBaseChilds and maxFloorChilds to zero.
        ///  Default is 3D.
        /// </summary>
        public static CanvasModeEnum canvasMode = CanvasModeEnum.ThreeDimensional;
        /// <summary>
        /// Solid connections have width that changes with zoom (pipes in 3D and ribbons in 2D mode) whereas wire connections are rendered as lines.Default is wire.
        /// </summary>
        public static ConnModeEnum connectionRenderMode = ConnModeEnum.Wire;
        /// <summary>
        /// Chamfers corners depth ratio to smallest node dimension. From 0 to 0.25;
        /// Only works in 3D mode and rounded corners are not chamfered.
        /// </summary>
        public static double chamferCornerDepth = 0;
        /// <summary>
        /// Round node and input/output corner radius ratio to node side. From 0 to 0.33. Default is 0.2;
        /// </summary>
        public static double roundedCornerRadius = 0.2;
        /// <summary>
        /// Round connection corner radius ratio to local connection segment length. From 0 to 0.33. Default is 0.2;
        /// </summary>
        public static double roundedConnRadius = 0.2;

        /// <summary>
        /// Starting Side of the node. Default 1
        /// </summary>
        public static double nodeSide = 1.0;
        /// <summary>
        /// Z Height of the node. Default 1
        /// </summary>
        public static double nodeHeight = 0.5;
        /// <summary>
        /// Z Height of Inputs and Outputs. Default 0.25
        /// </summary>
        public static double ioHeight = 0.25;
        /// <summary>
        /// X Height of inputs and outputs. Default 0.2
        /// </summary>
        public static double ioWidth = 0.2;
        /// <summary>
        /// Y Height of inputs and outputs. Default 0.2
        /// </summary>
        public static double ioLength = 0.2;
        /// <summary>
        /// Min Y spacing between inputs or outputs. Default 0.1
        /// </summary>
        public static double ioMinSpacing = 0.1;
        /// <summary>
        /// Starting text height on inputs and outputs. Default is 0.1
        /// </summary>
        public static double ioTextHeight = 0.1;
        /// <summary>
        /// Minimum spacing between nodes. Default is 0.5
        /// </summary>
        public static double nodeSpacing = 0.5;
        /// <summary>
        /// How much caption text is raised above boxes. Default is 0.001
        /// </summary>
        public static double textRaise = 0.001;
        /// <summary>
        /// How much connection pipes are raised above grid or objects. Default is .05
        /// </summary>
        public static double connRaise = 0.05;

        // public static double conndeltamove = 0.15;//5;

        //  public static double connmindeltamove = 0.05;

        //   public static double boxedgewidth = 0.001;
        /// <summary>
        /// When to stop trying to fit connections and just go straight through. Default is 100 iterations.
        /// </summary>
        public static int maxNumberTries = 100;

        //public static double desttoler = 0.1;

        //public static double ribwidth = 0.1;
        /// <summary>
        /// Thickness of a flat connection. Default is 0.01
        /// </summary>
        public static double ribThick = 0.01;
        /// <summary>
        /// For solid connections: pipe diameter in 3D or ribbon width in 2D. Default is 0.025. Also used to space out connections even when Wire setting used.
        /// </summary>
        public static double solidConnectionSize = 0.025;
        /// <summary>
        /// For wire connections. Line thickness in pixels.Default is 1;
        /// </summary>
        public static double wireConnectionSize = 1;

        /// <summary>
        /// How many sides a pipe connection will be rendered with. Default is 8.
        /// </summary>
        public static int pipeSides = 8;
        //this is for map connections
        /// <summary>
        /// Arrow tip scale factor for Map view connections.
        /// </summary>
        public static double arrowTip = 10;




        ///public static double connoffset = 0.1;

        //defualt for menu elements

        /// <summary>
        /// Width of menu Module menu buttons if not specified when creating a menu. Deafult is 100 px.
        /// </summary>
        public static double defaultMenuElementWidth = 100;
        /// <summary>
        /// Height of menu Module menu buttons if not specified when creating a menu. Deafult is 20 px.
        /// </summary>
        public static double defaultMenuElementHeight = 20;
        /// <summary>
        /// The font size for menus such as drop downs, right click, File, etc
        /// </summary>
        public static double dropDownMenuFontSize = 12;
        //default menu dimensions
        /// <summary>
        /// Width of menu Module menu window if not specified when creating a menu. Deafult is 100 px.
        /// </summary>
        public static double defaultMenuWindowWidth = 100;
        /// <summary>
        /// Height of menu Module menu window if not specified when creating a menu. Deafult is 20 px.
        /// </summary>
        public static double defaultMenuWindowHeight = 20;
        /// <summary>
        /// Maximum number of Module buttons per menu row if not specified. Default is 10 
        /// </summary>
        public static int defaultMenuMaxPerRow = 10;
        /// <summary>
        /// General tolerance for matching position. Default is 0.001
        /// </summary>
        internal static double errF = 0.001;
        /// <summary>
        /// Tolerance for colliniarity. Default is 0.001
        /// </summary>
        internal static double collinearToler = 0.001;
        /// <summary>
        /// Maximum number of connection lines going in the same direction sharing a grid space. Default is 12.
        /// </summary>
        public static int maxConnPerSpace = 12;

        //public static int skipconns = 1;
        /// <summary>
        /// Node box intersect toklerance. Default is 0.001
        /// </summary>
        internal static double intersectToler = 0.001;

        //color customization menu button
        /// <summary>
        /// Menu button red fraction if not specified.Default is 0.1
        /// </summary>
        public static double menuButtonRed = 0.1;
        /// <summary>
        /// Menu button green fraction if not specified.Default is 0.9
        /// </summary>
        public static double menuButtonGreen = 0.9;
        /// <summary>
        /// Menu button blue fraction if not specified.Default is 1.0
        /// </summary>
        public static double menuButtonBlue = 1.0;
        /// <summary>
        /// Menu button alpha(transparency) fraction if not specified.Default is 1.0 (opaque)
        /// </summary>
        public static double menuButtonAlpha = 1.0;

        //menu background default
        /// <summary>
        /// Menu Background red fraction if not specified.Default is 0.1
        /// </summary>
        public static double menuBackgroundRed = 1.0;
        /// <summary>
        /// Menu Background green fraction if not specified.Default is 0.9
        /// </summary>
        public static double menuBackgroundGreen = 1.0;
        /// <summary>
        /// Menu Background blue fraction if not specified.Default is 1.0
        /// </summary>
        public static double menuBackgroundBlue = 1.0;
        /// <summary>
        /// Menu Background alpha(transparency) fraction if not specified.Default is 1.0 (opaque)
        /// </summary>
        public static double menuBackgroundAlpha = 1.0;


        //menu border

        /// <summary>
        /// Menu Border Red fraction if not specified.Default is 0.1
        /// </summary>
        public static double menuBorderRed = 0.1;
        /// <summary>
        /// Menu Border Green fraction if not specified.Default is 0.1
        /// </summary>
        public static double menuBorderGreen = 0.1;
        /// <summary>
        /// Menu Border Blue fraction if not specified.Default is 0.5
        /// </summary>
        public static double menuBorderBlue = 0.5;
        /// <summary>
        /// Menu Border Alpha(transparency) fraction if not specified.Default is 1.0 (opaque)
        /// </summary>
        public static double menuBorderAlpha = 1.0;

        /// <summary>
        /// Selection rectangle overlay Red color fraction. Default is 0.5
        /// </summary>
        public static double selectRectangle_Red = 0.5;
        /// <summary>
        /// Selection rectangle overlay Green color fraction. Default is 0.85
        /// </summary>
        public static double selectRectangle_Green = 0.85;
        /// <summary>
        /// Selection rectangle overlay Blue color fraction. Default is 0.85
        /// </summary>
        public static double selectRectangle_Blue = 0.85;
        /// <summary>
        /// Selection rectangle overlay Alpha (transparency) fraction. Default is 0.5  (semi-transparent)
        /// </summary>
        public static double selectRectangle_Alpha = 0.5;


        /// <summary>
        /// Node Red color fraction. Default is 0.8
        /// </summary>
        public static double node_Red = 0.8;
        /// <summary>
        /// Node Green color fraction. Default is 0.85
        /// </summary>
        public static double node_Green = 0.85;
        /// <summary>
        /// Node Blue color fraction. Default is 0.85
        /// </summary>
        public static double node_Blue = 0.85;
        /// <summary>
        /// Node Alpha (transparency) fraction. Default is 1.0 (opaque)
        /// </summary>
        public static double node_Alpha = 1;
        /// <summary>
        /// Node Clicked on Red color fraction. Default is 0.2
        /// </summary>
        public static double nodeClicked_Red = 0.2;
        /// <summary>
        /// Node Clicked on Green color fraction. Default is 1
        /// </summary>
        public static double nodeClicked_Green = 1;
        /// <summary>
        /// Node Clicked on Blue color fraction. Default is 0.8
        /// </summary>
        public static double nodeClicked_Blue = 0.8;
        /// <summary>
        /// Node Clicked on Alpha (transparency) fraction. Default is 1 (opaque)
        /// </summary>
        public static double nodeClicked_Alpha = 1;

        /// <summary>
        /// Node Selected on Red color fraction. Default is 0.2
        /// </summary>
        public static double nodeSelected_Red = 0.6;
        /// <summary>
        /// Node Selected on Green color fraction. Default is 1
        /// </summary>
        public static double nodeSelected_Green = 1;
        /// <summary>
        /// Node Selected on Blue color fraction. Default is 0.8
        /// </summary>
        public static double nodeSelected_Blue = 0.8;
        /// <summary>
        /// Node Selected on Alpha (transparency) fraction. Default is 1 (opaque)
        /// </summary>
        public static double nodeSelected_Alpha = 1;

        /// <summary>
        /// Node input Red color fraction. Default is 0.8
        /// </summary>
        public static double input_Red = 0.8;
        /// <summary>
        /// Node input Green color fraction. Default is 0.8
        /// </summary>
        public static double input_Green = 0.8;
        /// <summary>
        /// Node input Blue color fraction. Default is 0
        /// </summary>
        public static double input_Blue = 0;
        /// <summary>
        /// Node input Alpha (transparency) fraction. Default is 1 (opaque)
        /// </summary>
        public static double input_Alpha = 1;

        ///// <summary>
        ///// Node clicked on input red color fraction. Default is 0.2
        ///// </summary>
        //public static double inputsel_Red = 1.0;
        //public static double inputsel_Green = 1.0;
        //public static double inputsel_Blue = 0.5;
        //public static double inputsel_Alpha = 1;

        /// <summary>
        /// Node output Red color fraction. Default is 0.2
        /// </summary>
        public static double output_Red = 0.2;
        /// <summary>
        /// Node output Green color fraction. Default is 1
        /// </summary>
        public static double output_Green = 1;
        /// <summary>
        /// Node output Blue color fraction. Default is 0.2
        /// </summary>
        public static double output_Blue = 0.2;
        /// <summary>
        /// Node output Alpha (transparency) fraction. Default is 1 (Opaque)
        /// </summary>
        public static double output_Alpha = 1;

        ////hovering over output
        //public static double outputsel_Red = 0.5;
        //public static double outputsel_Green = 1;
        //public static double outputsel_Blue = 0.5;
        //public static double outputsel_Alpha = 1;

        //when hoveirng over connections, change alpha by


        /// <summary>
        /// When the mouse cursor is over a connection or when dragging outputs to conenct to inputs
        /// nodes become more transparent in order to aid in visualization. This is the factor by which alpha is reduced 
        /// and its default value is 0.3
        /// </summary>
        public static double hover_Alpha_Reduction_Factor = 0.3;
        //empty inputs
        /// <summary>
        /// Red color fraction for an unconnected Input. Default value is 0.65
        /// </summary>
        public static double emptyInput_Red = 0.65;
        /// <summary>
        /// Green color fraction for an unconnected Input. Default value is 0.65
        /// </summary>
        public static double emptyInput_Green = 0.65;
        /// <summary>
        /// Blue color fraction for an unconnected Input. Default value is 0.65
        /// </summary>
        public static double emptyInput_Blue = 0.65;
        /// <summary>
        /// Alpha (transparency) fraction for an unconnected Input. Default value is 1 (opaque)
        /// </summary>
        public static double emptyInput_Alpha = 1;

        //empty optional
        /// <summary>
        /// Red color fraction for an unconnected optional Input. Default value is 0.5
        /// </summary>
        public static double emptyOptInput_Red = 0.5;
        /// <summary>
        /// Green color fraction for an unconnected optional Input. Default value is 0.5
        /// </summary>
        public static double emptyOptInput_Green = 0.5;
        /// <summary>
        /// Blue color fraction for an unconnected optional Input. Default value is 1
        /// </summary>
        public static double emptyOptInput_Blue = 1;
        /// <summary>
        /// Alpha (transparency) fraction for an unconnected optional Input. Default value is 1 (opaque)
        /// </summary>
        public static double emptyOptInput_Alpha = 1;


        //connections from selected node
        /// <summary>
        /// Red color fraction for connections to and from a node clicked on. Default value is 0.2
        /// </summary>
        public static double selconn_Red = 0.2;
        /// <summary>
        /// Green color fraction for connections to and from a node clicked on. Default value is 0.1
        /// </summary>
        public static double selconn_Green = 0.1;
        /// <summary>
        /// Blue color fraction for connections to and from a node clicked on. Default value is 0.1
        /// </summary>
        public static double selconn_Blue = 0.1;
        /// <summary>
        /// Alpha (transparency) fraction for connections to and from a node clicked on. Default value is 1 (opaque)
        /// </summary>
        public static double selconn_Alpha = 1;

        //background of 3d window
        /// <summary>
        /// Background of canvas window Red color fraction. Default value is 1.
        /// </summary>
        public static double background_Red = 1;
        /// <summary>
        /// Background of canvas window Green color fraction. Default value is 1.
        /// </summary>
        public static double background_Green = 1;
        /// <summary>
        /// Background of canvas window Blue color fraction. Default value is 1.
        /// </summary>
        public static double background_Blue = 1;
        /// <summary>
        /// Background of canvas window Alpha fraction. Default value is 1 (opaque).
        /// </summary>
        public static double background_Alpha = 1;
        /// <summary>
        /// Marker Red color fraction. Default value is 0.
        /// </summary>
        public static double marker_Red = 0;
        /// <summary>
        /// Marker Green color fraction. Default value is 0.
        /// </summary>
        public static double marker_Green = 0;
        /// <summary>
        /// Marker Blue color fraction. Default value is1.
        /// </summary>
        public static double marker_Blue = 1;
        /// <summary>
        /// Marker Alpha (transparency) fraction. Default value is 0.5
        /// </summary>
        public static double marker_Alpha = 0.5;
        /// <summary>
        /// Marker radius. Default value is 0.2.
        /// </summary>
        public static double markerRadius = 0.2;

        /// <summary>
        /// Maximum number of nodes that can go on a base node. Include nodes stacked up.Default is 100.
        /// </summary>
        public static int maxBaseChilds = 100;
        /// <summary>
        /// Number of digits to display from double numbers on inputs and outputs .
        /// </summary>
        public static int showDigits = 2;

        internal static int maxFloorChilds = 1;

        //when camera is moved while dragging
        internal static double cameraDragPanFactor = 0.05;
        //height of menu atop windows
        /// <summary>
        /// Pixel height on the menu buttons at the top of the canvas.
        /// </summary>
        public static double windowButtonHeight = 15;
        //for geometry, how much we push in for capping to ensure we get the contours
        internal static double geomCapToler = 0.001;
        //for geometry, weld relative tolerance.usually multiplied by a number
        internal static double geomWeldToler = 0.01;



        /// <summary>
        /// This is the pre initialization function. It needs to run after the PUPPIGUISettings were changed but before the PUPPICanvas is created in order to validate the settings.
        /// </summary>
        public static void initializeSettings()
        {

            initmysettings();

        }
        internal static void initmysettings()
        {
            if (CADViewManipulatorSize <= 0) CADViewManipulatorSize = 1.0;

            if (moduleMenuBorderWidth < 0)
                moduleMenuBorderWidth = 1;

            if (HTTPServerProcessDelay <= 100) HTTPServerProcessDelay = 100;
            System.Globalization.CultureInfo culture = System.Globalization.CultureInfo.CreateSpecificCulture("en-US");

            Thread.CurrentThread.CurrentCulture = culture;
            Thread.CurrentThread.CurrentUICulture = culture;
            if (customRendererCircleSides < 6) customRendererCircleSides = 6;

            if (nodeImagePixelPerUnit <= 0)
                nodeImagePixelPerUnit = 50;

            if (hoverInfo_Size <= 0)
            {
                hoverInfo_Size = 20;
            }

            try
            {
                cacaFoFa = new FontFamily(canvasCaptionsFontName);
            }
            catch
            {
                cacaFoFa = null;
            }
            if (cacaFoFa == null) cacaFoFa = new FontFamily("Arial");


            try
            {
                bumeFoFa = new FontFamily(buttonMenuFontName);
            }
            catch
            {
                bumeFoFa = null;
            }
            if (bumeFoFa == null) bumeFoFa = new FontFamily("Helvetica");


            if (PUPPIGUISettings.tabletTouchRange <= 0) PUPPIGUISettings.tabletTouchRange = 10;
            if (PUPPIGUISettings.tabletTouchRange > 100) PUPPIGUISettings.tabletTouchRange = 10;

            if (PUPPIGUISettings.cameraFarPlaneDistance <= 0) PUPPIGUISettings.cameraFarPlaneDistance = 1000;
            if (PUPPIGUISettings.dragGestureRecordFraction <= 0 || PUPPIGUISettings.dragGestureRecordFraction > 1)
            {
                PUPPIGUISettings.dragGestureRecordFraction = 0.05;
            }
            if (PUPPIGUISettings.showDigits <= 0) PUPPIGUISettings.showDigits = 2;
            //unpack helix cause sometimes it doesn't work embedded
            string assemblyFolder = System.IO.Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
            if (!File.Exists(assemblyFolder + @"\HelixToolkit.Wpf.dll"))
            {
                WriteHelixResourceToFile(assemblyFolder + @"\HelixToolkit.Wpf.dll");
            }

            PUPPIruntimesettings.extensionvalidate();

            PUPPIGUI.PUPPIruntimesettings.mycallerassembly = Assembly.GetCallingAssembly();

            if (PUPPIGUISettings.gridThickness <= 0) PUPPIGUISettings.gridThickness = 0.01;


            fastconstants.setme();
            //if in 2d mode we need to override 
            if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
            {
                PUPPIGUISettings.maxFloorChilds = 0;
                PUPPIGUISettings.maxBaseChilds = 0;
                PUPPIGUISettings.nodeHeight = 0.1;
                PUPPIGUISettings.ioHeight = 0.05;
                //only chamfer in 3d
                PUPPIGUISettings.chamferCornerDepth = 0;
            }
            if (PUPPIGUISettings.chamferCornerDepth > 0.25) PUPPIGUISettings.chamferCornerDepth = 0.25;
            if (PUPPIGUISettings.roundedCornerRadius > 0.33) PUPPIGUISettings.roundedCornerRadius = 0.33;
            if (PUPPIGUISettings.roundedConnRadius > 0.33) PUPPIGUISettings.roundedConnRadius = 0.33;
            if (PUPPIGUISettings.roundedConnRadius <= 0) PUPPIGUISettings.splineConnections = false;
            //if (PUPPIGUISettings.roundedConnRadius <= 0 && PUPPIGUISettings.splineConnections)
            //{
            //    PUPPIGUISettings.roundedConnRadius = 0.2;
            //}
            if (PUPPIGUISettings.numberSplineSegments < 3)
            {
                PUPPIGUISettings.numberSplineSegments = 3;
            }
            try
            {
                try { AppDomain.CurrentDomain.AssemblyResolve -= new ResolveEventHandler(CurrentDomain_AssemblyResolve); }
                catch { }
                AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(CurrentDomain_AssemblyResolve);
            }
            catch
            {

            }
            if (PUPPIGUISettings.maxConnPerSpace <= 1) PUPPIGUISettings.maxConnPerSpace = 2;
            if (PUPPIGUISettings.nodeSide <= 0 || PUPPIGUISettings.nodeSpacing <= 0)
            {
                PUPPIGUISettings.nodeSide = 1.0;
                PUPPIGUISettings.nodeSpacing = 0.5;
            }

            int div = (int)(PUPPIGUISettings.nodeSide / PUPPIGUISettings.nodeSpacing);
            if (div == 0) div = 1;
            PUPPIGUISettings.nodeSpacing = PUPPIGUISettings.nodeSide / div;

            //disable tablet stylus touch
            if (PUPPIGUISettings.tabletMode) DisableWPFTabletSupport();

            if (PUPPIGUISettings.ioWidth > PUPPIGUISettings.nodeSpacing * 0.5) PUPPIGUISettings.ioWidth = PUPPIGUISettings.nodeSpacing * 0.5;
            if (PUPPIGUISettings.ioLength > PUPPIGUISettings.nodeSide) PUPPIGUISettings.ioLength = PUPPIGUISettings.nodeSide * 0.5;
            if (PUPPIGUISettings.ioHeight > PUPPIGUISettings.nodeHeight) PUPPIGUISettings.ioHeight = PUPPIGUISettings.nodeHeight * 0.5;

            PUPPICanvas.settingsInitialized = true;
        }
        static void DisableWPFTabletSupport()
        {
            // Get a collection of the tablet devices for this window.  
            var devices = Tablet.TabletDevices;

            if (devices.Count > 0)
            {
                // Get the Type of InputManager.
                var inputManagerType = typeof(InputManager);

                // Call the StylusLogic method on the InputManager.Current instance.
                var stylusLogic = inputManagerType.InvokeMember("StylusLogic",
                            BindingFlags.GetProperty | BindingFlags.Instance | BindingFlags.NonPublic,
                            null, InputManager.Current, null);

                if (stylusLogic != null)
                {
                    //  Get the type of the stylusLogic returned from the call to StylusLogic.
                    var stylusLogicType = stylusLogic.GetType();

                    // Loop until there are no more devices to remove.
                    while (devices.Count > 0)
                    {
                        // Remove the first tablet device in the devices collection.
                        stylusLogicType.InvokeMember("OnTabletRemoved",
                                BindingFlags.InvokeMethod | BindingFlags.Instance | BindingFlags.NonPublic,
                                null, stylusLogic, new object[] { (uint)0 });
                    }
                }

            }
        }
        internal static System.Reflection.Assembly CurrentDomain_AssemblyResolve(object sender, ResolveEventArgs args)
        {
            string dllName = args.Name.Contains(',') ? args.Name.Substring(0, args.Name.IndexOf(',')) : args.Name.Replace(".dll", "");

            dllName = dllName.Replace(".", "_");

            if (dllName.EndsWith("_resources")) return null;
            string an = Assembly.GetExecutingAssembly().GetName().Name;
            System.Resources.ResourceManager rm = new System.Resources.ResourceManager(an + ".Properties.Resources", System.Reflection.Assembly.GetExecutingAssembly());

            byte[] bytes = (byte[])rm.GetObject(dllName);

            if (bytes != null && bytes.Length > 0) return System.Reflection.Assembly.Load(bytes); else return null;
        }
        internal static void WriteHelixResourceToFile(string fileName)
        {

            string dllName = "HelixToolkit_Wpf";

            if (dllName.EndsWith("_resources")) return;
            string an = Assembly.GetExecutingAssembly().GetName().Name;
            System.Resources.ResourceManager rm = new System.Resources.ResourceManager(an + ".Properties.Resources", System.Reflection.Assembly.GetExecutingAssembly());

            byte[] bytes = (byte[])rm.GetObject(dllName);
            File.WriteAllBytes(fileName, bytes);


        }
    }
    //this holds stuff that is used to make things faster from constants divisions
    internal static class fastconstants
    {
        internal static double oneverspacing = 1.0;
        internal static double dds = 0.1;

        internal static void setme()
        {
            oneverspacing = 1.0 / PUPPIGUISettings.nodeSpacing;
            dds = PUPPIGUISettings.nodeSpacing / (double)(PUPPIGUISettings.maxConnPerSpace + 1);

        }
    }



    internal sealed partial class PUPPICanvas : Window
    {
        TextBlock hoverSemiTransparent;
        internal PUPPICustomRenderer staticVisuals;
        internal bool thiscanvasdefinitelylocked = false;
        internal static bool settingsInitialized = false;

        //thread safe stuff for server
        internal static string currentXMLRepServer;
        internal static string currentCanvasStatusServer;
        internal static ConcurrentDictionary<string, string> nodeRendererImageFilesServer;
        internal static ConcurrentDictionary<string, string> nodeRendererOBJFolderServer;
        internal static ConcurrentDictionary<string, string> nodeRendererSTLServer;
        internal static ConcurrentDictionary<string, string> nodeInfoXMLServer;
        internal static ConcurrentDictionary<string, List<Model3D>> nodeRendererModel3DServer;

        //mostly used for server
        internal DateTime lastChanged;

        internal Dictionary<string, PUPPIModule> cvavailablePUPPIModules;
        ////initiate que for updates
        //      PUPPIruntimesettings.nodestoupdate.Clear();
        //      PUPPIruntimesettings.currentstate = PUPPIruntimesettings.graphicalnodeupdatestates.IsNotReady;   



        //              //updates nodes in que
        //      PUPPIruntimesettings.currentstate = PUPPIruntimesettings.graphicalnodeupdatestates.DoUpdate;
        //      for (i = 0; i < PUPPIruntimesettings.nodestoupdate.Count;i++ )
        //      {
        //          PUPPIruntimesettings.nodestoupdate[i].update_caption();
        //          PUPPIruntimesettings.nodestoupdate[i].update_inouts();
        //      }
        //when we do deferred update       
        List<ModViz3DNode> nodestoupdate;
        //so that we don't update connectors until it's finished
        internal bool blockconnupdates = false;
        //so we don't fit roots all the time
        internal bool blockfitroots = false;

        //default material for nodes
        internal Material node_default_mat;
        //and the transparent version
        internal Material node_tran_default_mat;
        //default material for mouse node
        internal Material node_clicked_default_mat;

        internal Material drag_rect_default_mat;

        //default material for selected nodes
        internal Material node_selected_default_mat;

        //for when we are dragging
        bool dragip = false;
        //default material for nodes
        internal Material input_default_mat;
        internal Material emptyInput_default_mat;
        internal Material emptyoptionalinput_default_mat;
        //default material for nodes
        internal Material output_default_mat;
        //default material for mouse marker
        internal Material marker_default_mat;
        //default material for selected connections
        internal Material connsel_default_mat;
        internal MaterialGroup connsel_default_matg;
        //store information from conencting with double click
        internal string doubleClickedOutput = "";
        internal string fileCurLdd = "";

        internal string my_old_pc_status = "New Canvas";

        internal BillboardTextVisual3D moduleDragMarker;
        internal string mDMtext = "";
        internal Material grid_default_mat;
        //default material for outer box of custom nodes
        internal Material customRenderBox_default_mat;
        //whether changes have been saved or not
        bool issaved;
        //clipboard
        //ModViz3DNode clipstacknode;
        //now clipboard a dictionary so we can put more stacks in
        internal Dictionary<string, ModViz3DNode> clipstacks;
        //we'll use xml formulation instead to be consistent
        internal string clipboardXMLRepresentation = "";

        //selection ,just nodeguids
        internal List<string> selstacks;
        HelixViewport3D hv;
        Frame frame3d;
        //know where we're putting stuff
        ModelVisual3D mousemarker;
        //know what's under mouse
        internal BillboardTextVisual3D objectUnderMouseText;

        //when we drag-select we show a rectangle
        ModelVisual3D dragSelectAreaRectangle;


        //line whenw e drag connection
        ArrowVisual3D nodeMoveArrowShow;
        Point3D nmasStart;
        //and actual start to make sure we don't move nodes for nothing
        Point3D nmasStartAc;
        //line whenw e drag connection
        LinesVisual3D dragConnectLineShow;
        Point3D dclsStart;
        //line for gesture
        //line whenw e drag connection
        LinesVisual3D gestureLineShow;
        Point3D glsStart;

        //when updating node in real time while dragging
        ModViz3DNode dragonMyNode = null;
        Point3D dragonMystart;
        //save renderer state in case gesture fails
        string dragonMyRe;


        // PerspectiveCamera mycamera;
        //holds the tree nodes and connectors
        //used for clicking on stuff

        internal Dictionary<string, ModViz3DNode> stacks;
        internal Dictionary<string, ModViz3DConn> connpaths;
        //save for undo/redo
        internal Dictionary<string, connectorpath> sconnpaths;

        //customr endering objects
        internal Dictionary<string, PUPPINodeCustomRenderer> customRenderers;
        internal Dictionary<Type, string> moduleRenderers;
        //these will be ignored when clicking on
        //for notes, grid etc
        ArrayList ignoreclick;
        ////clipboard
        //ModViz3DNode inclip;
        //whether entire stakc of nodes above it is copied or cut
        bool clipstack = false;

        //the child that has been highlighted
        internal int hvhlch = -1;

        AmbientLight light;
        //CombinedManipulator cm;
        MATraMu cm;
        internal GridLinesVisual3D gv3d;

        //internal Canvas canvasview;
        internal Grid canvasview;
        //right click mode,changes when double right clicking
        System.Windows.Input.MouseGesture rightclickmode;
        Button rotationmode;
        Button leftClickMode;
        //in tablet mode, switch tap
        Button tapMode;
        //MenuItem tabCameraPanUp;
        //MenuItem tabCameraPanDown;
        //MenuItem tabCameraPanLeft;
        //MenuItem tabCameraPanRight;
        Button tabCameraPanUp;
        Button tabCameraPanDown;
        Button tabCameraPanLeft;
        Button tabCameraPanRight;
        Button tabCameraPanMode;

        TextBlock pCanvasStatusUpdate;
        //for bigger identificatyion of nodes and inputs

        //pan/rotate mode flag-only in 3d
        bool cpm = true;

        PUPPINodeContextMenu noderightclickmenu;
        PUPPIInputConnectorContextMenu inputrightclickmenu;
        PUPPIOutputConnectorContextMenu outputrightclickmenu;
        PUPPICanvasContextMenu canvasrightclickmenu;
        //if using manipulator  we don't want to drag over inputs and outputs
        bool usingmanip = false;
        //if true, when clicking on nodes the manipulator shows up
        bool leftClickModeMove = true;
        //if true, forces right click tablet mode, if false, left click
        bool tabletForceRight = false;


        internal SynchronizedCollection<String> commandQueue;
        internal List<string> commandQueueResults;
        //does it on a thread
        internal void saveReponThread()
        {

            //new Thread(() =>
            //{
            //    Thread.CurrentThread.IsBackground = true;
            //    while (PUPPIruntimesettings.PUPPICurrentlySavingStatusForServer)
            //        Thread.Sleep(10);  

            //    PUPPIruntimesettings.PUPPICurrentlySavingStatusForServer = true;
            if (PUPPIGUISettings.serverExportHiddenNodes)
            {
                PUPPICanvas.currentXMLRepServer = saveCanvasRepresentationToXML();
            }
            else
            {
                PUPPICanvas.currentXMLRepServer = saveCanvasRepresentationToXMLNoHI();

            }
            //    PUPPIruntimesettings.PUPPICurrentlySavingStatusForServer = false;
            //}).Start();


        }
        //called when server started
        internal void doAnInitialServerUpdate()
        {
            if (PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning || PUPPIruntimesettings.PUPPICanvasHTTPServerIsRunning)
            {
                PUPPICanvas.currentCanvasStatusServer = readMyCanvasStatus();
                saveReponThread();
                foreach (ModViz3DNode m in stacks.Values)
                {
                    if (m != null && m.nodeCustomRenderer != null) m.exportMyNRenderer();
                }

            }
        }
        internal void runStringCanvasCommands()
        {
            ////multiple commands, block processing then run
            //if (commandQueue.Count > 1)
            //{
            PUPPIruntimesettings.processyesno = false;
            bool needsrerun = false;
            if (commandQueue.Count > 0) needsrerun = true;
            if (needsrerun) commandQueueResults.Clear();
            if (needsrerun) stopMouseEv();
            while (commandQueue.Count > 0)
            {
                string myc = commandQueue[0];
                if (commandQueue.Count > 0)
                    commandQueue.RemoveAt(0);
                string sss = interpretMyTextualCommand(myc);
                commandQueueResults.Add(sss);

            }
            PUPPIModel.Utilities.commandObjs.Clear();



            PUPPIruntimesettings.processyesno = PUPPIruntimesettings.liveupdate;
            if (needsrerun) runPUPPIprogram();
            if (needsrerun) resumeMouseEv();
            //}
            //else
            //{
            //    //one command, execute

            //    bool needsrerun = false;
            //    if (commandQueue.Count > 0) needsrerun = true;
            //    if (needsrerun) commandQueueResults.Clear();
            //    if (needsrerun) stopMouseEv();
            //    while (commandQueue.Count > 0)
            //    {
            //        string myc = commandQueue[0];
            //        if (commandQueue.Count > 0)
            //            commandQueue.RemoveAt(0);
            //        string sss = interpretMyTextualCommand(myc);
            //        commandQueueResults.Add(sss);

            //    }
            //    PUPPIModel.Utilities.commandObjs.Clear();

            //    if (needsrerun) resumeMouseEv();
            //}
        }
        internal string readMyCanvasStatus()
        {
            string rep = "";
            rep += "Canvas loaded: " + fileCurLdd + "\n";
            rep += "Number nodes: " + stacks.Count + "\n";
            rep += "Number connections " + connpaths.Count + "\n";
            rep += "Canvas is locked: " + thiscanvasdefinitelylocked.ToString() + "\n";
            return rep;
        }
        //all node info written for clients to get that
        internal void updateNodeInfoServer(string GUID)
        {
            if (stacks.ContainsKey(GUID))
            {

                ModViz3DNode mb = stacks[GUID];

                if (mb != null)
                {
                    if (PUPPICanvas.nodeInfoXMLServer.ContainsKey(mb.nodeGUID.ToString()))
                    {
                        PUPPICanvas.nodeInfoXMLServer[mb.nodeGUID.ToString()] = mb.ninfoXML();
                    }
                    else
                    {
                        PUPPICanvas.nodeInfoXMLServer.TryAdd(mb.nodeGUID.ToString(), mb.ninfoXML());
                    }
                }

            }

        }

        internal string getNCRFile(string ng)
        {
            if (stacks.ContainsKey(ng))
            {
                ModViz3DNode mv = stacks[ng];
                if (mv.nodeCustomRenderer == null)
                {
                    return "nullrenderer";
                }
                PUPPINodeCustomRenderer ncr = mv.nodeCustomRenderer;
                if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    if (ncr.model2D == null)
                    {
                        return "nullmodel";
                    }

                    if (File.Exists(System.IO.Path.GetTempPath() + "R" + ncr.name + "N" + ng + PUPPIGUISettings.NCRImageSaveExtension))
                    {
                        return System.IO.Path.GetTempPath() + "R" + ncr.name + "N" + ng + PUPPIGUISettings.NCRImageSaveExtension;
                    }
                    else
                    {
                        return "filenotfound";
                    }
                }
                else
                {
                    if (ncr.model3D == null)
                    {
                        return "nullmodel";
                    }
                    if (File.Exists(System.IO.Path.GetTempPath() + "R" + ncr.name + "N" + ng + PUPPIGUISettings.NCRImageSaveExtension))
                    {
                        return System.IO.Path.GetTempPath() + "R" + ncr.name + "N" + ng + PUPPIGUISettings.NCRImageSaveExtension;
                    }
                    else
                    {
                        return "filenotfound";
                    }
                }
            }
            else
            {
                return "nodenotfound";
            }
        }

        internal string expNCR2File(string ng)
        {
            if (stacks.ContainsKey(ng))
            {
                ModViz3DNode mv = stacks[ng];
                if (mv.nodeCustomRenderer == null)
                {
                    return "nullrenderer";
                }
                PUPPINodeCustomRenderer ncr = mv.nodeCustomRenderer;
                if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    if (ncr.model2D == null)
                    {
                        return "nullmodel";
                    }

                    return PUPPICAD.HelperClasses.utilities.renderModelVisual3D(ncr.model2D.cloneMyVisual(), "", "R" + ncr.name + "N" + ng);
                }
                else
                {
                    if (ncr.model3D == null)
                    {
                        return "nullmodel";
                    }
                    return PUPPICAD.HelperClasses.utilities.renderModelVisual3D(ncr.model3D.cloneMyVisual(), "", "R" + ncr.name + "N" + ng);
                }
            }
            else
            {
                return "notfound";
            }
        }

        internal string interpretMyTextualCommand(string myCommand)
        {
            string[] sep = { "_|_" };
            string[] myInput = myCommand.Split(sep, StringSplitOptions.None);
            try
            {
                if (myInput[0].ToLower() == "setinput")
                {
                    string nodeset = myInput[1];
                    int iset = Convert.ToInt16(myInput[2]);
                    //if (double.Parse()  )
                    //double vset = Convert.ToDouble(myInput[3]);
                    //make this reference to an arraylist storing objects

                    int vset = Convert.ToInt16(myInput[3]);
                    bool b = setMyNodeOnCanvasInput(nodeset, iset, PUPPIModel.Utilities.commandObjs[vset]);
                    if (b)
                        return "success";
                    else
                        return "failure";
                }
                //addNodeToCanvasCommand(double x,double y, PUPPIModel.PUPPIModule myModule)
                else if (myInput[0].ToLower() == "addnodetocanvascommand")
                {
                    Type tm = null;
                    string tName = myInput[3];
                    tm = PUPPIModel.AutomaticPUPPImodulesCreator.findTypeByName(tName);

                    if (tm == null)
                    {
                        throw new Exception("nullmodule");
                    }

                    object pm1 = System.Activator.CreateInstance(tm);
                    PUPPIModule mm = pm1 as PUPPIModule;
                    double myx = Convert.ToDouble(myInput[1]);
                    double myy = Convert.ToDouble(myInput[2]);
                    Point3D p = new Point3D(myx, myy, 0);
                    return addANodeToTheCanvas(p, mm).ToString();
                }
                //addNodeOnNodeCommand(string baseNodeGUID, PUPPIModel.PUPPIModule myModule  )
                else if (myInput[0].ToLower() == "addnodeonnodecommand")
                {
                    Type tm = null;
                    string tName = myInput[2];
                    tm = PUPPIModel.AutomaticPUPPImodulesCreator.findTypeByName(tName);

                    if (tm == null)
                    {
                        throw new Exception("nullmodule");
                    }
                    object pm1 = System.Activator.CreateInstance(tm);
                    PUPPIModule mm = pm1 as PUPPIModule;
                    int myG = Convert.ToInt16(myInput[1]);
                    return addNodeOnTopOfNodeToTheCanvas(myG, mm).ToString();
                }
                //connectNodesCommand(string sourceNodeGUID,int sourceNodeOutputIndex, string destinationNodeGUID, int destinationInputIndex)
                else if (myInput[0].ToLower() == "connectnodescommand")
                {
                    int sguid = Convert.ToInt16(myInput[1]);
                    int soi = Convert.ToInt16(myInput[2]);
                    int dguid = Convert.ToInt16(myInput[3]);
                    int di = Convert.ToInt16(myInput[4]);
                    bool b = connectNode2Node(sguid, soi, dguid, di);
                    if (b == true) return "success";
                    else return "failure";
                }
                //disconnectNodeInputCommand(string destinationNodeGUID, int destinationInputIndex)
                else if (myInput[0].ToLower() == "disconnectnodeinputcommand")
                {
                    int dguid = Convert.ToInt16(myInput[1]);
                    int di = Convert.ToInt16(myInput[2]);
                    bool b = disconnectANodesInput(dguid, di);
                    if (b == true) return "success";
                    else return "failure";

                }

                else if (myInput[0].ToLower() == "disconnectnodeoutputcommand")
                {

                    int di = Convert.ToInt16(myInput[2]);
                    bool b = discoAllNodeOutputs(myInput[1], di);
                    if (b == true) return "success";
                    else return "failure";

                }


                else if (myInput[0].ToLower() == "getnodeinformationxml")
                {
                    if (stacks.ContainsKey(myInput[1]) == false) return "notfound";
                    try
                    {
                        PUPPICanvas.ModViz3DNode mb = stacks[myInput[1]];
                        return mb.ninfoXML();
                    }
                    catch
                    {
                        return "error";
                    }

                }
                else if (myInput[0].ToLower() == "getcanvaschangedtime")
                {
                    return lastChanged.ToString();
                }
                else if (myInput[0].ToLower() == "performnodegesture")
                {

                    try
                    {
                        string nid = myInput[1];
                        double sXr = Convert.ToDouble(myInput[2]);
                        double sYr = Convert.ToDouble(myInput[3]);
                        double sZr = Convert.ToDouble(myInput[4]);
                        double eXr = Convert.ToDouble(myInput[5]);
                        double eYr = Convert.ToDouble(myInput[6]);
                        double eZr = Convert.ToDouble(myInput[7]);
                        doAGestureOnANode(nid, sXr, sYr, sZr, eXr, eYr, eZr);
                        return "sent";
                    }

                    catch
                    {
                        return "error";
                    }
                }

                else if (myInput[0].ToLower() == "performnodedoubleclick")
                {

                    try
                    {
                        string nid = myInput[1];
                        double sXr = Convert.ToDouble(myInput[2]);
                        double sYr = Convert.ToDouble(myInput[3]);
                        double sZr = Convert.ToDouble(myInput[4]);
                        doADoubleClickonANode(nid, sXr, sYr, sZr);
                        return "sent";
                    }

                    catch
                    {
                        return "error";
                    }
                }
                else if (myInput[0].ToLower() == "runcanvasprogramcommand")
                {

                    runPUPPIprogram();
                }

                //forceNodeProcess
                else if (myInput[0].ToLower() == "forcenodeprocess")
                {

                    try
                    {
                        string nid = myInput[1];
                        tellMyNodeOnCanvasToProcess(nid);
                        return "sent";
                    }

                    catch
                    {
                        return "error";
                    }
                }
                else if (myInput[0].ToLower() == "exportnoderendererimage")
                {
                    return expNCR2File(myInput[1]);
                }
                else if (myInput[0].ToLower() == "getnoderendererimagefilename")
                {
                    return getNCRFile(myInput[1]);
                }

                else if (myInput[0].ToLower() == "getnoderendererstatexml")
                {
                    if (stacks.ContainsKey(myInput[1]) == false) return "notfound";
                    try
                    {
                        PUPPICanvas.ModViz3DNode mb = stacks[myInput[1]];
                        if (mb.nodeCustomRenderer == null) return "nullRenderer";

                        return mb.nodeCustomRenderer.saveCustomRendererStateToXML();
                    }
                    catch
                    {
                        return "error";
                    }

                }
                //else if (myInput[0].ToLower() == "getnoderendererimage")
                //{
                //    if (stacks.ContainsKey(myInput[1]) == false) return "notfound";
                //    try
                //    {
                //        PUPPICanvas.ModViz3DNode mb = stacks[myInput[1]];
                //        if (mb.nodeCustomRenderer == null) return "nullRenderer";

                //        return mb.nodeCustomRenderer.saveCustomRendererStateToXML();
                //    }
                //    catch
                //    {
                //        return "error";
                //    }

                //}

                else if (myInput[0].ToLower() == "getindexedmodulenames")
                {
                    string ret = "";
                    int ii = 0;
                    foreach (string s in cvavailablePUPPIModules.Keys)
                    {

                        //ret += s;
                        ret += cvavailablePUPPIModules[s].GetType().FullName;
                        if (ii != cvavailablePUPPIModules.Keys.Count - 1)
                            ret += "_|_";
                        ii++;
                    }
                    return ret;

                }
                //getIndexedModuleNames
                // public void deleteCanvasNodeByGUID(string nodeGUID)
                else if (myInput[0].ToLower() == "deletecanvasnodebyid")
                {
                    int dguid = Convert.ToInt16(myInput[1]);
                    deleteMyNodeOnCanvasbyID(dguid);
                    return "success";
                }
                else if (myInput[0].ToLower() == "canvasreadablereport")
                {
                    return readMyCanvasStatus();
                }
                else if (myInput[0].ToLower() == "setoutputinteger")
                {
                    string nodeset = myInput[1];
                    int oset = Convert.ToInt16(myInput[2]);
                    //if (double.Parse()  )
                    //double vset = Convert.ToDouble(myInput[3]);
                    //make this reference to an arraylist storing objects

                    int numvalue = Convert.ToInt16(myInput[3]);
                    bool b = setMyNodeOnCanvasOutput(nodeset, oset, numvalue);
                    if (b)
                        return "success";
                    else
                        return "failure";
                }
                else if (myInput[0].ToLower() == "setoutputdouble")
                {
                    string nodeset = myInput[1];
                    int oset = Convert.ToInt16(myInput[2]);
                    //if (double.Parse()  )
                    //double vset = Convert.ToDouble(myInput[3]);
                    //make this reference to an arraylist storing objects

                    double numvalue = Convert.ToDouble(myInput[3]);
                    bool b = setMyNodeOnCanvasOutput(nodeset, oset, numvalue);
                    if (b)
                        return "success";
                    else
                        return "failure";
                }
                else if (myInput[0].ToLower() == "setoutputstring")
                {
                    string nodeset = myInput[1];
                    int oset = Convert.ToInt16(myInput[2]);
                    //if (double.Parse()  )
                    //double vset = Convert.ToDouble(myInput[3]);
                    //make this reference to an arraylist storing objects

                    string myvalue = myInput[3].ToString();
                    bool b = setMyNodeOnCanvasOutput(nodeset, oset, myvalue);
                    if (b)
                        return "success";
                    else
                        return "failure";
                }

                else if (myInput[0].ToLower() == "setoutputliststring")
                {
                    string nodeset = myInput[1];
                    int oset = Convert.ToInt16(myInput[2]);
                    //if (double.Parse()  )
                    //double vset = Convert.ToDouble(myInput[3]);
                    //make this reference to an arraylist storing objects

                    char[] splitters = { ',' };

                    string[] myvalue = myInput[3].ToString().Split(splitters);
                    ArrayList setit = new ArrayList();
                    foreach (string toset in myvalue)
                    {
                        setit.Add(toset);
                    }


                    bool b = setMyNodeOnCanvasOutput(nodeset, oset, setit);
                    if (b)
                        return "success";
                    else
                        return "failure";
                }
                else if (myInput[0].ToLower() == "setoutputlistdouble")
                {
                    string nodeset = myInput[1];
                    int oset = Convert.ToInt16(myInput[2]);
                    //if (double.Parse()  )
                    //double vset = Convert.ToDouble(myInput[3]);
                    //make this reference to an arraylist storing objects

                    char[] splitters = { ',' };

                    string[] myvalue = myInput[3].ToString().Split(splitters);
                    ArrayList setit = new ArrayList();
                    foreach (string toset in myvalue)
                    {
                        setit.Add(Convert.ToDouble(toset));
                    }


                    bool b = setMyNodeOnCanvasOutput(nodeset, oset, setit);
                    if (b)
                        return "success";
                    else
                        return "failure";
                }
                else if (myInput[0].ToLower() == "setoutputlistinteger")
                {
                    string nodeset = myInput[1];
                    int oset = Convert.ToInt16(myInput[2]);
                    //if (double.Parse()  )
                    //double vset = Convert.ToDouble(myInput[3]);
                    //make this reference to an arraylist storing objects

                    char[] splitters = { ',' };

                    string[] myvalue = myInput[3].ToString().Split(splitters);
                    ArrayList setit = new ArrayList();
                    foreach (string toset in myvalue)
                    {
                        setit.Add(Convert.ToInt32(toset));
                    }


                    bool b = setMyNodeOnCanvasOutput(nodeset, oset, setit);
                    if (b)
                        return "success";
                    else
                        return "failure";
                }
                //else if (myInput[0].ToLower() == "getnodeoutputvalue")
                //{



                //    bool b = setMyNodeOnCanvasOutput(nodeset, oset, setit);
                //    if (b)
                //        return "success";
                //    else
                //        return "failure";
                //}
                return "Unrecognized command";
            }
            catch (Exception exy)
            {
                return "Error";
            }
        }

        //reset camera button
        Button resetcam;
        //zoom extent button
        Button zoomextents;
        //execution mode button
        Button setliveupdate;
        //coords
        double ttop = 0;
        double tlef = 0;
        //need to know positions
        internal double twid = 0;
        internal double thei = 0;
        //undo and redo stacks
        //holds full xml definitions
        Stack<string> undostack;
        Stack<Dictionary<string, connectorpath>> undoconns;
        Stack<string> redostack;
        Stack<Dictionary<string, connectorpath>> redoconns;
        internal void renderStaticVisual()
        {
            if (hv == null) throw new Exception("Canvas not initialized!");
            foreach (ModelVisual3D g in hv.Children.ToArray())
            {

                if (g.GetName() != null && g.GetName().Contains("staticVisual")) hv.Children.Remove(g);

            }
            foreach (ModelVisual3D m in ignoreclick.ToArray())
            {
                if (m.GetName() != null && m.GetName().Contains("staticVisual"))
                {
                    ignoreclick.Remove(m);
                }
            }
            if (staticVisuals != null)
            {

                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {


                    if (staticVisuals.needsRender)
                    {
                        bool bv = staticVisuals.renderCustom();
                        if (bv == false)
                        {
                            MessageBox.Show("Failed to render static canvas visual");
                            return;
                        }
                    }
                    staticVisuals.model3D.SetName("staticVisual");
                    ignoreclick.Add(staticVisuals.model3D);
                    for (int icc = 0; icc < staticVisuals.model3D.Children.Count; icc++)
                    {
                        (staticVisuals.model3D.Children[icc] as ModelVisual3D).SetName("staticVisual_" + icc.ToString());
                        ignoreclick.Add(staticVisuals.model3D.Children[icc] as ModelVisual3D);
                    }
                    hv.Children.Insert(0, staticVisuals.model3D);
                }
                else
                {

                    if (staticVisuals.needsRender)
                    {
                        bool bv = staticVisuals.renderCustom();
                        if (bv == false)
                        {
                            MessageBox.Show("Failed to render static canvas visual");
                            return;
                        }
                    }
                    staticVisuals.model2D.SetName("staticVisual");
                    ignoreclick.Add(staticVisuals.model2D);
                    for (int icc = 0; icc < staticVisuals.model2D.Children.Count; icc++)
                    {
                        (staticVisuals.model2D.Children[icc] as ModelVisual3D).SetName("staticVisual_" + icc.ToString());
                        ignoreclick.Add(staticVisuals.model2D.Children[icc] as ModelVisual3D);
                    }
                    hv.Children.Insert(0, staticVisuals.model2D);
                }

            }


        }
        //gets the node custom renderer must be by reference
        internal PUPPINodeCustomRenderer getNodeCustomRendererByID(string myGUID)
        {
            if (stacks.ContainsKey(myGUID))
            {
                ModViz3DNode m = stacks[myGUID];
                return m.nodeCustomRenderer;
            }
            return null;

        }
        //when interacting with modules, number calls on nodes should be set to 1 lest we go in stack overflow
        internal void resetNumberCallsOnInteraction()
        {
            foreach (ModViz3DNode m in stacks.Values)
            {
                if (m != null && m.logical_representation != null) m.logical_representation.numbercalls = Math.Min(1, m.logical_representation.numbercalls);
            }
        }
        internal void camera_reset()
        {

            ProjectionCamera pro = hv.Camera;

            //only for 3d
            if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
            {
                hv.Camera = pro;
                hv.Camera.FarPlaneDistance = PUPPIGUISettings.cameraFarPlaneDistance;
            }
            else
            {
                //by default we have right click edit mode
                hv.Camera.UpDirection = new Vector3D(0, 1, 0);
                hv.Camera.Position = new Point3D(0, 0, 10);
                hv.Camera.LookDirection = new Vector3D(0, 0, -1);
                // hv.ZoomExtents();
                rightclickmode.MouseAction = MouseAction.None;
                hv.Camera.FarPlaneDistance = 1000;
            }


        }
        //sets the camera position only for 3d
        //looks at center
        internal void setcameraposition(Point3D newpos)
        {
            ProjectionCamera pro = hv.Camera;
            //only for 3d
            if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
            {
                hv.Camera = pro;
            }
            else
            {
                //by default we have right click edit mode
                hv.Camera.UpDirection = new Vector3D(0, 1, 0);
                hv.Camera.Position = new Point3D(newpos.X, newpos.Y, Math.Abs(newpos.Z));
                hv.Camera.LookDirection = new Vector3D(0, 0, -Math.Abs(newpos.Z));
                // hv.ZoomExtents();
                rightclickmode.MouseAction = MouseAction.None;

            }
        }
        internal static System.Reflection.Assembly CurrentDomain_AssemblyResolve(object sender, ResolveEventArgs args)
        {
            string dllName = args.Name.Contains(',') ? args.Name.Substring(0, args.Name.IndexOf(',')) : args.Name.Replace(".dll", "");

            dllName = dllName.Replace(".", "_");

            if (dllName.EndsWith("_resources")) return null;
            string an = Assembly.GetExecutingAssembly().GetName().Name;
            System.Resources.ResourceManager rm = new System.Resources.ResourceManager(an + ".Properties.Resources", System.Reflection.Assembly.GetExecutingAssembly());

            byte[] bytes = (byte[])rm.GetObject(dllName);

            if (bytes != null && bytes.Length > 0) return System.Reflection.Assembly.Load(bytes); else return null;
        }

        internal void resetAllCanvasNodeCaptions()
        {
            canvasabouttochange();
            if (PUPPIDebugger.debugenabled)
            {
                PUPPIDebugger.log("Started " + utils.StringConstants.rnc);
            }
            foreach (ModViz3DNode mao in stacks.Values)
            {
                mao.reset_my_node_caption();
            }
            if (PUPPIDebugger.debugenabled)
            {
                PUPPIDebugger.log("Finished " + utils.StringConstants.rnc);
            }
        }

        internal bool setANodeCaptionByGUID(string ng, string cc)
        {

            if (stacks.ContainsKey(ng) && cc != "")
            {
                ModViz3DNode ml = stacks[ng];
                canvasabouttochange();
                ml.displayname = cc;
                ml.update_caption();
                return true;
            }
            else
            {
                return false;
            }

        }

        internal Dictionary<string, ModViz3DNode> cloneMultipleStacks(bool pasteMode)
        {
            Dictionary<string, ModViz3DNode> cs = new Dictionary<string, ModViz3DNode>();
            return cs;
        }

        internal void deleteMyNodeOnCanvasbyID(int ii)
        {
            deselectallnodes();
            canvasabouttochange();
            blockconnupdates = true;
            string sss = ii.ToString();
            if (stacks.ContainsKey(sss))
            {
                ModViz3DNode zz = stacks[sss];
                zz.delete(true);
            }
            blockconnupdates = false;
            update_all_connectors();

        }


        internal void setHiddenMyNodeOnCanvasbyID(int ii, bool hime)
        {

            string sss = ii.ToString();
            if (stacks.ContainsKey(sss))
            {
                ModViz3DNode zz = stacks[sss];
                zz.setNodeHiddenLockedCanvasStatus(hime);
                //zz.hiddenOnLockedCanvas = hime;
                //List<ModViz3DNode> mc = new List<ModViz3DNode>();
                //zz.getalllevelschildren(mc);
                //foreach (ModViz3DNode kl in mc)
                //{
                //    kl.hiddenOnLockedCanvas = hime; 
                //}
            }

        }

        internal bool explodeAContainerNode(int nodeGUID, out List<ModViz3DNode> newModules)
        {
            newModules = new List<ModViz3DNode>();
            if (stacks.ContainsKey(nodeGUID.ToString()))
            {
                ModViz3DNode m = stacks[nodeGUID.ToString()];
                PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer pnc = null;
                try
                {
                    pnc = m.logical_representation as PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer;
                }
                catch
                {
                    pnc = null;
                }
                if (pnc != null)
                {
                    blockconnupdates = true;

                    if (PUPPIDebugger.debugenabled)
                    {
                        PUPPIDebugger.log(" Started exploding container" + nodeGUID.ToString());
                    }
                    string os = my_old_pc_status;
                    updatemyPCStatus("Please wait,exploding container...");
                    //these are from connected inputs and will have to reprocess
                    List<PUPPIModule> upstreamers = new List<PUPPIModule>();
                    //go through inputs of container 
                    while (pnc.PMsmInMap.Count > 0)
                    {
                        string ss = pnc.PMsmInMap[0];
                        char[] ser = { '_' };
                        string[] s = ss.Split(ser);

                        try
                        {
                            int oi = Convert.ToInt16(s[0]);
                            PUPPIModule pi = pnc.PMsubModules[Convert.ToInt16(s[1])];
                            int inputPIIndex = Convert.ToInt32(s[2]);
                            //connect input to submodule
                            PUPPIInParameter pZ = m.logical_representation.inputs[oi];
                            //clear it
                            pnc.PMsmInMap.RemoveAt(0);
                            if (pZ == null || pZ.module == null)
                            {

                            }
                            else
                            {
                                PUPPIModule pipi = pZ.module;
                                int ooi = pZ.outParIndex;
                                m.disconnectinput(oi);
                                upstreamers.Add(pipi);
                                PUPPIInParameter zI = new PUPPIInParameter();
                                zI.getinputfrom(pipi, ooi);
                                pi.connect_input(zI, inputPIIndex, false, false);

                            }


                        }
                        catch
                        {

                        }


                    }

                    //now outputs

                    while (pnc.PMsmOutMap.Count > 0)
                    {

                        string ss = pnc.PMsmOutMap[0];
                        char[] ser = { '_' };
                        string[] s = ss.Split(ser);

                        try
                        {
                            int oi = Convert.ToInt16(s[0]);
                            //see what we need to connect downstream
                            List<ModViz3DNode> la = m.getAllNodesDownstream(oi);
                            List<int> al = new List<int>();
                            List<int> laa = new List<int>();
                            PUPPIModule pi = pnc.PMsubModules[Convert.ToInt16(s[1])];
                            int poi = Convert.ToInt32(s[2]);
                            //clear it
                            pnc.PMsmOutMap.RemoveAt(0);

                            //figure out what they are connected to before we disconnect
                            int alc = 0;
                            foreach (ModViz3DNode mia in la)
                            {
                                for (int ii = 0; ii < mia.logical_representation.inputs.Count; ii++)
                                {
                                    PUPPIInParameter pia = mia.logical_representation.inputs[ii];
                                    if (pia != null && pia.module == m.logical_representation && pia.outParIndex == oi)
                                    {
                                        //add node index and input index

                                        al.Add(ii);
                                        laa.Add(alc);
                                        mia.disconnectinput(ii);
                                        //break;
                                    }
                                }
                                alc++;
                            }
                            int ai = 0;
                            for (alc = 0; alc < laa.Count; alc++)
                            {
                                // ai = laa[alc];
                                ModViz3DNode mia = la[laa[alc]];
                                int gai = al[alc];

                                PUPPIInParameter lll = new PUPPIInParameter();
                                lll.getinputfrom(pi, poi);

                                mia.logical_representation.connect_input(lll, gai, false, false);
                                //ai++;
                            }

                            //foreach (ModViz3DNode mia in la)
                            //{
                            //    int gai = al[ai];
                            //    PUPPIInParameter lll = new PUPPIInParameter();
                            //    lll.getinputfrom(pi, poi);

                            //    mia.logical_representation.connect_input(lll, gai, false);
                            //    ai++;
                            //}

                        }
                        catch
                        {

                        }

                    }
                    //reset number calls
                    //foreach (PUPPIModule pao in pnc.PMsubModules)
                    //{

                    //    pao.numbercalls = 0;
                    //}

                    //foreach (PUPPIModule pao in upstreamers)
                    //{

                    //        pao.doIprocess();
                    //}

                    //need to reprocess
                    foreach (PUPPIModule pao in pnc.PMsubModules)
                    {
                        if (pao.inputs.Count == 0)
                            pao.doIprocess();
                    }
                    Point3D cp = m.myposition;

                    ModViz3DNode mao = null;
                    //stagger nodes around
                    int rct = Convert.ToInt16(Math.Sqrt(pnc.PMsubModules.Count));
                    int iii = 0;
                    int jjj = 0;
                    foreach (PUPPIModule pao in pnc.PMsubModules)
                    {
                        Point3D lp = cp;
                        lp.Offset((iii - rct * 0.5) * PUPPIGUISettings.nodeSpacing * 2, (jjj - rct * 0.5) * PUPPIGUISettings.nodeSpacing * 2, 0);
                        Rect3D baxy = lp.makedefaultbox();
                        mao = new ModViz3DNode(baxy, pao, this);
                        stacks.Add(mao.nodeGUID.ToString(), mao);
                        newModules.Add(mao);
                        if (mao != null) mao.fitroots(stacks);
                        iii++;
                        if (iii > rct)
                        {
                            iii = 0;
                            jjj++;
                        }
                    }
                    m.delete(true);
                    blockconnupdates = false;
                    regenerate_connections(true);
                    if (PUPPIDebugger.debugenabled)
                    {
                        PUPPIDebugger.log(" Finished exploding container" + nodeGUID.ToString());
                    }
                    updatemyPCStatus(os);
                    return true;

                }

            }

            return false;
        }

        internal bool explodeContainerGetGUIDs(int nG, out List<string> ng)
        {
            deselectallnodes();
            List<ModViz3DNode> aaa = new List<ModViz3DNode>();
            bool bas = explodeAContainerNode(nG, out aaa);
            ng = new List<string>();
            foreach (ModViz3DNode aa in aaa)
            {
                ng.Add(aa.nodeGUID.ToString());
            }
            return bas;

        }

        internal string updatemyPCStatus(string s)
        {
            string ss = "";
            if (PUPPIGUISettings.displayStatusOnCanvas)
            {
                ss = pCanvasStatusUpdate.Text;
                pCanvasStatusUpdate.Text = s;
                my_old_pc_status = s;
                //Action emptyDelegate = delegate { };
                //this.canvasview.Dispatcher.Invoke(emptyDelegate, DispatcherPriority.Render);
                Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);

            }
            return ss;
        }
        //no wait
        internal string updatemyPCStatusNW(string s, Brush bruh)
        {
            string ss = "";
            if (PUPPIGUISettings.displayStatusOnCanvas)
            {
                ss = pCanvasStatusUpdate.Text;
                pCanvasStatusUpdate.Text = s;
                pCanvasStatusUpdate.Background = new SolidColorBrush(Colors.WhiteSmoke);
                pCanvasStatusUpdate.Foreground = bruh;


            }
            return ss;
        }

        internal void uHoNodeIO(string s)
        {

            if (PUPPIGUISettings.displayInfoHover)
            {
                hoverSemiTransparent.Text = s;



            }

        }
        //update with updating connectors too
        internal void forceNodeMoveUpdate(string myGUID, double xM, double yM)
        {
            if (stacks.ContainsKey(myGUID))
            {
                blockconnupdates = true;
                ModViz3DNode m = stacks[myGUID];
                Rect3D newbox = m.boundingBox;
                if (newbox.IsEmpty || Double.IsNaN(newbox.Location.X) || Double.IsNaN(newbox.Location.Y) || Double.IsNaN(newbox.Location.Z) || Double.IsNaN(newbox.SizeX) || Double.IsNaN(newbox.SizeY) || Double.IsNaN(newbox.SizeZ))
                {

                }
                else
                {


                    bool b = m.movestack(xM, yM, true);
                    //if we need to rebuild from top as size changed
                    if (newbox.SizeX != m.boundingBox.SizeX || newbox.SizeY != m.boundingBox.SizeY || newbox.SizeZ != m.boundingBox.SizeZ)
                    {
                        if (m.parent != null)
                        {
                            List<ModViz3DNode> l = m.gettopchildren();
                            if (l.Count > 0)
                            {
                                l[0].bottompyramid(l[0]);

                            }
                            else
                            {
                                m.bottompyramid(m);
                            }
                        }
                    }

                    if (b || newbox != m.boundingBox)


                    {
                        ModViz3DNode mr = m.getroot();
                        if (mr != null)
                        {

                            mr.fitroots(stacks);
                        }
                        else
                        {
                            m.fitroots(stacks);
                        }
                    }
                }
                // Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
                blockconnupdates = false;
                update_all_connectors();
            }

        }

        //light update
        internal void forceNodeCustomRendererUpdate(string myGUID)
        {
            if (stacks.ContainsKey(myGUID))
            {

                blockconnupdates = true;
                ModViz3DNode m = stacks[myGUID];
                if (m.nodeCustomRenderer == null) return;
                Rect3D newbox = m.boundingBox;
                if (newbox.IsEmpty || Double.IsNaN(newbox.Location.X) || Double.IsNaN(newbox.Location.Y) || Double.IsNaN(newbox.Location.Z) || Double.IsNaN(newbox.SizeX) || Double.IsNaN(newbox.SizeY) || Double.IsNaN(newbox.SizeZ))
                {

                }
                else
                {
                    ModelVisual3D newme = null;
                    newme = m.replacebox(newbox);


                }

                blockconnupdates = false;

            }

        }


        //file dialog, reused
        Microsoft.Win32.OpenFileDialog dlg;
        Microsoft.Win32.SaveFileDialog dlsave;
        //unique node collection so an unique node cannot be added again
        List<PUPPIModule> unique_nodes;
        //when hovering over connections, nodes are made transparent to better view the connections
        bool nodesaretransparent = false;
        //make all nodes transparent
        void makenodestransparent()
        {
            //on;y in 3d
            if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
            {
                foreach (ModViz3DNode modelnode in stacks.Values)
                {
                    //valid rep
                    if (modelnode.myself != null)
                    {
                        //valid content
                        if (modelnode.myself.Content != null)
                        {

                            GeometryModel3D cc = modelnode.myself.Content as GeometryModel3D;
                            Material mater = cc.Material;
                            cc.Material = node_tran_default_mat;
                        }
                        //try to put it at end to maintain transparency
                        hv.Children.Remove(modelnode.myself);
                        hv.Children.Add(modelnode.myself);
                    }
                }
                nodesaretransparent = true;
            }
        }
        //restore nodes to default
        void makenodesnottransparent()
        {
            foreach (ModViz3DNode modelnode in stacks.Values)
            {
                //valid rep
                if (modelnode.myself != null && modelnode.nodeCustomRenderer == null)
                {
                    //valid content
                    if (modelnode.myself.Content != null)
                    {
                        GeometryModel3D cc = modelnode.myself.Content as GeometryModel3D;
                        //Material mater = cc.Material;
                        if (selstacks.Contains(modelnode.nodeGUID.ToString()))
                        {
                            cc.Material = node_selected_default_mat;
                        }
                        else
                        {
                            if (modelnode.nodeUpdatedMaterial == null)
                            {
                                cc.Material = node_default_mat;
                            }
                            else
                            {
                                cc.Material = modelnode.nodeUpdatedMaterial;
                            }
                        }
                    }
                }
            }
            nodesaretransparent = false;
        }
        //changes the caption of a node programmatically
        internal void updateNodeCaptionProgrammatically(string captionPText, int captionPIndex, string nGUID)
        {
            if (stacks.ContainsKey(nGUID))
            {
                ModViz3DNode t = stacks[nGUID];
                if (t != null)
                {
                    canvasabouttochange();
                    t.displayname = captionPText;
                    t.update_caption(captionPIndex);
                }

            }
        }


        //adds a node at position. can be connected to other events and made public
        internal int addANodeToTheCanvas(Point3D p, PUPPIModule pm, bool attemptCleanCap = true)
        {
            try
            {
                Rect3D newbounds = new Rect3D(Math.Round(p.X) - PUPPIGUISettings.nodeSide * 0.5, Math.Round(p.Y) - PUPPIGUISettings.nodeSide * 0.5, 0, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeHeight);
                //disable updating nodes until we are done
                blockconnupdates = true;
                blockfitroots = true;
                ModViz3DNode newbox = new ModViz3DNode(newbounds, this);
                Type tm = pm.GetType();

                if (tm == null)
                {
                    blockconnupdates = false;
                    blockfitroots = false;
                    return -1;
                }

                object pm1 = System.Activator.CreateInstance(tm);
                //but we need to also keep the changed caption
                if (pm.cleancap != "")
                {
                    (pm1 as PUPPIModule).cleancap = pm.cleancap;
                    newbox.displayname = pm.cleancap;
                }
                else if (attemptCleanCap)
                {

                    try
                    {

                        string[] stringSeparators = new string[] { "__" };
                        string[] typeSeparators = new string[] { "." };
                        string[] result = pm.name.Split(stringSeparators, StringSplitOptions.None);
                        if (result[0] != null && result[0] != "")
                        {
                            string[] tS = result[0].Split(typeSeparators, StringSplitOptions.None);
                            string ltS = tS[tS.GetLength(0) - 1];
                            (pm1 as PUPPIModule).cleancap = ltS;
                            newbox.displayname = ltS;
                        }
                    }
                    catch
                    {
                        (pm1 as PUPPIModule).cleancap = "";

                    }

                }


                newbox.setlogic(pm1 as PUPPIModule);
                newbox.useRenderer();
                stacks.Add(newbox.nodeGUID.ToString(), newbox);
                //make sure we add unique nodes so they don't get added again
                if (pm.unique)
                {
                    unique_nodes.Add(pm);
                }
                blockfitroots = false;
                newbox.fitroots(stacks);
                blockconnupdates = false;
                update_all_connectors();
                try
                {
                    cm.Transform = Transform3D.Identity;
                    if (hv.Children.IndexOf(cm) >= 0)
                    {
                        cm.UnBind();
                        hv.Children.Remove(cm);
                    }
                }
                catch { }




                update_grid();
                return newbox.nodeGUID;
            }
            catch (Exception exy)
            {
                return -1;
            }
        }

        //so camera doesn't mess up while doing operations
        ProjectionCamera ccam = null;

        internal void stopMouseEv()
        {


            hv.IsHitTestVisible = false;
            frame3d.IsHitTestVisible = false;
            //  canvasview.IsHitTestVisible = false; 
            this.IsHitTestVisible = false;
            ccam = hv.Camera;

        }
        internal void resumeMouseEv()
        {



            this.IsHitTestVisible = true;
            //  canvasview.IsHitTestVisible = true;
            frame3d.IsHitTestVisible = true;
            hv.IsHitTestVisible = true;
            if (ccam != null)
                hv.Camera = ccam;

            //  canvasview.IsHitTestVisible = true;  
        }
        internal int addNodeOnTopOfNodeToTheCanvas(int ng, PUPPIModule pm, bool attemptCleanCap = true)
        {

            if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional) return -1;

            if (pm == null) return -1;
            if (stacks.ContainsKey(ng.ToString()) == false) return -1;
            ModViz3DNode on = stacks[ng.ToString()];
            if (!on.acceptschilds()) return -1;
            PUPPIModule mp = PUPPIModel.AutomaticPUPPImodulesCreator.instantiatePUPPIModule(pm.GetType());
            try
            {
                blockfitroots = true;
                ModViz3DNode newone = on.addontopof(on, null);

                (mp as PUPPIModule).cleancap = pm.cleancap;
                if (pm.cleancap != "")
                {
                    //(pm1 as PUPPIModule).cleancap = pm.cleancap;
                    newone.displayname = pm.cleancap;
                }
                else if (attemptCleanCap)
                {

                    try
                    {

                        string[] stringSeparators = new string[] { "__" };
                        string[] typeSeparators = new string[] { "." };
                        string[] result = pm.name.Split(stringSeparators, StringSplitOptions.None);
                        if (result[0] != null && result[0] != "")
                        {
                            string[] tS = result[0].Split(typeSeparators, StringSplitOptions.None);
                            string ltS = tS[tS.GetLength(0) - 1];
                            (mp as PUPPIModule).cleancap = ltS;
                            newone.displayname = ltS;
                        }
                    }
                    catch
                    {
                        (mp as PUPPIModule).cleancap = "";

                    }

                }


                //but we need to also keep the changed caption

                newone.setlogic(mp as PUPPIModule);
                on.mycanvas.stacks.Add(newone.nodeGUID.ToString(), newone);
                blockfitroots = false;
                on.getroot().fitroots(on.mycanvas.stacks);
                return newone.nodeGUID;
            }
            catch
            {
                return -1;
            }
            //ModViz3DNode no = new ModViz3DNode(new Rect3D(), mp, this);

            // try
            // {
            //     ModViz3DNode mo=on.addontopof(on, no);
            //     return mo.nodeGUID;
            // }
            // catch
            // {
            //     return -1;
            // }

        }
        internal bool addAContainerNodeToTheCanvas(Point3D p, PUPPIModule pm)
        {
            try
            {
                Rect3D newbounds = new Rect3D(Math.Round(p.X) - PUPPIGUISettings.nodeSide * 0.5, Math.Round(p.Y) - PUPPIGUISettings.nodeSide * 0.5, 0, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeHeight);
                //disable updating nodes until we are done
                blockconnupdates = true;
                blockfitroots = true;
                ModViz3DNode newbox = new ModViz3DNode(newbounds, this);
                //but we need to also keep the changed caption
                if (pm.cleancap != "")
                {
                    newbox.displayname = pm.cleancap;
                }
                newbox.setlogic(pm as PUPPIModule);
                newbox.useRenderer();
                stacks.Add(newbox.myself.GetName(), newbox);
                blockfitroots = false;
                newbox.fitroots(stacks);
                blockconnupdates = false;
                update_all_connectors();
                try
                {
                    cm.Transform = Transform3D.Identity;
                    if (hv.Children.IndexOf(cm) >= 0)
                    {
                        cm.UnBind();
                        hv.Children.Remove(cm);
                    }
                }
                catch { }




                update_grid();
                return true;
            }
            catch
            {
                return false;
            }
        }


        //checks if an unique node is already on the canvas
        internal bool contains_unique_node(PUPPIModule pm)
        {
            for (int i = 0; i < unique_nodes.Count; i++)
            {
                if (unique_nodes[i].name == pm.name)
                {
                    return true;
                }
            }
            return false;
        }
        //removes unique node
        internal void remove_unique_node(PUPPIModule pm)
        {
            for (int i = 0; i < unique_nodes.Count; i++)
            {
                if (unique_nodes[i].name == pm.name)
                {
                    unique_nodes.Remove(unique_nodes[i]);
                    return;
                }
            }
        }
        internal EventHandler lockCanvasEvent;
        internal EventHandler unlockCanvasEvent;
        internal void setthiscanvaslockstatus(bool locked)
        {
            thiscanvasdefinitelylocked = locked;
            if (locked == true)
            {
                if (lockCanvasEvent != null) lockCanvasEvent(this, EventArgs.Empty);
            }
            else
            {
                if (unlockCanvasEvent != null) unlockCanvasEvent(this, EventArgs.Empty);
            }
            string myf = "";
            myf = fileCurLdd;
            if (myf == "")
                clearobjects(true);
            else openfile(myf);
        }

        //BackgroundWorker canvasProcessingMonitor;
        //nternal EventHandler somewhereProcessingStarted;
        internal EventHandler somewhereProcessingStopped;

        //constructor
        internal PUPPICanvas(double left = 0, double top = 0, double width = 1000, double height = 800, bool cisl = false)
        {


            //make sure settings initialized
            if (settingsInitialized == false) throw new Exception("Settings not initialized, you need to run PUPPIGuiSettings.initializeSettings() first!");

            thiscanvasdefinitelylocked = cisl;
            customRenderers = new Dictionary<string, PUPPINodeCustomRenderer>();
            moduleRenderers = new Dictionary<Type, string>();




            cvavailablePUPPIModules = new Dictionary<string, PUPPIModule>();
            initme(left, top, width, height, true);

            //canvasProcessingMonitor = new BackgroundWorker
            //{
            //    WorkerReportsProgress = true,
            //    WorkerSupportsCancellation = true
            //};
            //canvasProcessingMonitor.DoWork += canvasProcessingMonitor_DoWork;
            //canvasProcessingMonitor.ProgressChanged += canvasProcessingMonitor_ProgressChanged;
            //monitor processing of nodes
            commandQueue = new SynchronizedCollection<string>();
            commandQueueResults = new List<string>();
            somewhereProcessingStopped += (sender, args) => { runStringCanvasCommands(); };

            //canvasProcessingMonitor.RunWorkerAsync();



            //  runStringCanvasCommands(); 
            Thread backgroundExeMonitor = new Thread(new ThreadStart(this.backgroundMonitorCommands));
            backgroundExeMonitor.IsBackground = true;
            backgroundExeMonitor.Name = "MSCO";
            backgroundExeMonitor.Start();


            //server stuyff

            currentXMLRepServer = "";
            currentCanvasStatusServer = "";
            nodeRendererImageFilesServer = new ConcurrentDictionary<string, string>();
            nodeRendererModel3DServer = new ConcurrentDictionary<string, List<Model3D>>();
            nodeRendererOBJFolderServer = new ConcurrentDictionary<string, string>();
            nodeRendererSTLServer = new ConcurrentDictionary<string, string>();
            nodeInfoXMLServer = new ConcurrentDictionary<string, string>();

            //initialize file dialgos

            dlg = new Microsoft.Win32.OpenFileDialog();
            //if we have a saved load folder
            try
            {
                if (PUPPI.Properties.Settings.Default.savedfolder != "" && PUPPI.Properties.Settings.Default.savedfolder != "initial")
                {
                    dlg.InitialDirectory = PUPPI.Properties.Settings.Default.savedfolder;

                }
                else
                {
                    dlg.InitialDirectory = System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().CodeBase);
                }
            }
            catch
            {
                dlg.InitialDirectory = System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().CodeBase);
            }
            dlg.FileName = ""; // Default file name
            dlg.DefaultExt = PUPPIGUISettings.saveFileExtension; // Default file extension
            dlg.Filter = PUPPIGUISettings.saveFileExtension.Replace(".", "") + " documents (" + PUPPIGUISettings.saveFileExtension + ")|*" + PUPPIGUISettings.saveFileExtension; // Filter files by extension 

            // Configure save file dialog box
            dlsave = new Microsoft.Win32.SaveFileDialog();
            dlsave.FileName = "PUPPIProgram"; // Default file name
            dlsave.DefaultExt = PUPPIGUISettings.saveFileExtension; // Default file extension
            dlsave.Filter = PUPPIGUISettings.saveFileExtension.Replace(".", "") + " documents (" + PUPPIGUISettings.saveFileExtension + ")|*" + PUPPIGUISettings.saveFileExtension; // Filter files by extension 
            dlsave.InitialDirectory = dlg.InitialDirectory; //System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().CodeBase);
            if (PUPPIGUISettings.addNodeOnModuleDoubleClick)
                PUPPIruntimesettings.moduleButtonWasDoubleClicked += yes_moduleButtonWasDoubleClicked;
            fileCurLdd = "";
            //make sure temporary lines get removed from canvas as we exit

            //  this.frame3d.MouseLeave += hv_MouseLeave;
            //    hv.DragLeave += frame3d_DragLeave;
            hv.MouseEnter += hv_MouseEnter;
        }

        void hv_MouseEnter(object sender, MouseEventArgs e)
        {
            if (e.LeftButton == MouseButtonState.Pressed || e.RightButton == MouseButtonState.Pressed || e.MiddleButton == MouseButtonState.Pressed)
            {
                mouseisdown = true;
            }
            else
            {
                mouseisdown = false;
            }
            removeAllTracesDCLS();
            removeAllTracesDMR();
            removeAllTracesGLS();
            removeAllTracesNMAS();
            removeDragSelector();
        }

        void frame3d_DragLeave(object sender, DragEventArgs e)
        {
            //Point p = e.GetPosition(this.frame3d);
            ////string pp = p.X.ToString() + "_" + p.Y.ToString();
            ////updatemyPCStatusNW(pp, Brushes.Red);
            //if (p.X <= 0 || p.X >= this.frame3d.ActualWidth || p.Y <= 0 || p.Y >= this.frame3d.ActualHeight)
            //{
            //  removeAllTracesDCLS();
            //    removeAllTracesDMR();

            ////    removeAllTracesGLS();
            //    removeAllTracesNMAS();
            //}
        }

        //void hv_MouseLeave(object sender, MouseEventArgs e)
        //{

        //    Point p = e.GetPosition(this.frame3d);
        //    string pp = p.X.ToString() + "_" + p.Y.ToString();
        //    updatemyPCStatusNW(pp, Brushes.Red);
        //    if (p.X <= 0 || p.X >= this.frame3d.ActualWidth || p.Y <= 0 || p.Y >= this.frame3d.ActualHeight)
        //    {
        //        removeAllTracesDCLS();
        //        removeAllTracesDMR();
        //        removeAllTracesGLS();
        //        removeAllTracesNMAS();
        //    }

        //}

        //void canvasProcessingMonitor_ProgressChanged(object sender, ProgressChangedEventArgs e)
        //{
        //    int statec = e.ProgressPercentage;
        //    if (statec == 0)
        //    {
        //        if (somewhereProcessingStopped != null) somewhereProcessingStopped(this, EventArgs.Empty);
        //    }
        //    else
        //    {
        //        if (somewhereProcessingStarted != null) somewhereProcessingStarted(this, EventArgs.Empty);
        //    }

        //}


        void backgroundMonitorCommands()
        {
            int pstatus = 0;
            if (PUPPIModel.PUPPIModule.concurrentProcesses + PUPPIServer.PUPPICanvasTCPServer.NumberClientThreads + PUPPIServer.PUPPICanvasHTTPServer.NumberClientThreads > 0)
                pstatus = 1;

            while (true)
            {
                long curstatus = PUPPIModel.PUPPIModule.concurrentProcesses + PUPPIServer.PUPPICanvasTCPServer.NumberClientThreads + PUPPIServer.PUPPICanvasHTTPServer.NumberClientThreads;
                if (curstatus > 0)
                {
                    curstatus = 1;
                }
                else
                {
                    curstatus = 0;
                }


                if (pstatus == 1 && curstatus == 0)
                {
                    if (somewhereProcessingStopped != null)
                    {

                        Dispatcher.BeginInvoke(new EventHandler(somewhereProcessingStopped), this, null);
                        //  somewhereProcessingStopped(this, null);
                        //});
                    }

                }
                pstatus = (int)curstatus;
            }
        }

        //void canvasProcessingMonitor_DoWork(object sender, DoWorkEventArgs e)
        //{
        //    int pstatus = 0;
        //    if (PUPPIModel.PUPPIModule.concurrentProcesses +PUPPIServer.PUPPICanvasServer.NumberClientThreads>0)
        //        pstatus = 1;
        //    BackgroundWorker worker = (BackgroundWorker)sender;
        //    while (!worker.CancellationPending)
        //    {
        //        long curstatus = PUPPIModel.PUPPIModule.concurrentProcesses + PUPPIServer.PUPPICanvasServer.NumberClientThreads;
        //        if (curstatus > 0)
        //        {
        //            curstatus = 1;
        //        }
        //        else
        //        {
        //            curstatus = 0;
        //        }


        //        if (pstatus != curstatus)
        //        {
        //            //1 means it started processing, 0 means it stopped processing
        //            worker.ReportProgress((int)curstatus, "Processing status changed");
        //        }
        //        pstatus = (int)curstatus;
        //    }
        //}

        void yes_moduleButtonWasDoubleClicked(object sender, EventArgs e)
        {
            if (PUPPIruntimesettings.savedAddNodeModule != null)
                addANodeToTheCanvas(new Point3D(0, 0, 0), PUPPIruntimesettings.savedAddNodeModule);
        }
        //initialize and reset
        //it can be a full reset or just clearing items
        internal void initme(double left = 0, double top = 0, double width = 1000, double height = 800, bool fullreset = false)
        {

            if (PUPPIDebugger.debugenabled)
            {
                PUPPIDebugger.log("Initializing canvas...");
                PUPPIDebugger.log("Culture: " + Thread.CurrentThread.CurrentCulture.ToString());
                PUPPIDebugger.log("UI Culture: " + Thread.CurrentThread.CurrentUICulture.ToString());

            }

            usingmanip = false;
            if (fullreset)
            {
                undostack = new Stack<string>();
                undoconns = new Stack<Dictionary<string, connectorpath>>();
                redostack = new Stack<string>();
                redoconns = new Stack<Dictionary<string, connectorpath>>();
                nodestoupdate = new List<ModViz3DNode>();


            }
            //for storing objects when calling commands by string
            PUPPIModel.Utilities.commandObjs = new ArrayList();
            ignoreclick = new ArrayList();
            ttop = top;
            tlef = left;
            twid = width;
            thei = height;
            doubleClickedOutput = "";
            //initailie defualt material
            SolidColorBrush sobro = new SolidColorBrush();

            sobro.Color = Color.FromArgb(Convert.ToByte(255 * PUPPIGUISettings.node_Alpha), Convert.ToByte(255 * PUPPIGUISettings.node_Red), Convert.ToByte(255 * PUPPIGUISettings.node_Green), Convert.ToByte(255 * PUPPIGUISettings.node_Blue));
            node_default_mat = new DiffuseMaterial(sobro);
            //transparent for when we hover over connections
            SolidColorBrush sotrabro = new SolidColorBrush();
            sotrabro.Color = Color.FromArgb(Convert.ToByte(255 * PUPPIGUISettings.node_Alpha * PUPPIGUISettings.hover_Alpha_Reduction_Factor), Convert.ToByte(255 * PUPPIGUISettings.node_Red), Convert.ToByte(255 * PUPPIGUISettings.node_Green), Convert.ToByte(255 * PUPPIGUISettings.node_Blue));
            node_tran_default_mat = new DiffuseMaterial(sotrabro);
            sotrabro.Freeze();
            node_tran_default_mat.Freeze();

            //transparent for when we hover over connections
            SolidColorBrush selrebro = new SolidColorBrush();
            selrebro.Color = Color.FromArgb(Convert.ToByte(255 * PUPPIGUISettings.selectRectangle_Alpha), Convert.ToByte(255 * PUPPIGUISettings.selectRectangle_Red), Convert.ToByte(255 * PUPPIGUISettings.selectRectangle_Green), Convert.ToByte(255 * PUPPIGUISettings.selectRectangle_Blue));
            drag_rect_default_mat = new DiffuseMaterial(selrebro);
            selrebro.Freeze();
            drag_rect_default_mat.Freeze();



            SolidColorBrush iobro = new SolidColorBrush();
            iobro.Color = Color.FromArgb(Convert.ToByte(255 * PUPPIGUISettings.input_Alpha), Convert.ToByte(255 * PUPPIGUISettings.input_Red), Convert.ToByte(255 * PUPPIGUISettings.input_Green), Convert.ToByte(255 * PUPPIGUISettings.input_Blue));
            input_default_mat = new DiffuseMaterial(iobro);
            iobro.Freeze();
            input_default_mat.Freeze();

            //and empty
            SolidColorBrush eiobro = new SolidColorBrush();
            eiobro.Color = Color.FromArgb(Convert.ToByte(255 * PUPPIGUISettings.emptyInput_Alpha), Convert.ToByte(255 * PUPPIGUISettings.emptyInput_Red), Convert.ToByte(255 * PUPPIGUISettings.emptyInput_Green), Convert.ToByte(255 * PUPPIGUISettings.emptyInput_Blue));
            emptyInput_default_mat = new DiffuseMaterial(eiobro);
            eiobro.Freeze();
            emptyInput_default_mat.Freeze();

            //and empty optional
            SolidColorBrush eoptiobro = new SolidColorBrush();
            eoptiobro.Color = Color.FromArgb(Convert.ToByte(255 * PUPPIGUISettings.emptyOptInput_Alpha), Convert.ToByte(255 * PUPPIGUISettings.emptyOptInput_Red), Convert.ToByte(255 * PUPPIGUISettings.emptyOptInput_Green), Convert.ToByte(255 * PUPPIGUISettings.emptyOptInput_Blue));
            emptyoptionalinput_default_mat = new DiffuseMaterial(eoptiobro);
            eoptiobro.Freeze();
            emptyInput_default_mat.Freeze();

            SolidColorBrush oobro = new SolidColorBrush();
            oobro.Color = Color.FromArgb(Convert.ToByte(255 * PUPPIGUISettings.output_Alpha), Convert.ToByte(255 * PUPPIGUISettings.output_Red), Convert.ToByte(255 * PUPPIGUISettings.output_Green), Convert.ToByte(255 * PUPPIGUISettings.output_Blue));
            output_default_mat = new DiffuseMaterial(oobro);
            oobro.Freeze();
            output_default_mat.Freeze();

            SolidColorBrush mybro = new SolidColorBrush();
            mybro.Color = Color.FromArgb(Convert.ToByte(255 * PUPPIGUISettings.marker_Alpha), Convert.ToByte(255 * PUPPIGUISettings.marker_Red), Convert.ToByte(255 * PUPPIGUISettings.marker_Green), Convert.ToByte(255 * PUPPIGUISettings.marker_Blue));
            marker_default_mat = new DiffuseMaterial(mybro);
            mybro.Freeze();
            marker_default_mat.Freeze();


            SolidColorBrush clickedbro = new SolidColorBrush();
            clickedbro.Color = Color.FromArgb(Convert.ToByte(255 * PUPPIGUISettings.nodeClicked_Alpha), Convert.ToByte(255 * PUPPIGUISettings.nodeClicked_Red), Convert.ToByte(255 * PUPPIGUISettings.nodeClicked_Green), Convert.ToByte(255 * PUPPIGUISettings.nodeClicked_Blue));
            node_clicked_default_mat = new DiffuseMaterial(clickedbro);
            clickedbro.Freeze();
            node_clicked_default_mat.Freeze();

            SolidColorBrush selectedbro = new SolidColorBrush();
            selectedbro.Color = Color.FromArgb(Convert.ToByte(255 * PUPPIGUISettings.nodeSelected_Alpha), Convert.ToByte(255 * PUPPIGUISettings.nodeSelected_Red), Convert.ToByte(255 * PUPPIGUISettings.nodeSelected_Green), Convert.ToByte(255 * PUPPIGUISettings.nodeSelected_Blue));
            node_selected_default_mat = new DiffuseMaterial(selectedbro);
            selectedbro.Freeze();
            node_selected_default_mat.Freeze();


            //node_selected_default_mat

            SolidColorBrush connclickedbro = new SolidColorBrush();
            connclickedbro.Color = Color.FromArgb(Convert.ToByte(255 * PUPPIGUISettings.selconn_Alpha), Convert.ToByte(255 * PUPPIGUISettings.selconn_Red), Convert.ToByte(255 * PUPPIGUISettings.selconn_Green), Convert.ToByte(255 * PUPPIGUISettings.selconn_Blue));
            connsel_default_matg = new MaterialGroup();
            connsel_default_mat = new DiffuseMaterial(connclickedbro);
            connclickedbro.Freeze();
            connsel_default_mat.Freeze();

            EmissiveMaterial ae = new EmissiveMaterial(Brushes.Black);
            connsel_default_matg.Children.Add(connsel_default_mat);
            connsel_default_matg.Children.Add(ae);
            connsel_default_matg.Freeze();



            SolidColorBrush transbro = new SolidColorBrush();
            transbro.Color = Color.FromArgb(0, 255, 255, 255);
            customRenderBox_default_mat = new DiffuseMaterial(transbro);
            transbro.Freeze();
            customRenderBox_default_mat.Freeze();

            SolidColorBrush backbro = new SolidColorBrush();
            backbro.Color = Color.FromArgb(Convert.ToByte(255 * PUPPIGUISettings.background_Alpha), Convert.ToByte(255 * PUPPIGUISettings.background_Red), Convert.ToByte(255 * PUPPIGUISettings.background_Green), Convert.ToByte(255 * PUPPIGUISettings.background_Blue));

            //initialize default selection box
            dragSelectAreaRectangle = Visual3DExtensions.makeMeaVizBoxFromRectangle(new Rect3D(0, 0, 0, 0.1, 0.1, 0.1), node_tran_default_mat);
            //line between output and input when connecting
            dragConnectLineShow = new LinesVisual3D();
            gestureLineShow = new LinesVisual3D();
            moduleDragMarker = new BillboardTextVisual3D();
            mDMtext = "";
            dclsStart = new Point3D(-99999, -99999, -99999);
            glsStart = new Point3D(-99999, -99999, -99999);
            dragonMystart = new Point3D(-99999, -99999, -99999);
            dragonMyRe = "";
            dragonMyNode = null;
            issaved = true;

            //initialize context menu but keep hidden
            noderightclickmenu = new PUPPINodeContextMenu();
            noderightclickmenu.IsOpen = false;

            inputrightclickmenu = new PUPPIInputConnectorContextMenu();
            inputrightclickmenu.IsOpen = false;


            outputrightclickmenu = new PUPPIOutputConnectorContextMenu();
            outputrightclickmenu.IsOpen = false;

            canvasrightclickmenu = new PUPPICanvasContextMenu();
            canvasrightclickmenu.IsOpen = false;



            //initialize the grid

            canvasview = new Grid();
            // canvasview.ClipToBounds = true;  
            //   canvasview.Margin = new Thickness(tlef, ttop, 0, 0);
            //
            //   canvasview.Height = thei;
            //  canvasview.Width = twid;

            canvasview.Background = sobro;

            sobro.Freeze();
            canvasview.HorizontalAlignment = HorizontalAlignment.Stretch;
            canvasview.VerticalAlignment = VerticalAlignment.Stretch;


            //canvasview.MinHeight = 10;
            //canvasview.MinWidth = 10;
            //canvasview.MinHeight = 10000;
            //canvasview.MinWidth = 10000;  


            stacks = new Dictionary<string, ModViz3DNode>();
            connpaths = new Dictionary<string, ModViz3DConn>();
            unique_nodes = new List<PUPPIModule>();
            clipstacks = new Dictionary<string, ModViz3DNode>();
            selstacks = new List<string>();

            //initialize the single manipulator used (appears when left clicking) 
            //cm = new CombinedManipulator();


            //cm.SetName("manipulator");
            //cm.CanRotateX = false;
            //cm.CanRotateY = false;
            //cm.CanRotateZ = false;
            //cm.CanTranslateZ = false;

            cm = new MATraMu();


            cm.SetName("manipulator");

            cm.CanTranslateZ = false;

            usingmanip = false;
            dragip = false;


            //Camera
            //mycamera = new PerspectiveCamera();
            //mycamera.LookDirection = new Vector3D(0, -1, 0);
            //mycamera.Position = new Point3D(2, 10, 0);
            //mycamera.UpDirection = new Vector3D(1, 0, 0);
            //mycamera.NearPlaneDistance = 0;
            //mycamera.FarPlaneDistance = 20;


            //3d view
            //check if hv exists and if not make new
            if (hv != null)
            {
                hv.Children.Clear();


            }
            else
            {
                DockPanel cbutt = new DockPanel();

                hv = new HelixViewport3D();
                hv.ClipToBounds = false;

                if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {

                    hv.ShowViewCube = false;
                }
                hv.Background = backbro;
                //canvasview.Background = backbro;
                //   frame3d.Background = backbro;  
                //change rotate so we can use right click for something else
                rightclickmode = new System.Windows.Input.MouseGesture(MouseAction.RightClick);

                hv.RotateGesture = rightclickmode;

                //menu buttons displacement
                int mD = 0;

                //generate view specific menu
                rotationmode = new Button();

                rotationmode.Margin = new Thickness(0);
                //rotationmode.
                rotationmode.FontSize = Math.Max(PUPPIGUISettings.windowButtonHeight - 4, 1);
                rotationmode.Height = PUPPIGUISettings.windowButtonHeight;
                rotationmode.Content = "Rght Clck Rot. Mode";
                rotationmode.Width = 140;
                rotationmode.HorizontalAlignment = HorizontalAlignment.Left;
                rotationmode.VerticalAlignment = VerticalAlignment.Top;

                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    mD += 142;
                }
                rotationmode.Background = Brushes.LightBlue;
                rotationmode.Click += rotationmode_Click;

                leftClickMode = new Button();
                //leftClickMode.Margin = new Thickness(0);
                //leftClickMode.BorderThickness = new Thickness(0);
                // leftClickMode
                leftClickMode.FontSize = Math.Max(PUPPIGUISettings.windowButtonHeight - 4, 1);
                leftClickMode.Height = PUPPIGUISettings.windowButtonHeight;
                leftClickMode.Content = "Left Clck Move Node";
                leftClickMode.Width = 140;
                //leftClickMode.FontSize = 10;  
                //leftClickMode.Margin = new Thickness(mD, 0, 0, 0);
                //leftClickMode.Padding = new Thickness(0);
                leftClickMode.Background = Brushes.LightBlue;
                leftClickMode.Click += leftClickMode_Click;
                leftClickModeMove = true;
                leftClickMode.HorizontalAlignment = HorizontalAlignment.Left;
                leftClickMode.VerticalAlignment = VerticalAlignment.Top;



                //menu for camera reset
                resetcam = new Button();
                resetcam.FontSize = Math.Max(PUPPIGUISettings.windowButtonHeight - 4, 1);
                resetcam.Background = Brushes.LightBlue;
                resetcam.Height = PUPPIGUISettings.windowButtonHeight;
                resetcam.Click += resetcam_Click;
                //resetcam.Margin = new Thickness(142 + mD, 0, 0, 0);
                resetcam.Width = 140;
                resetcam.Content = "Reset Cam.";
                resetcam.HorizontalAlignment = HorizontalAlignment.Left;
                resetcam.VerticalAlignment = VerticalAlignment.Top;



                zoomextents = new Button();
                zoomextents.FontSize = Math.Max(PUPPIGUISettings.windowButtonHeight - 4, 1);
                //zoomextents.BorderThickness = new Thickness(0);
                zoomextents.Content = "Zoom Ext.";
                zoomextents.Background = Brushes.LightBlue;
                zoomextents.Height = PUPPIGUISettings.windowButtonHeight;
                zoomextents.Click += zoomextents_Click;
                //zoomextents.Margin = new Thickness(284 + mD, 0, 0, 0);
                zoomextents.Width = 140;
                zoomextents.HorizontalAlignment = HorizontalAlignment.Left;
                zoomextents.VerticalAlignment = VerticalAlignment.Top;



                setliveupdate = new Button();
                setliveupdate.FontSize = Math.Max(PUPPIGUISettings.windowButtonHeight - 4, 1);
                setliveupdate.Content = "Run Live";
                setliveupdate.Width = 140;
                setliveupdate.Background = Brushes.LightGreen;
                setliveupdate.Height = PUPPIGUISettings.windowButtonHeight;
                setliveupdate.Click += setliveupdate_Click;
                setliveupdate.HorizontalAlignment = HorizontalAlignment.Left;
                setliveupdate.VerticalAlignment = VerticalAlignment.Top;


                //setliveupdate.Margin = new Thickness(426 + mD, 0, 0, 0);

                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                    hv.Camera.FarPlaneDistance = PUPPIGUISettings.cameraFarPlaneDistance;
                else
                    hv.Camera.FarPlaneDistance = 1000;

                //store tablet buttons in dock panel
                //DockPanel tbu = new DockPanel();
                //tbu.MaxHeight = 100;
                //tbu.MaxWidth = 100;
                //tbu.MinHeight = 100;
                //tbu.MinWidth = 100;

                //tbu.HorizontalAlignment = HorizontalAlignment.Left;
                //tbu.VerticalAlignment = VerticalAlignment.Top;
                Grid ga = new Grid();
                ga.MaxHeight = 100;
                ga.MaxWidth = 150;
                ga.HorizontalAlignment = HorizontalAlignment.Left;
                ga.VerticalAlignment = VerticalAlignment.Top;
                if (PUPPIGUISettings.tabletMode || PUPPIGUISettings.displayCameraControlButtons)
                {

                    tapMode = new Button();
                    tapMode.Content = "Tap Mode Lft Clck";
                    tapMode.Width = 140;
                    tapMode.FontSize = Math.Max(PUPPIGUISettings.windowButtonHeight - 4, 1);
                    tapMode.Background = Brushes.LightBlue;
                    tapMode.Height = PUPPIGUISettings.windowButtonHeight;
                    tapMode.HorizontalAlignment = HorizontalAlignment.Left;
                    tapMode.VerticalAlignment = VerticalAlignment.Top;
                    tapMode.Click += tapMode_Click;
                    //tapMode.Margin = new Thickness(568 + mD, 0, 0, 0);


                    //put them in grid

                    RowDefinition ra = new RowDefinition();

                    ga.RowDefinitions.Add(new RowDefinition());
                    ga.RowDefinitions.Add(new RowDefinition());
                    ga.RowDefinitions.Add(new RowDefinition());

                    ColumnDefinition ca = new ColumnDefinition();
                    ga.ColumnDefinitions.Add(new ColumnDefinition());
                    ga.ColumnDefinitions.Add(new ColumnDefinition());
                    ga.ColumnDefinitions.Add(new ColumnDefinition());


                    tabCameraPanUp = new Button();

                    tabCameraPanUp.Width = 40;
                    tabCameraPanUp.FontSize = Math.Max(PUPPIGUISettings.windowButtonHeight - 4, 1);
                    tabCameraPanUp.Content = " ";
                    tabCameraPanUp.Background = Brushes.LightCyan;
                    tabCameraPanUp.Height = PUPPIGUISettings.windowButtonHeight;
                    tabCameraPanUp.Click += tabCameraPanUp_Click;
                    Grid.SetRow(tabCameraPanUp, 0);
                    Grid.SetColumn(tabCameraPanUp, 1);
                    // tabCameraPanUp.HorizontalAlignment = HorizontalAlignment.Center;
                    // tabCameraPanUp.VerticalAlignment = VerticalAlignment.Top;
                    // tbu.Children.Add(tabCameraPanUp);  
                    //tabCameraPanUp.Margin = new Thickness(568 + mD + 40 + 142, 0, 0, 0);

                    tabCameraPanDown = new Button();

                    tabCameraPanDown.Width = 40;
                    tabCameraPanDown.FontSize = Math.Max(PUPPIGUISettings.windowButtonHeight - 4, 1);
                    tabCameraPanDown.Content = " ";
                    tabCameraPanDown.Background = Brushes.LightCyan;
                    tabCameraPanDown.Height = PUPPIGUISettings.windowButtonHeight;
                    tabCameraPanDown.Click += tabCameraPanDown_Click;
                    Grid.SetRow(tabCameraPanDown, 2);
                    Grid.SetColumn(tabCameraPanDown, 1);
                    // tabCameraPanDown.Margin = new Thickness(568 + mD + 40 + 142, PUPPIGUISettings.windowButtonHeight * 2, 0, 0);
                    //   tabCameraPanDown.HorizontalAlignment = HorizontalAlignment.Center;
                    //   tabCameraPanDown.VerticalAlignment = VerticalAlignment.Bottom; 
                    //  tbu.Children.Add(tabCameraPanDown); 


                    tabCameraPanLeft = new Button();
                    tabCameraPanLeft.Width = 40;
                    tabCameraPanLeft.FontSize = Math.Max(PUPPIGUISettings.windowButtonHeight - 4, 1);
                    tabCameraPanLeft.Content = " ";
                    tabCameraPanLeft.Background = Brushes.LightCyan;
                    tabCameraPanLeft.Height = PUPPIGUISettings.windowButtonHeight;
                    tabCameraPanLeft.Click += tabCameraPanLeft_Click;
                    Grid.SetRow(tabCameraPanLeft, 1);
                    Grid.SetColumn(tabCameraPanLeft, 0);
                    //tabCameraPanLeft.Margin = new Thickness(568 + mD + 142, PUPPIGUISettings.windowButtonHeight, 0, 0);
                    //   tabCameraPanLeft.HorizontalAlignment = HorizontalAlignment.Left;
                    //   tabCameraPanLeft.VerticalAlignment = VerticalAlignment.Center;
                    //   tbu.Children.Add(tabCameraPanLeft); 


                    tabCameraPanRight = new Button();
                    tabCameraPanRight.Width = 40;
                    tabCameraPanRight.FontSize = Math.Max(PUPPIGUISettings.windowButtonHeight - 4, 1);
                    tabCameraPanRight.Content = " ";
                    tabCameraPanRight.Background = Brushes.LightCyan;
                    tabCameraPanRight.Height = PUPPIGUISettings.windowButtonHeight;
                    tabCameraPanRight.Click += tabCameraPanRight_Click;
                    Grid.SetRow(tabCameraPanRight, 1);
                    Grid.SetColumn(tabCameraPanRight, 2);
                    //tabCameraPanRight.Margin = new Thickness(568 + mD + 80 + 142, PUPPIGUISettings.windowButtonHeight, 0, 0);
                    //  tabCameraPanRight.HorizontalAlignment = HorizontalAlignment.Right;
                    //  tabCameraPanRight.VerticalAlignment = VerticalAlignment.Center;
                    //    tbu.Children.Add(tabCameraPanRight);

                    if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                    {
                        tabCameraPanMode = new Button();
                        tabCameraPanMode.Width = 38;
                        tabCameraPanMode.FontSize = Math.Max(PUPPIGUISettings.windowButtonHeight - 4, 1);
                        tabCameraPanMode.Content = "Pan";
                        tabCameraPanMode.Background = Brushes.LightCyan;
                        tabCameraPanMode.Height = PUPPIGUISettings.windowButtonHeight;
                        tabCameraPanMode.Click += tabCameraPanMode_Click;
                        Grid.SetRow(tabCameraPanMode, 1);
                        Grid.SetColumn(tabCameraPanMode, 1);


                        ga.Children.Add(tabCameraPanMode);
                        // tabCameraPanMode.Margin = new Thickness(568 + mD + 41 + 142, PUPPIGUISettings.windowButtonHeight, 0, 0);
                        //  tabCameraPanMode.HorizontalAlignment = HorizontalAlignment.Center;
                        //  tabCameraPanMode.VerticalAlignment = VerticalAlignment.Center;
                        // tbu.Children.Add(tabCameraPanMode); 
                    }
                    ga.Children.Add(tabCameraPanLeft);
                    ga.Children.Add(tabCameraPanRight);
                    ga.Children.Add(tabCameraPanUp);
                    ga.Children.Add(tabCameraPanDown);

                }

                pCanvasStatusUpdate = new TextBlock();

                pCanvasStatusUpdate.Text = "New Canvas";
                pCanvasStatusUpdate.FontSize = Math.Max(PUPPIGUISettings.windowButtonHeight - 4, 1);
                //pCanvasStatusUpdate.Margin = new Thickness(1, this.canvasview.ActualHeight - PUPPIGUISettings.windowButtonHeight, 0, 0);
                pCanvasStatusUpdate.HorizontalAlignment = HorizontalAlignment.Left;
                pCanvasStatusUpdate.VerticalAlignment = VerticalAlignment.Bottom;

                //to show transparent node info overlay
                SolidColorBrush hoverInfo_bro = new SolidColorBrush();
                hoverInfo_bro.Color = Color.FromArgb(Convert.ToByte(255 * PUPPIGUISettings.hoverInfo_Alpha), Convert.ToByte(255 * PUPPIGUISettings.hoverInfo_Red), Convert.ToByte(255 * PUPPIGUISettings.hoverInfo_Green), Convert.ToByte(255 * PUPPIGUISettings.hoverInfo_Blue));


                hoverSemiTransparent = new TextBlock();
                hoverSemiTransparent.FontSize = PUPPIGUISettings.hoverInfo_Size;
                hoverSemiTransparent.Text = "";
                hoverSemiTransparent.Foreground = hoverInfo_bro;
                hoverInfo_bro.Freeze();


                // hoverSemiTransparent.FontSize =PUPPIGUISettings.windowButtonHeight *2;
                hoverSemiTransparent.HorizontalAlignment = HorizontalAlignment.Center;
                hoverSemiTransparent.VerticalAlignment = VerticalAlignment.Center;

                hoverSemiTransparent.IsHitTestVisible = false;


                // pCanvasStatusUpdate.Margin = new Thickness(100, 100, 101, 101);
                //Show it all
                frame3d = new Frame();
                frame3d.AllowDrop = true;
                frame3d.Drop += PUPPICanvas_dropon3d;
                frame3d.KeyDown += frame3d_KeyDown;

                frame3d.KeyUp += frame3d_KeyUp;
                frame3d.Background = backbro;
                backbro.Freeze();

                frame3d.Content = hv;

                frame3d.HorizontalAlignment = HorizontalAlignment.Stretch;


                frame3d.HorizontalContentAlignment = HorizontalAlignment.Stretch;

                frame3d.VerticalAlignment = VerticalAlignment.Stretch;


                frame3d.VerticalContentAlignment = VerticalAlignment.Stretch;


                //AnaglyphView3D ggg = new AnaglyphView3D();
                // Frame frameStereo = new Frame();
                // frameStereo.Content = ggg;  


                //       frame3d.ClipToBounds = true;
                //frame3d.Width = width;
                //frame3d.Height = height;

                //frame3d.Visibility = Visibility.Hidden;

                //frameStereo.AllowDrop = true;
                //frameStereo.Drop += PUPPICanvas_dropon3d;   

                //canvasview.Children.Add(frameStereo);
                canvasview.Children.Add(frame3d);

                //rotation mode only in 3d
                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)// && thiscanvasdefinitelylocked==false )
                {
                    cbutt.Children.Add(rotationmode);
                    // this.canvasview.Children.Add(rotationmode);
                }

                //if (thiscanvasdefinitelylocked==false )
                //{
                // this.canvasview.Children.Add(leftClickMode);
                cbutt.Children.Add(leftClickMode);
                //}


                /*this.canvasview.Children.Add(setliveupdate);
                this.canvasview.Children.Add(resetcam);
                this.canvasview.Children.Add(zoomextents);*/

                cbutt.Children.Add(setliveupdate);
                cbutt.Children.Add(resetcam);
                cbutt.Children.Add(zoomextents);



                if (PUPPIGUISettings.tabletMode)
                {

                    cbutt.Children.Add(tapMode);
                    // this.canvasview.Children.Add(tapMode);
                }
                if (PUPPIGUISettings.tabletMode || PUPPIGUISettings.displayCameraControlButtons)
                {
                    cbutt.Children.Add(ga);

                    //this.canvasview.Children.Add(tabCameraPanUp);
                    //this.canvasview.Children.Add(tabCameraPanDown);
                    //this.canvasview.Children.Add(tabCameraPanLeft);
                    //this.canvasview.Children.Add(tabCameraPanRight);
                    //if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                    //{
                    //    this.canvasview.Children.Add(tabCameraPanMode);
                    //}

                }
                this.canvasview.Children.Add(cbutt);
                if (PUPPIGUISettings.displayStatusOnCanvas)
                {
                    this.canvasview.Children.Add(pCanvasStatusUpdate);
                }

                if (PUPPIGUISettings.displayInfoHover)
                {
                    this.canvasview.Children.Add(hoverSemiTransparent);
                }

                //frame3d.Margin = new Thickness(0,0,0,0) ;  
                hv.AllowDrop = true;
                frame3d.MouseDown += PUPPICanvas_MouseDown;
                frame3d.MouseUp += PUPPICanvas_MouseUp;
                //border
                hv.BorderBrush = Brushes.LightBlue;
                hv.BorderThickness = new Thickness(2);
                //    hv.MouseMove += dragoutputitem;

                mousemarker = new ModelVisual3D();
                mousemarker.SetName("mousemarker");

                objectUnderMouseText = new BillboardTextVisual3D();
                objectUnderMouseText.SetName("oumt");

                hv.MouseMove += move_marker;
                hv.DragOver += drag_marker;
                //test
                hv.PreviewMouseWheel += hv_PreviewMouseWheel;
                hv.DragEnter += hv_DragEnter;

                //disable some gestures to ensure camera doesn't screw up
                if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    MouseGesture nogesture = new MouseGesture();
                    nogesture.MouseAction = MouseAction.None;
                    hv.RotateGesture = nogesture;
                    hv.ChangeLookAtGesture = nogesture;
                    hv.BackViewGesture = nogesture;
                    hv.BottomViewGesture = nogesture;
                    hv.ChangeFieldOfViewGesture = nogesture;
                    hv.FrontViewGesture = nogesture;
                    hv.LeftViewGesture = nogesture;
                    hv.OrthographicToggleGesture = nogesture;
                    hv.ResetCameraGesture = nogesture;
                    hv.RotateGesture2 = nogesture;
                    hv.TopViewGesture = nogesture;
                }
                else
                {
                    //no annoying middle button double click
                    MouseGesture nogesture = new MouseGesture();
                    nogesture.MouseAction = MouseAction.None;
                    hv.ResetCameraGesture = nogesture;


                }
                //  hv.CameraInertiaFactor = 10;
                //hv.FrameRate = 30;

            }


            //lights
            DefaultLights dl = new DefaultLights();
            hv.Children.Add(dl);

            ////Lighting
            ModelVisual3D tlv3d = new ModelVisual3D();
            PointLight tlight = new PointLight(Colors.Gray, new Point3D(0, 0, 100));
            tlight.Freeze();
            tlv3d.Content = tlight;
            ModelVisual3D dlv3d = new ModelVisual3D();
            PointLight dlight = new PointLight(Colors.Gray, new Point3D(0, -1000, 10));
            dlight.Freeze();
            dlv3d.Content = dlight;
            hv.Children.Add(tlv3d);
            hv.Children.Add(dlv3d);

            //camera reset
            if (fullreset)
            {
                camera_reset();

            }

            //now the grid lines
            gv3d = new GridLinesVisual3D();

            gv3d.Center = new Point3D(0, 0, 0);
            // Width="8" Length="8" MinorDistance="1" MajorDistance="1" Thickness="0.01"
            gv3d.Width = 8;
            gv3d.Length = 8;
            gv3d.MinorDistance = PUPPIGUISettings.nodeSpacing;
            gv3d.MajorDistance = Math.Max(PUPPIGUISettings.nodeSpacing * 2, PUPPIGUISettings.nodeSide / PUPPIGUISettings.nodeSpacing);
            gv3d.Thickness = PUPPIGUISettings.gridThickness;

            SolidColorBrush gridbro = new SolidColorBrush();
            gridbro.Color = Color.FromArgb(Convert.ToByte(255 * PUPPIGUISettings.grid_Alpha), Convert.ToByte(255 * PUPPIGUISettings.grid_Red), Convert.ToByte(255 * PUPPIGUISettings.grid_Green), Convert.ToByte(255 * PUPPIGUISettings.grid_Blue));
            grid_default_mat = new DiffuseMaterial(gridbro);
            gv3d.Material = grid_default_mat;
            gv3d.SetName("grid");
            ignoreclick.Add(gv3d);
            //hv.IsHeadLightEnabled = true;
            if (PUPPIGUISettings.showGridOnCanvas)
                hv.Children.Add(gv3d);
            //grid text
            //for debug
            //for (int gg = 0; gg < gv3d.Length/ gv3d.MinorDistance; gg++)
            //{
            //    double gx = -gv3d.Length *0.5 + gg * gv3d.MinorDistance; 
            //    for (int hh = 0; hh < gv3d.Length/ gv3d.MinorDistance; hh++)
            //    {
            //        double gy = -gv3d.Length *0.5 + hh * gv3d.MinorDistance;
            //       // var text = new TextBlock { Text = "("+ gx.ToString() + ","+ gy.ToString()+  ")" };
            //        BillboardTextVisual3D b3d = new BillboardTextVisual3D();
            //        b3d.Text = "(" + gx.ToString() + "," + gy.ToString() + ")";
            //        b3d.SetName("grid");
            //        b3d.Position = new Point3D(gx, gy, -0.5);
            //        hv.Children.Add(b3d);  
            //    }
            //}


            // gv3d.Visible = false;    
            renderStaticVisual();
            if (thiscanvasdefinitelylocked)
            {
                leftClickModeMove = false;

                rotationmode.Visibility = Visibility.Hidden;
                rotationmode.IsEnabled = false;
                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)// && thiscanvasdefinitelylocked==false )
                {
                    if (rightclickmode.MouseAction == MouseAction.RightClick)
                    {

                    }
                    else
                    {
                        rightclickmode.MouseAction = MouseAction.RightClick;
                        rotationmode.Content = "Rght Clck Rot. Mode";

                    }
                    hv.RotateGesture = rightclickmode;
                }
                leftClickMode.Visibility = Visibility.Hidden;
                leftClickMode.IsEnabled = false;
            }
            else
            {


                rotationmode.Visibility = Visibility.Visible;
                rotationmode.IsEnabled = true;
                leftClickMode.Visibility = Visibility.Visible;
                leftClickMode.IsEnabled = true;
                if (leftClickModeMove == true)
                {
                    leftClickMode.Content = "Left Clck Move Node";



                }
                else
                {

                    leftClickMode.Content = "Left Clck Gesture";
                }
            }
            lastChanged = DateTime.Now;


            if ((PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning || PUPPIruntimesettings.PUPPICanvasHTTPServerIsRunning) && PUPPIruntimesettings.PUPPICanvasServerUpdatingFully)
            {
                PUPPICanvas.currentCanvasStatusServer = readMyCanvasStatus();
                if (PUPPIGUISettings.serverExportHiddenNodes)
                {
                    PUPPICanvas.currentXMLRepServer = saveCanvasRepresentationToXML();
                }
                else
                {
                    PUPPICanvas.currentXMLRepServer = saveCanvasRepresentationToXMLNoHI();
                }
            }

        }

        void frame3d_KeyUp(object sender, KeyEventArgs e)
        {
            //if (e.Key == PUPPIGUISettings.operationModifierKey)
            //{
            //    hv.IsHitTestVisible =true;
            //}
        }

        void hv_DragEnter(object sender, DragEventArgs e)
        {
            mouseisdown = true;
            reset_all_transforms();
            Point p = e.GetPosition(hv);


            if (p.X < 10 || p.X > canvasview.Width - 10 || p.Y < PUPPIGUISettings.windowButtonHeight + 10 || p.Y > canvasview.Height - 10 - PUPPIGUISettings.windowButtonHeight)
            {

                PUPPIModule pm = null;
                try
                {
                    pm = e.Data.GetData("PUPPIModule") as PUPPIModule;

                }
                catch
                {
                    pm = null;
                }
                ////remove line
                removeAllTracesDMR();
                if (pm != null)
                {

                    removeAllTracesDCLS();
                    removeDragSelector();
                    removeAllTracesGLS();
                    mDMtext = pm.cleancap;

                    hv.DragOver += drawMyModuleRepresentation;
                    try
                    {
                        hv.DragOver -= pandrag;
                    }
                    catch
                    {

                    }


                }
            }
        }




        void frame3d_KeyDown(object sender, KeyEventArgs e)
        {


            if (thiscanvasdefinitelylocked == false)
            {

                //if (e.Key==PUPPIGUISettings.operationModifierKey  )
                //{
                //    hv.IsHitTestVisible = false; 
                //}

                bool ico = System.Windows.Forms.Control
                           .IsKeyLocked(System.Windows.Forms.Keys.CapsLock);
                bool iso = (Keyboard.Modifiers & ModifierKeys.Shift)
                                             == ModifierKeys.Shift;
                bool tl = false;
                if (!iso && !ico)
                {
                    tl = true;
                }
                if (e.Key == PUPPIGUISettings.deleteNodeKey || (tl && e.Key.ToString().ToLower() == PUPPIGUISettings.deleteNodeKey.ToString().ToLower()))
                {
                    if (selstacks.Count > 0)
                    {
                        delete_selected_nodes();
                    }
                    else

                        if (node_that_highlighted != null)
                    {
                        if (node_that_highlighted.mycanvas.stacks.ContainsKey(node_that_highlighted.nodeGUID.ToString()))
                        {
                            if (Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey))
                            {
                                //delete stack
                                node_that_highlighted.mycanvas.canvasabouttochange();
                                node_that_highlighted.mycanvas.blockconnupdates = true;
                                node_that_highlighted.deletestack();
                                node_that_highlighted.mycanvas.blockconnupdates = false;
                                node_that_highlighted.mycanvas.update_all_connectors();

                            }
                            else
                            {
                                node_that_highlighted.mycanvas.canvasabouttochange();
                                node_that_highlighted.mycanvas.blockconnupdates = true;
                                node_that_highlighted.delete(true);
                                node_that_highlighted.mycanvas.blockconnupdates = false;
                                node_that_highlighted.mycanvas.update_all_connectors();

                            }
                        }
                        else
                        {
                            node_that_highlighted = null;
                        }
                    }
                }
                if ((e.Key == PUPPIGUISettings.copySelKey && Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey)) || (tl && e.Key.ToString().ToLower() == PUPPIGUISettings.copySelKey.ToString().ToLower()) && Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey))
                {
                    if (selstacks.Count > 0)
                    {
                        copyselectiontoclipboard();
                    }

                }
                if ((e.Key == PUPPIGUISettings.pasteKey && Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey)) || (tl && e.Key.ToString().ToLower() == PUPPIGUISettings.pasteKey.ToString().ToLower()) && Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey))
                {

                    if (node_that_highlighted != null)
                    {
                        canvasabouttochange();
                        node_that_highlighted.pasteontopof();
                    }
                    else
                    {
                        canvasabouttochange();
                        stopMouseEv();
                        pastefromclip(new Point3D(0, 0, 0));
                        resumeMouseEv();
                    }
                }
                if ((e.Key == PUPPIGUISettings.undoKey && Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey)) || (tl && e.Key.ToString().ToLower() == PUPPIGUISettings.undoKey.ToString().ToLower()) && Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey))
                {
                    stopMouseEv();
                    undome();
                    resumeMouseEv();
                }
                if ((e.Key == PUPPIGUISettings.redoKey && Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey)) || (tl && e.Key.ToString().ToLower() == PUPPIGUISettings.redoKey.ToString().ToLower()) && Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey))
                {
                    stopMouseEv();
                    redome();
                    resumeMouseEv();
                }
                if ((e.Key == PUPPIGUISettings.selectAllKey && Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey)) || (tl && e.Key.ToString().ToLower() == PUPPIGUISettings.selectAllKey.ToString().ToLower()) && Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey))
                {
                    selectallnodes();
                }
                if ((e.Key == PUPPIGUISettings.selectNoneKey && Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey)) || (tl && e.Key.ToString().ToLower() == PUPPIGUISettings.selectNoneKey.ToString().ToLower()) && Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey))
                {
                    deselectallnodes();
                }
                if ((e.Key == PUPPIGUISettings.openFileKey && Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey)) || (tl && e.Key.ToString().ToLower() == PUPPIGUISettings.openFileKey.ToString().ToLower()) && Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey))
                {
                    stopMouseEv();
                    openfile();
                    resumeMouseEv();
                }
                if ((e.Key == PUPPIGUISettings.saveFileKey && Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey)) || (tl && e.Key.ToString().ToLower() == PUPPIGUISettings.saveFileKey.ToString().ToLower()) && Keyboard.IsKeyDown(PUPPIGUISettings.operationModifierKey))
                {
                    stopMouseEv();
                    saveas(stacks.Values.ToList<PUPPICanvas.ModViz3DNode>());
                    resumeMouseEv();
                }

            }

        }

        void tabCameraPanUp_Click(object sender, RoutedEventArgs e)
        {

            ProjectionCamera p = hv.Camera;
            if (cpm)
            {
                Point3D pp = p.Position;
                pp.Offset(0, PUPPIGUISettings.nodeSpacing, 0);
                p.Position = pp;
            }
            else
            {


                //figure out if we rotate around where we are looking or clip that
                var rr = new Ray3D(p.Position, p.LookDirection);

                if (rr == null)
                {
                    return;
                }


                var pi = rr.PlaneIntersection(new Point3D(0, 0, 0), new Vector3D(0, 0, 1));
                Point3D rAr = new Point3D();
                double rd = PUPPIGUISettings.nodeSpacing * 10;
                if (pi.HasValue == false)
                {

                }
                else
                {
                    rAr = pi.Value;
                    rAr.Z = 0;
                    Point3D ps = p.Position;
                    ps.Z = 0;
                    Vector3D pz = Point3D.Subtract(rAr, ps);
                    if (pz.Length < PUPPIGUISettings.nodeSpacing * 10) rd = pz.Length;

                }
                Vector3D ldn = p.LookDirection;
                ldn.Normalize();
                //limit up and down
                ldn *= rd;
                Point3D tr = p.Position + ldn;
                double nz = -ldn.Z + PUPPIGUISettings.nodeSpacing;
                double bz = Math.Sqrt(ldn.X * ldn.X + ldn.Y * ldn.Y);
                if (nz > bz) nz = bz;
                Vector3D nl = new Vector3D(ldn.X, ldn.Y, -nz);
                Point3D piz = tr - nl;
                p.Position = piz;
                p.UpDirection = new Vector3D(0, 0, 1);
                p.LookDirection = nl;



            }
            hv.Camera = p;
        }

        void tabCameraPanDown_Click(object sender, RoutedEventArgs e)
        {
            ProjectionCamera p = hv.Camera;
            if (cpm)
            {
                Point3D pp = p.Position;
                pp.Offset(0, -PUPPIGUISettings.nodeSpacing, 0);
                p.Position = pp;
            }
            else
            {
                // Vector3D vv = p.LookDirection;
                // Vector3D ii=Vector3D.CrossProduct(vv, p.UpDirection);
                // Quaternion r = new Quaternion(ii, -5);
                // Matrix3D m = Matrix3D.Identity;
                // m.Rotate(r);
                // Vector3D j = m.Transform(vv);
                // p.LookDirection = j;
                //// p.UpDirection = Vector3D.CrossProduct(j, ii);  


                //figure out if we rotate around where we are looking or clip that
                var rr = new Ray3D(p.Position, p.LookDirection);

                if (rr == null)
                {
                    return;
                }


                var pi = rr.PlaneIntersection(new Point3D(0, 0, 0), new Vector3D(0, 0, 1));
                Point3D rAr = new Point3D();
                double rd = PUPPIGUISettings.nodeSpacing * 10;
                if (pi.HasValue == false)
                {

                }
                else
                {
                    rAr = pi.Value;
                    rAr.Z = 0;
                    Point3D ps = p.Position;
                    ps.Z = 0;
                    Vector3D pz = Point3D.Subtract(rAr, ps);
                    if (pz.Length < PUPPIGUISettings.nodeSpacing * 10) rd = pz.Length;

                }
                Vector3D ldn = p.LookDirection;
                ldn.Normalize();
                //limit up and down
                ldn *= rd;
                Point3D tr = p.Position + ldn;
                double nz = -ldn.Z - PUPPIGUISettings.nodeSpacing;
                double bz = Math.Sqrt(ldn.X * ldn.X + ldn.Y * ldn.Y);
                if (nz < -bz) nz = bz;
                Vector3D nl = new Vector3D(ldn.X, ldn.Y, -nz);
                Point3D piz = tr - nl;
                p.Position = piz;
                p.UpDirection = new Vector3D(0, 0, 1);
                p.LookDirection = nl;

            }
            hv.Camera = p;
        }

        void tabCameraPanLeft_Click(object sender, RoutedEventArgs e)
        {
            ProjectionCamera p = hv.Camera;

            if (cpm)
            {
                Point3D pp = p.Position;
                pp.Offset(-PUPPIGUISettings.nodeSpacing, 0, 0);
                p.Position = pp;
            }
            else
            {
                //Vector3D vv = p.LookDirection;
                //Quaternion r = new Quaternion(new Vector3D(0,0,1) , -5);
                //Matrix3D m = Matrix3D.Identity;
                //m.Rotate(r);
                //Vector3D j = m.Transform(vv);
                //p.LookDirection = j;
                //figure out if we rotate around where we are looking or clip that
                var rr = new Ray3D(p.Position, p.LookDirection);

                if (rr == null)
                {
                    return;
                }


                var pi = rr.PlaneIntersection(new Point3D(0, 0, 0), new Vector3D(0, 0, 1));
                Point3D rAr = new Point3D();
                double rd = PUPPIGUISettings.nodeSpacing * 10;
                if (pi.HasValue == false)
                {

                }
                else
                {
                    rAr = pi.Value;
                    rAr.Z = 0;
                    Point3D ps = p.Position;
                    ps.Z = 0;
                    Vector3D pz = Point3D.Subtract(rAr, ps);
                    if (pz.Length < PUPPIGUISettings.nodeSpacing * 10) rd = pz.Length;

                }
                Vector3D ldn = p.LookDirection;
                ldn.Normalize();
                ldn *= rd;
                Point3D tr = p.Position + ldn;
                //rotate in 2d
                Vector3D rv = new Vector3D(-ldn.X, -ldn.Y, 0);
                double rx = rv.X * Math.Cos(5 * Math.PI / 180) - rv.Y * Math.Sin(5 * Math.PI / 180);
                double ry = rv.X * Math.Sin(5 * Math.PI / 180) + rv.Y * Math.Cos(5 * Math.PI / 180);
                Point3D piz = new Point3D(tr.X + rx, tr.Y + ry, p.Position.Z);



                p.Position = piz;
                p.UpDirection = new Vector3D(0, 0, 1);
                p.LookDirection = tr - piz;


            }
            hv.Camera = p;
        }

        void tabCameraPanRight_Click(object sender, RoutedEventArgs e)
        {
            ProjectionCamera p = hv.Camera;
            if (cpm)
            {
                Point3D pp = p.Position;
                pp.Offset(PUPPIGUISettings.nodeSpacing, 0, 0);
                p.Position = pp;
            }
            else
            {
                //Vector3D vv = p.LookDirection;
                //Quaternion r = new Quaternion(new Vector3D(0,0,1) , 5);
                //Matrix3D m = Matrix3D.Identity;
                //m.Rotate(r);
                //Vector3D j = m.Transform(vv);
                //p.LookDirection = j;

                var rr = new Ray3D(p.Position, p.LookDirection);

                if (rr == null)
                {
                    return;
                }


                var pi = rr.PlaneIntersection(new Point3D(0, 0, 0), new Vector3D(0, 0, 1));
                Point3D rAr = new Point3D();
                double rd = PUPPIGUISettings.nodeSpacing * 10;
                if (pi.HasValue == false)
                {

                }
                else
                {
                    rAr = pi.Value;
                    rAr.Z = 0;
                    Point3D ps = p.Position;
                    ps.Z = 0;
                    Vector3D pz = Point3D.Subtract(rAr, ps);
                    if (pz.Length < PUPPIGUISettings.nodeSpacing * 10) rd = pz.Length;

                }
                Vector3D ldn = p.LookDirection;
                ldn.Normalize();
                ldn *= rd;
                Point3D tr = p.Position + ldn;
                //rotate in 2d
                Vector3D rv = new Vector3D(-ldn.X, -ldn.Y, 0);
                double rx = rv.X * Math.Cos(-5 * Math.PI / 180) - rv.Y * Math.Sin(-5 * Math.PI / 180);
                double ry = rv.X * Math.Sin(-5 * Math.PI / 180) + rv.Y * Math.Cos(-5 * Math.PI / 180);
                Point3D piz = new Point3D(tr.X + rx, tr.Y + ry, p.Position.Z);



                p.Position = piz;
                p.UpDirection = new Vector3D(0, 0, 1);
                p.LookDirection = tr - piz;


            }
            hv.Camera = p;
        }
        void tabCameraPanMode_Click(object sender, RoutedEventArgs e)
        {
            if (cpm)
            {
                cpm = false;
                tabCameraPanMode.Content = "Orbit";
            }
            else
            {
                cpm = true;
                tabCameraPanMode.Content = "Pan";
            }
        }
        void tapMode_Click(object sender, RoutedEventArgs e)
        {
            if (tabletForceRight == true)
            {
                tapMode.Content = "Tap Mode Lft Clck";
                tabletForceRight = false;

            }
            else
            {
                tapMode.Content = "Tap Mode Rght Clck";
                tabletForceRight = true;
                removemanipulator();
            }
        }
        void removeDragSelector()
        {
            //cancel selection
            if (dragSelectAreaRectangle != null && hv.Children.Contains(dragSelectAreaRectangle))
            {
                try
                {
                    hv.Children.Remove(dragSelectAreaRectangle);
                }
                catch
                {

                }

            }
            if (dragSelectAreaRectangle != null && ignoreclick.Contains(dragSelectAreaRectangle))
            {
                try
                {
                    ignoreclick.Remove(dragSelectAreaRectangle);
                }
                catch
                {

                }

            }
            try
            {
                hv.DragOver -= drag_select;
            }
            catch
            {

            }
            // dragSelectAreaRectangle = null; 

        }
        void leftClickMode_Click(object sender, RoutedEventArgs e)
        {


            if (leftClickModeMove == true)
            {
                leftClickMode.Content = "Left Clck Gesture";
                leftClickModeMove = false;
                removemanipulator();
                removeDragSelector();
            }
            else
            {
                leftClickMode.Content = "Left Clck Move Node";
                leftClickModeMove = true;
            }
            removeAllTracesDCLS();
            removeAllTracesDMR();
            removeAllTracesGLS();
            removeAllTracesNMAS();
        }
        //changes whether the program is run every time something changed
        private void setliveupdate_Click(object sender, RoutedEventArgs e)
        {
            slupd8();
        }

        internal void slupd8()
        {
            //menu status change to running
            if (PUPPIruntimesettings.liveupdate == false)
            {
                setliveupdate.Content = "Running...";
                setliveupdate.Background = Brushes.Orange;
                //Action emptyDelegate = delegate { };
                //this.canvasview.Dispatcher.Invoke(emptyDelegate, DispatcherPriority.Render);
                Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);

            }
            PUPPIruntimesettings.liveupdate = !PUPPIruntimesettings.liveupdate;
            if (PUPPIruntimesettings.liveupdate == true)
            {
                //run the program


                PUPPIruntimesettings.processyesno = true;
                runPUPPIprogram();
                //now set to regular header which means it is updating live
                setliveupdate.Content = "Run Live";
                setliveupdate.Background = Brushes.LightGreen;
                //Action emptyDelegate = delegate { };
                //this.canvasview.Dispatcher.Invoke(emptyDelegate, DispatcherPriority.Render);
                Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
            }
            else
            {
                setliveupdate.Content = "Run Prog.";
                setliveupdate.Background = Brushes.LightSalmon;
                //Action emptyDelegate = delegate { };
                //this.canvasview.Dispatcher.Invoke(emptyDelegate, DispatcherPriority.Render);
                Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
                PUPPIruntimesettings.processyesno = false;
            }
        }


        void zoomextents_Click(object sender, RoutedEventArgs e)
        {

            hv.ZoomExtents(500);
            if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional && hv.Camera.Position.Z > 900)
            {
                double X = hv.Camera.Position.X;
                double Y = hv.Camera.Position.Y;
                //  hv.Camera.Position = new Point3D(X, Y, 900);

                //by default we have right click edit mode
                hv.Camera.UpDirection = new Vector3D(0, 1, 0);
                hv.Camera.Position = new Point3D(X, Y, 900);
                hv.Camera.LookDirection = new Vector3D(0, 0, -900);
                // hv.ZoomExtents();
                rightclickmode.MouseAction = MouseAction.None;
            }
        }

        internal void myCanvasPleaseZoomExtents(int mS)
        {
            hv.ZoomExtents(mS);
        }
        //removes the manipulator
        void removemanipulator()
        {
            try
            {
                hv.Children.Remove(cm);
            }
            catch
            {
            }
            usingmanip = false;

        }

        //draws a marker on grid or objects when moving mouse or dragging so we know where it's gonna be in 3d
        void move_marker(object sender, MouseEventArgs e)
        {

            if (e.MiddleButton == MouseButtonState.Pressed)
            {
                return;
            }
            var p = e.GetPosition(hv);
            //only when camera is looking kind of down
            if (hv.Camera.LookDirection.Z < 0 && Math.Abs(hv.Camera.LookDirection.Z) > 5 * Math.Abs(hv.Camera.LookDirection.X) && Math.Abs(hv.Camera.LookDirection.Z) > 5 * Math.Abs(hv.Camera.LookDirection.Y))
            {

                update_marker(p);
            }
            else
            {
                hv.Children.Remove(mousemarker);
            }
            highlight_object(p);
            showhatsunder(p);

        }

        void drag_marker(object sender, DragEventArgs e)
        {
            Point p = e.GetPosition(hv);
            if (hv.Camera.LookDirection.Z < 0 && Math.Abs(hv.Camera.LookDirection.Z) > 5 * Math.Abs(hv.Camera.LookDirection.X) && Math.Abs(hv.Camera.LookDirection.Z) > 5 * Math.Abs(hv.Camera.LookDirection.Y))
            {

                update_marker(p);
            }
            else
            {
                hv.Children.Remove(mousemarker);
            }
            highlight_object(p);
            // showhatsunder(p); 
        }

        void drag_select(object sender, DragEventArgs e)
        {
            Point p = e.GetPosition(hv);
            Vector3D normal;
            Point3D pos;
            // var source = FindSource(p, out n, out markpos);
            var ray = new Ray3D();

            ray = null;
            ray = Viewport3DHelper.Point2DtoRay3D(hv.Viewport, p);


            if (ray == null)
            {
                return;
            }


            var pi = ray.PlaneIntersection(new Point3D(0, 0, PUPPIGUISettings.textRaise), new Vector3D(0, 0, 1));
            if (pi.HasValue == false)
            {
                return;
            }



            if (hv.Children.Contains(dragSelectAreaRectangle))
            {
                try
                {
                    hv.Children.Remove(dragSelectAreaRectangle);
                }
                catch
                {

                }

            }
            //a box to show selection
            double xmin = Math.Min(myPCselStart.X, pi.Value.X);
            double ymin = Math.Min(myPCselStart.Y, pi.Value.Y);
            double xsize = Math.Abs(myPCselStart.X - pi.Value.X);
            double ysize = Math.Abs(myPCselStart.Y - pi.Value.Y);

            dragSelectAreaRectangle = Visual3DExtensions.makeMeaVizBoxFromRectangle(new Rect3D(xmin, ymin, 0, xsize, ysize, PUPPIGUISettings.textRaise), drag_rect_default_mat);
            dragSelectAreaRectangle.SetName("CSAR_PUPPICANVAS");
            hv.Children.Add(dragSelectAreaRectangle);

        }

        //moves the camera as we dragout
        void pandrag(object sender, DragEventArgs e)
        {
            Point p = e.GetPosition(hv);
            updatecamedges(p);

        }
        //moves the camera as we exit under certain conditions
        void letMyMouseGo(object sender, MouseEventArgs e)
        {
            if (e.LeftButton == MouseButtonState.Pressed && (cm.Transform.Value.OffsetX != 0 || cm.Transform.Value.OffsetY != 0))
            {
                Point p = e.GetPosition(hv);
                camfollowmanipulator(p);

            }

            removeAllTracesGLS();
        }






        void updatecamedges(Point p)
        {
            //debugdraw(p); 
            if (p.X < 10 || p.X > frame3d.ActualWidth - 10 || p.Y < PUPPIGUISettings.windowButtonHeight + 10 || p.Y > frame3d.ActualHeight - 10 - PUPPIGUISettings.windowButtonHeight)
            {
                Point3D ccp = hv.Camera.Position;
                Vector3D right = Vector3D.CrossProduct(hv.Camera.LookDirection, hv.Camera.UpDirection);
                Vector3D looky = hv.Camera.LookDirection;
                Vector3D uppy = hv.Camera.UpDirection;
                right.Normalize();
                right.Z = 0;
                double diff = 0;
                //need to compare with grid so we don't stray when we move

                //make grid rectangle match camera z

                // bigger for higher up
                double cZF = Math.Max(Math.Abs(ccp.Z / 20), 1);
                double factorlookdir = 0;
                //for 3d only
                if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.ThreeDimensional)
                {
                    Vector3D ccenter = ccp.ToVector3D();
                    ccenter.Normalize();
                    ccenter.Negate();
                    Vector3D dooky = looky;
                    dooky.Normalize();
                    factorlookdir = 20 * Math.Max(Vector3D.DotProduct(ccenter, dooky), 0);
                }
                Rect3D gridb = new Rect3D(gv3d.Content.Bounds.Location.X - 10 * cZF - factorlookdir, gv3d.Content.Bounds.Location.Y - 10 * cZF - factorlookdir, -Math.Abs(ccp.Z), gv3d.Content.Bounds.SizeX + 20 * cZF + 2 * factorlookdir, gv3d.Content.Bounds.SizeY + 20 * cZF + 2 * factorlookdir, 2 * Math.Abs(ccp.Z));

                Point3D gridcenter = gridb.rectcenter();

                Point3D orpos = new Point3D(ccp.X, ccp.Y, ccp.Z);
                if (p.X > frame3d.ActualWidth - 10)
                {

                    diff = p.X - frame3d.ActualWidth + 10;

                    ccp.Offset(right.X * diff * PUPPIGUISettings.cameraDragPanFactor, right.Y * diff * PUPPIGUISettings.cameraDragPanFactor, right.Z * diff * PUPPIGUISettings.cameraDragPanFactor);
                    if (ccp.isinsiderectangle(gridb) == false && ccp.DistanceTo(gridcenter) > orpos.DistanceTo(gridcenter))
                    {
                        //in 3d 
                        if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                        {
                            //look at center, don't move
                            ccp = hv.Camera.Position;
                            looky.X = gridcenter.X - ccp.X;
                            looky.Y = gridcenter.Y - ccp.Y;
                            Vector3D flatme = new Vector3D(looky.X, looky.Y, 0);
                            right = Vector3D.CrossProduct(flatme, new Vector3D(0, 0, 1));
                            hv.Camera.UpDirection = Vector3D.CrossProduct(right, looky);
                            uppy = Vector3D.CrossProduct(right, looky);
                        }
                        else
                        {

                            //just go back to center
                            ccp = hv.Camera.Position;
                            ccp.X = 0;
                            ccp.Y = 0;
                            uppy = new Vector3D(0, 1, 0);
                            looky = new Vector3D(0, 0, -1);
                        }
                    }
                }
                else if (p.X < 10)
                {
                    diff = p.X - 10;
                    ccp.Offset(right.X * diff * PUPPIGUISettings.cameraDragPanFactor, right.Y * diff * PUPPIGUISettings.cameraDragPanFactor, right.Z * diff * PUPPIGUISettings.cameraDragPanFactor);
                    if (ccp.isinsiderectangle(gridb) == false && ccp.DistanceTo(gridcenter) > orpos.DistanceTo(gridcenter))
                    {
                        if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                        {
                            //look at center, don't move
                            ccp = hv.Camera.Position;
                            looky.X = gridcenter.X - ccp.X;
                            looky.Y = gridcenter.Y - ccp.Y;
                            Vector3D flatme = new Vector3D(looky.X, looky.Y, 0);
                            right = Vector3D.CrossProduct(flatme, new Vector3D(0, 0, 1));
                            hv.Camera.UpDirection = Vector3D.CrossProduct(right, looky);
                            uppy = Vector3D.CrossProduct(right, looky);
                        }
                        else
                        {

                            //just go back to center
                            ccp = hv.Camera.Position;
                            ccp.X = 0;
                            ccp.Y = 0;
                            uppy = new Vector3D(0, 1, 0);
                            looky = new Vector3D(0, 0, -1);
                        }

                    }
                }
                //so that we move uniform regardless if we look way down or stright

                Vector3D movefor = Vector3D.Add(hv.Camera.LookDirection, hv.Camera.UpDirection);
                if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional || (hv.Camera.LookDirection.X == 0 && hv.Camera.LookDirection.Y == 0))
                {
                    looky = hv.Camera.LookDirection;
                    uppy = hv.Camera.UpDirection;
                    looky.Normalize();
                    uppy.Normalize();
                    movefor = Vector3D.Add(looky, uppy);
                    movefor.Normalize();
                }
                movefor.Normalize();
                movefor.Z = 0;
                if (p.Y > frame3d.ActualHeight - PUPPIGUISettings.windowButtonHeight - 10)
                {
                    diff = -(p.Y - frame3d.ActualHeight + PUPPIGUISettings.windowButtonHeight + 10);
                    ccp.Offset(movefor.X * diff * PUPPIGUISettings.cameraDragPanFactor, movefor.Y * diff * PUPPIGUISettings.cameraDragPanFactor, movefor.Z * diff * PUPPIGUISettings.cameraDragPanFactor);
                    if (ccp.isinsiderectangle(gridb) == false && ccp.DistanceTo(gridcenter) > orpos.DistanceTo(gridcenter))
                    {
                        if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                        {
                            //look at center, don't move
                            ccp = hv.Camera.Position;
                            looky.X = gridcenter.X - ccp.X;
                            looky.Y = gridcenter.Y - ccp.Y;
                            Vector3D flatme = new Vector3D(looky.X, looky.Y, 0);
                            right = Vector3D.CrossProduct(flatme, new Vector3D(0, 0, 1));
                            hv.Camera.UpDirection = Vector3D.CrossProduct(right, looky);
                            uppy = Vector3D.CrossProduct(right, looky);
                        }
                        else
                        {

                            //just go back to center
                            ccp = hv.Camera.Position;
                            ccp.X = 0;
                            ccp.Y = 0;
                            uppy = new Vector3D(0, 1, 0);
                            looky = new Vector3D(0, 0, -1);
                        }
                    }
                }
                else if (p.Y < PUPPIGUISettings.windowButtonHeight + 10)
                {
                    diff = -p.Y + PUPPIGUISettings.windowButtonHeight + 10;
                    if (diff > 10) diff = 10;
                    ccp.Offset(movefor.X * diff * PUPPIGUISettings.cameraDragPanFactor, movefor.Y * diff * PUPPIGUISettings.cameraDragPanFactor, movefor.Z * diff * PUPPIGUISettings.cameraDragPanFactor);
                    if (ccp.isinsiderectangle(gridb) == false && ccp.DistanceTo(gridcenter) > orpos.DistanceTo(gridcenter))
                    {
                        if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                        {
                            //look at center, don't move
                            ccp = hv.Camera.Position;
                            looky.X = gridcenter.X - ccp.X;
                            looky.Y = gridcenter.Y - ccp.Y;
                            Vector3D flatme = new Vector3D(looky.X, looky.Y, 0);
                            right = Vector3D.CrossProduct(flatme, new Vector3D(0, 0, 1));
                            hv.Camera.UpDirection = Vector3D.CrossProduct(right, looky);
                            uppy = Vector3D.CrossProduct(right, looky);
                        }
                        else
                        {

                            //just go back to center
                            ccp = hv.Camera.Position;
                            ccp.X = 0;
                            ccp.Y = 0;
                            uppy = new Vector3D(0, 1, 0);
                            looky = new Vector3D(0, 0, -1);
                        }
                    }
                }
                hv.Camera.LookDirection = looky;
                hv.Camera.UpDirection = uppy;
                hv.Camera.Position = ccp;


            }
        }
        //makes camera follow manipulator
        void camfollowmanipulator(Point p)
        {
            //debugdraw(p); 
            if (p.X < 10 || p.X > frame3d.ActualWidth - 10 || p.Y < PUPPIGUISettings.windowButtonHeight + 10 || p.Y > frame3d.ActualHeight - 10)
            {
                Point3D ccp = hv.Camera.Position;
                Vector3D right = Vector3D.CrossProduct(hv.Camera.LookDirection, hv.Camera.UpDirection);
                Vector3D looky = hv.Camera.LookDirection;
                Vector3D uppy = hv.Camera.UpDirection;
                right.Normalize();
                right.Z = 0;
                double diff = 0;


                Point3D orpos = new Point3D(ccp.X, ccp.Y, ccp.Z);
                if (p.X > frame3d.ActualWidth - 10)
                {

                    diff = p.X - frame3d.ActualWidth + 10;

                    ccp.Offset(right.X * diff * PUPPIGUISettings.cameraDragPanFactor, right.Y * diff * PUPPIGUISettings.cameraDragPanFactor, right.Z * diff * PUPPIGUISettings.cameraDragPanFactor);

                }
                else if (p.X < 10)
                {
                    diff = p.X - 10;
                    ccp.Offset(right.X * diff * PUPPIGUISettings.cameraDragPanFactor, right.Y * diff * PUPPIGUISettings.cameraDragPanFactor, right.Z * diff * PUPPIGUISettings.cameraDragPanFactor);

                }
                //so that we move uniform regardless if we look way down or stright
                Vector3D movefor = Vector3D.Add(hv.Camera.LookDirection, hv.Camera.UpDirection);
                if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional || (hv.Camera.LookDirection.X == 0 && hv.Camera.LookDirection.Y == 0))
                {
                    looky = hv.Camera.LookDirection;
                    uppy = hv.Camera.UpDirection;
                    looky.Normalize();
                    uppy.Normalize();
                    movefor = Vector3D.Add(looky, uppy);
                    movefor.Normalize();
                }
                movefor.Normalize();
                movefor.Z = 0;
                if (p.Y > frame3d.ActualHeight - 10)
                {
                    diff = -(p.Y - frame3d.ActualHeight + 10);
                    ccp.Offset(movefor.X * diff * PUPPIGUISettings.cameraDragPanFactor, movefor.Y * diff * PUPPIGUISettings.cameraDragPanFactor, movefor.Z * diff * PUPPIGUISettings.cameraDragPanFactor);

                }
                else if (p.Y < PUPPIGUISettings.windowButtonHeight + 10)
                {
                    diff = -p.Y + PUPPIGUISettings.windowButtonHeight + 10;
                    if (diff > 10) diff = 10;
                    ccp.Offset(movefor.X * diff * PUPPIGUISettings.cameraDragPanFactor, movefor.Y * diff * PUPPIGUISettings.cameraDragPanFactor, movefor.Z * diff * PUPPIGUISettings.cameraDragPanFactor);

                }
                hv.Camera.LookDirection = looky;
                hv.Camera.UpDirection = uppy;
                hv.Camera.Position = ccp;


            }
        }





        void update_marker(Point p)
        {
            //we will not show the marker for now
            try
            {
                hv.Children.Remove(mousemarker);
                return;
            }
            catch
            {
                return;
            }


            Vector3D n;
            Point3D markpos;
            var source = FindSource(p, out n, out markpos);
            var ray = new Ray3D();

            ray = null;
            ray = Viewport3DHelper.Point2DtoRay3D(hv.Viewport, p);


            if (ray == null && source == null)
            {
                try
                {
                    hv.Children.Remove(mousemarker);
                    return;
                }
                catch
                {
                    return;
                }
            }
            double newx = 0;
            double newy = 0;
            double newz = 0;

            var pi = ray.PlaneIntersection(new Point3D(0, 0, PUPPIGUISettings.nodeHeight), new Vector3D(0, 0, 1));
            if (pi.HasValue)
            {
                markpos = new Point3D();
                newx = pi.Value.X.nodespacecenterconvert(PUPPIGUISettings.nodeSpacing);
                newy = pi.Value.Y.nodespacecenterconvert(PUPPIGUISettings.nodeSpacing);

            }
            else
            {
                try
                {
                    hv.Children.Remove(mousemarker);
                    return;
                }
                catch
                {
                    return;
                }

            }
            string str = "";
            if (source != null)
            {
                ModelVisual3D vv = source.Visual as ModelVisual3D;
                if (vv == null)
                {
                    try
                    {
                        hv.Children.Remove(mousemarker);
                        return;
                    }
                    catch
                    {
                        return;
                    }
                }
                str = vv.GetName();
                if (str != null)
                {   //only real components
                    newz = vv.Content.Bounds.Location.Z + vv.Content.Bounds.SizeZ;
                    //also some things that should make it vanish
                    if (str == "manipulator" || str.ElementAt(0) == 'I' || str.ElementAt(0) == 'O')
                    {
                        try
                        {
                            hv.Children.Remove(mousemarker);
                            return;
                        }
                        catch
                        {
                            return;
                        }

                    }
                }
                //not climb on self
                else
                {
                    //in this case we keep the old coordinate
                    try
                    {
                        Point3D oldcenter = mousemarker.Content.Bounds.rectcenter();
                        newx = oldcenter.X;
                        newy = oldcenter.Y;
                        newz = oldcenter.Z;
                    }
                    catch
                    {
                    }
                }
            }

            //not climb on self
            if (str != "mousemarker")
            {
                markpos = new Point3D(newx, newy, newz);



                try
                {
                    hv.Children.Remove(mousemarker);
                }
                catch { }
                var meshBuilder = new MeshBuilder(false, false);
                meshBuilder.AddSphere(markpos, PUPPIGUISettings.markerRadius);
                var mesh = meshBuilder.ToMesh(true);
                GeometryModel3D newModel = new GeometryModel3D();
                newModel.Geometry = mesh;
                newModel.Material = marker_default_mat;
                mousemarker.Content = newModel;
                hv.Children.Add(mousemarker);

            }

        }
        ModelVisual3D transformed;
        void showhatsunder(Point p)
        {



            Vector3D n;
            Point3D markpos;
            var source = FindSource(p, out n, out markpos);



            if (source == null)
            {
                if (transformed != null)
                {
                    transformed.Transform = Transform3D.Identity;
                    transformed = null;
                }
                string s = updatemyPCStatusNW(my_old_pc_status, Brushes.Black);
                uHoNodeIO("");
                return;
            }

            string str = "";
            if (source != null)
            {
                ModelVisual3D vv = source.Visual as ModelVisual3D;
                if (vv == null)
                {
                    string s = updatemyPCStatusNW(my_old_pc_status, Brushes.Black);
                    uHoNodeIO("");
                    if (transformed != null)
                    {
                        transformed.Transform = Transform3D.Identity;
                        transformed = null;
                    }
                    return;

                }
                if (ignoreclick.Contains(vv))
                {
                    string s = updatemyPCStatusNW(my_old_pc_status, Brushes.Black);
                    uHoNodeIO("");
                    if (transformed != null)
                    {
                        transformed.Transform = Transform3D.Identity;
                        transformed = null;
                    }
                    return;
                }
                str = vv.GetName();
                if (str != null)
                {
                    //try to get info
                    if (str.StartsWith("I"))
                    {
                        try
                        {
                            char[] sep = { '_' };
                            string[] ss = str.Split(sep, StringSplitOptions.None);

                            if (stacks.ContainsKey(ss[2]))
                            {
                                ModViz3DNode mao = stacks[ss[2]];
                                string viname = "";
                                try
                                {
                                    viname = mao.vizinputs[Convert.ToInt16(ss[1])].visualInputNameString;
                                }
                                catch
                                {
                                    viname = "";
                                }

                                string vival = "";
                                try
                                {
                                    vival = mao.vizinputs[Convert.ToInt16(ss[1])].visualInputValueString;
                                }
                                catch
                                {
                                    vival = "";
                                }
                                if (mao.caption != null)
                                {
                                    string s = updatemyPCStatusNW(mao.caption.Text + " " + viname + ":" + vival, Brushes.DarkOrange);
                                    uHoNodeIO(mao.caption.Text + "\n" + viname + ":" + vival);
                                }
                                else
                                {
                                    string s = updatemyPCStatusNW("Node input " + viname + ":" + vival, Brushes.DarkOrange);
                                    uHoNodeIO("Node input " + viname + ":" + vival);
                                }
                                try
                                {

                                    if (transformed != null && transformed != mao.vizinputs[Convert.ToInt16(ss[1])].myself)
                                    {
                                        transformed.Transform = Transform3D.Identity;
                                        transformed = null;
                                    }



                                    if (PUPPIGUISettings.popInputsOutputs)
                                    {
                                        int iindex = Convert.ToInt16(ss[1]);
                                        Transform3DGroup tg = new Transform3DGroup();

                                        //check custom input
                                        if (mao.nodeCustomRenderer != null && PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional && mao.nodeCustomRenderer.use3D && mao.nodeCustomRenderer.inputPositions.Count > 0)
                                        {
                                            //Point3D pl = mao.nodeCustomRenderer.inputPositions[iindex].model3D.getBBRecursive
                                            //Vector3D vl = pl.ToVector3D();



                                            //tg.Children.Add(new TranslateTransform3D(-vl));
                                            //double st = Math.Max(1.1, hv.Camera.Position.DistanceTo(pl) * 0.05);

                                            //tg.Children.Add(new ScaleTransform3D(st, st, st));


                                            //tg.Children.Add(new TranslateTransform3D(vl));
                                            //mao.vizinputs[Convert.ToInt16(ss[1])].myself.Transform = tg;
                                            //transformed = mao.vizinputs[Convert.ToInt16(ss[1])].myself;
                                        }
                                        else if (mao.nodeCustomRenderer != null && PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional && mao.nodeCustomRenderer.use2D && mao.nodeCustomRenderer.inputPositions.Count > 0)
                                        {

                                        }
                                        else
                                        {

                                            Vector3D vl = mao.vizinputs[iindex].myPosition.ToVector3D();



                                            tg.Children.Add(new TranslateTransform3D(-vl));
                                            double st = Math.Max(1.1, hv.Camera.Position.DistanceTo(mao.vizinputs[iindex].myPosition) * 0.05);

                                            tg.Children.Add(new ScaleTransform3D(st, st, st));


                                            tg.Children.Add(new TranslateTransform3D(vl));
                                            mao.vizinputs[Convert.ToInt16(ss[1])].myself.Transform = tg;
                                            transformed = mao.vizinputs[Convert.ToInt16(ss[1])].myself;
                                        }
                                    }
                                }
                                catch
                                {
                                    if (transformed != null)
                                    {
                                        transformed.Transform = Transform3D.Identity;
                                        transformed = null;
                                    }
                                }

                            }
                            else
                            {
                                if (transformed != null)
                                {
                                    transformed.Transform = Transform3D.Identity;
                                    transformed = null;
                                }
                            }
                        }
                        catch
                        {
                            string sss = updatemyPCStatusNW(my_old_pc_status, Brushes.Black);
                            uHoNodeIO("");
                            if (transformed != null)
                            {
                                transformed.Transform = Transform3D.Identity;
                                transformed = null;
                            }
                        }
                    }

                    else if (str.StartsWith("O"))
                    {
                        try
                        {
                            char[] sep = { '_' };
                            string[] ss = str.Split(sep, StringSplitOptions.None);

                            if (stacks.ContainsKey(ss[2]))
                            {
                                ModViz3DNode mao = stacks[ss[2]];
                                string viname = "";
                                try
                                {
                                    viname = mao.vizoutputs[Convert.ToInt16(ss[1])].visualOutputNameString;
                                }
                                catch
                                {
                                    viname = "";
                                }

                                string vival = "";
                                try
                                {
                                    vival = mao.vizoutputs[Convert.ToInt16(ss[1])].visualOutputValueString;
                                }
                                catch
                                {
                                    vival = "";
                                }
                                if (mao.caption != null)
                                {
                                    string s = updatemyPCStatusNW(mao.caption.Text + " " + viname + ":" + vival, Brushes.Green);
                                    uHoNodeIO(mao.caption.Text + "\n" + viname + ":" + vival);
                                }
                                else
                                {
                                    string s = updatemyPCStatusNW("Node output " + viname + ":" + vival, Brushes.Green);
                                    uHoNodeIO("Node output " + viname + ":" + vival);
                                }
                                try
                                {

                                    if (transformed != null && transformed != mao.vizoutputs[Convert.ToInt16(ss[1])].myself)
                                    {
                                        transformed.Transform = Transform3D.Identity;
                                        transformed = null;
                                    }

                                    if (PUPPIGUISettings.popInputsOutputs)
                                    {
                                        int iindex = Convert.ToInt16(ss[1]);
                                        Transform3DGroup tg = new Transform3DGroup();

                                        //check custom output
                                        if (mao.nodeCustomRenderer != null && PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional && mao.nodeCustomRenderer.use3D && mao.nodeCustomRenderer.outputPositions.Count > 0)
                                        {
                                        }
                                        else if (mao.nodeCustomRenderer != null && PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional && mao.nodeCustomRenderer.use2D && mao.nodeCustomRenderer.outputPositions.Count > 0)
                                        {

                                        }
                                        else
                                        {

                                            Vector3D vl = mao.vizoutputs[iindex].myPosition.ToVector3D(); ;

                                            tg.Children.Add(new TranslateTransform3D(-vl));
                                            double st = Math.Max(1.1, hv.Camera.Position.DistanceTo(mao.vizoutputs[iindex].myPosition) * 0.05);

                                            tg.Children.Add(new ScaleTransform3D(st, st, st));
                                            tg.Children.Add(new TranslateTransform3D(vl));
                                            mao.vizoutputs[Convert.ToInt16(ss[1])].myself.Transform = tg;
                                            transformed = mao.vizoutputs[Convert.ToInt16(ss[1])].myself;
                                        }
                                    }
                                }
                                catch
                                {
                                    if (transformed != null)
                                    {
                                        transformed.Transform = Transform3D.Identity;
                                        transformed = null;
                                    }
                                }
                            }
                            else
                            {
                                if (transformed != null)
                                {
                                    transformed.Transform = Transform3D.Identity;
                                    transformed = null;
                                }
                            }
                        }
                        catch
                        {
                            string sss = updatemyPCStatusNW(my_old_pc_status, Brushes.Black);
                            uHoNodeIO("");
                            if (transformed != null)
                            {
                                transformed.Transform = Transform3D.Identity;
                                transformed = null;
                            }
                        }
                    }
                    else
                    {
                        if (transformed != null)
                        {
                            transformed.Transform = Transform3D.Identity;
                            transformed = null;
                        }
                        if (str.EndsWith("_Caption"))
                        {
                            str = str.Replace("_Caption", "");
                        }
                        if (str.EndsWith("_CustomChild"))
                        {
                            str = str.Replace("_CustomChild", "");
                        }
                        try
                        {


                            if (stacks.ContainsKey(str))
                            {
                                ModViz3DNode mao = stacks[str];
                                if (mao.caption != null)
                                {
                                    string s = updatemyPCStatusNW(mao.caption.Text + " GUID:" + mao.nodeGUID.ToString(), Brushes.DarkBlue);
                                    uHoNodeIO(mao.caption.Text + "\nGUID:" + mao.nodeGUID.ToString());
                                }
                                else
                                {
                                    string s = updatemyPCStatusNW("Node GUID:" + mao.nodeGUID.ToString(), Brushes.DarkBlue);
                                    uHoNodeIO("Node GUID:" + mao.nodeGUID.ToString());
                                }
                            }
                            else
                            {
                                string sss = updatemyPCStatusNW(my_old_pc_status, Brushes.Black);
                                uHoNodeIO("");

                            }
                        }
                        catch
                        {
                            string sss = updatemyPCStatusNW(my_old_pc_status, Brushes.Black);
                            uHoNodeIO("");
                        }
                    }

                }
                else
                {
                    string s = updatemyPCStatusNW(my_old_pc_status, Brushes.Black);
                    uHoNodeIO("");
                    if (transformed != null)
                    {
                        transformed.Transform = Transform3D.Identity;
                        transformed = null;
                    }
                }

            }
            else
            {
                if (transformed != null)
                {
                    transformed.Transform = Transform3D.Identity;
                    transformed = null;
                }
            }




        }

        ModViz3DNode getMyNodeByVisualName(string svn, ModelVisual3D vv)
        {
            ModViz3DNode myviz = null;

            if (svn != "oumt" && svn != "trialname" && svn != "grid" && svn.Contains("staticVisual") == false && svn.Contains("Conn_") == false && svn != "light" && svn != "manipulator" && svn.ElementAt(0) != 'I' && svn.ElementAt(0) != 'O')//&& svn != "mousemarker")
            {


                //if dropped on caption, take their parent 
                if (vv.GetName().Contains("_Caption") || vv.GetName().Contains("_CustomChild"))
                {
                    vv = VisualTreeHelper.GetParent(vv) as ModelVisual3D;
                }
                if (vv != null)
                {

                    //so we don't get captions and other crap - by size or numeric name
                    if (vv.Content.Bounds.SizeZ == PUPPIGUISettings.nodeHeight || Regex.IsMatch(vv.GetName(), @"^\d+$"))
                    {

                        GeometryModel3D gm = vv.Content as GeometryModel3D;



                        try
                        {
                            myviz = stacks[vv.GetName()];

                        }
                        catch
                        {
                            myviz = null;
                        }
                    }
                }
            }
            return myviz;

        }


        internal ModViz3DNode node_that_highlighted = null;
        //shows which object we are gonna do
        void highlight_object(Point p)
        {
            node_that_highlighted = null;
            Vector3D n;
            Point3D markpos;
            var source = FindSource(p, out n, out markpos);
            int desel = hvhlch;
            hvhlch = -1;
            //make sure we hit something that should respond to clicks
            bool somethingthere = true;

            if (source == null || source.Visual == null)
            {
                somethingthere = false;
            }
            else
            {
                if (ignoreclick.Contains(source.Visual))
                {
                    somethingthere = false;
                }
            }

            if (somethingthere == true)
            {

                //we can highlight
                try
                {
                    string svn = source.Visual.GetName();
                    if (svn != "oumt" && svn != "trialname" && svn != "grid" && svn.Contains("staticVisual") == false && svn.Contains("Conn_") == false && svn != "light" && svn != "manipulator" && svn.ElementAt(0) != 'I' && svn.ElementAt(0) != 'O')//&& svn != "mousemarker")
                    {

                        ModelVisual3D vv = source.Visual as ModelVisual3D;
                        //if dropped on caption, take their parent 
                        if (vv.GetName().Contains("_Caption") || vv.GetName().Contains("_CustomChild"))
                        {
                            vv = VisualTreeHelper.GetParent(vv) as ModelVisual3D;
                        }
                        if (vv != null)
                        {

                            //so we don't get captions and other crap - by size or numeric name
                            if (vv.Content.Bounds.SizeZ == PUPPIGUISettings.nodeHeight || Regex.IsMatch(vv.GetName(), @"^\d+$"))
                            {
                                hvhlch = hv.Children.IndexOf(vv);
                                GeometryModel3D gm = vv.Content as GeometryModel3D;
                                gm.Material = node_clicked_default_mat;
                                ModViz3DNode myviz = null;

                                try
                                {
                                    myviz = stacks[vv.GetName()];

                                }
                                catch
                                {
                                    myviz = null;
                                }

                                if (myviz != null)
                                {
                                    node_that_highlighted = myviz;
                                    //now connections
                                    foreach (ModViz3DInput myinput in myviz.vizinputs)
                                    {
                                        if (myinput != null)
                                        {
                                            //also change the color of the connector
                                            if (myinput.myself != null)
                                            {
                                                GeometryModel3D im = myinput.myself.Content as GeometryModel3D;
                                                im.Material = node_clicked_default_mat;
                                            }
                                            if (myinput.myconnector != null)
                                            {
                                                if (myinput.myconnector.myself != null)
                                                {
                                                    GeometryModel3D cm = myinput.myconnector.myself.Content as GeometryModel3D;

                                                    cm.Material = connsel_default_matg;
                                                    //if (cm.Bounds.SizeX > 0)
                                                    //{


                                                    //    double sfx = 1 + PUPPIGUISettings.ioWidth*0.5 / cm.Bounds.SizeX;
                                                    //    Point3D pli = cm.Bounds.rectcenter();
                                                    //    Vector3D vli = new Vector3D(sfx, 1, 1);
                                                    //    cm.Transform = new ScaleTransform3D(vli, pli);
                                                    //}


                                                }
                                            }
                                        }
                                    }
                                    foreach (ModViz3DOutput myoutput in myviz.vizoutputs)
                                    {
                                        if (myoutput != null)
                                        {
                                            if (myoutput.myself != null)
                                            {
                                                GeometryModel3D om = myoutput.myself.Content as GeometryModel3D;
                                                om.Material = node_clicked_default_mat;
                                            }
                                            foreach (ModViz3DConn myconnector in myoutput.outboundconns)
                                                if (myconnector != null)
                                                {
                                                    if (myconnector.myself != null)
                                                    {
                                                        GeometryModel3D cm = myconnector.myself.Content as GeometryModel3D;
                                                        cm.Material = connsel_default_matg;
                                                        //if (cm.Bounds.SizeX > 0)
                                                        //{
                                                        //    double sfx = 1 + PUPPIGUISettings.ioWidth*0.5 / cm.Bounds.SizeX;
                                                        //    Point3D pli=cm.Bounds.rectcenter();
                                                        //    Vector3D vli=new Vector3D(sfx,1,1);
                                                        //    cm.Transform = new ScaleTransform3D( vli,pli);
                                                        //}
                                                    }
                                                }
                                        }
                                    }
                                }
                            }
                        }

                    }
                    //    //hover over inputs
                    //    if (source.Visual.GetName().ElementAt(0) == 'I')
                    //    {

                    //    }
                    //else
                    //{

                    //}

                    //when over a connection we make nodes transparent
                    if (svn.Contains("Conn_") == true)
                    {
                        if (nodesaretransparent == false)
                        {
                            makenodestransparent();
                        }

                    }
                    else
                    {
                        if (nodesaretransparent)
                        {
                            makenodesnottransparent();
                        }
                    }

                }
                catch
                {

                }
            }
            //also make nodes not transparent when nothing touched
            else
            {
                if (nodesaretransparent)
                {
                    makenodesnottransparent();
                }
            }




            //deselects previous

            if (desel != -1 && desel != hvhlch)
            {
                try
                {
                    ModelVisual3D vv = hv.Children[desel] as ModelVisual3D;
                    if (vv != null && vv.Content.Bounds.SizeZ == PUPPIGUISettings.nodeHeight)
                    {
                        GeometryModel3D gm = vv.Content as GeometryModel3D;
                        gm.Material = node_default_mat;

                        ModViz3DNode myviz = null;


                        try
                        {
                            myviz = stacks[hv.Children[desel].GetName()];

                        }
                        catch
                        {
                            myviz = null;
                        }

                        if (myviz != null)
                        {
                            //selection
                            if (selstacks.Contains(myviz.nodeGUID.ToString()) && myviz.nodeCustomRenderer == null)
                            {
                                gm.Material = node_selected_default_mat;
                            }
                            else if (myviz.nodeCustomRenderer == null && myviz.nodeUpdatedMaterial != null)
                            {
                                gm.Material = myviz.nodeUpdatedMaterial;
                            }

                            //now connections and inputs
                            int ii = 0;
                            foreach (ModViz3DInput myinput in myviz.vizinputs)
                            {
                                if (myinput != null)
                                {
                                    //also change back the color of the input
                                    if (myinput.myself != null)
                                    {

                                        GeometryModel3D im = myinput.myself.Content as GeometryModel3D;
                                        if (myviz.logical_representation.inputs[ii].module == null)
                                        {
                                            if (myviz.logical_representation.inputs[ii].isoptional == true)
                                            {
                                                im.Material = emptyoptionalinput_default_mat;
                                            }
                                            else
                                            {
                                                im.Material = emptyInput_default_mat;
                                            }
                                        }
                                        else
                                        {
                                            im.Material = input_default_mat;
                                        }



                                    }
                                    //also change back the color of the connector
                                    if (myinput.myconnector != null)
                                    {
                                        if (myinput.myconnector.myself != null)
                                        {
                                            GeometryModel3D cm = myinput.myconnector.myself.Content as GeometryModel3D;
                                            cm.Material = MaterialHelper.CreateMaterial(ColorHelper.HsvToColor(myinput.myconnector.cindex, myinput.myconnector.colsaturation, myinput.myconnector.colvallue));
                                            cm.Transform = Transform3D.Identity;
                                        }
                                    }
                                }
                                ii++;
                            }
                            foreach (ModViz3DOutput myoutput in myviz.vizoutputs)
                            {
                                if (myoutput != null)
                                {
                                    if (myoutput.myself != null)
                                    {
                                        GeometryModel3D om = myoutput.myself.Content as GeometryModel3D;
                                        om.Material = output_default_mat;
                                    }
                                    foreach (ModViz3DConn myconnector in myoutput.outboundconns)
                                        if (myconnector != null)
                                        {
                                            if (myconnector.myself != null)
                                            {
                                                GeometryModel3D cm = myconnector.myself.Content as GeometryModel3D;

                                                cm.Material = MaterialHelper.CreateMaterial(ColorHelper.HsvToColor(myconnector.cindex, myconnector.colsaturation, myconnector.colvallue));
                                                cm.Transform = Transform3D.Identity;
                                            }
                                        }
                                }
                            }
                        }

                    }
                }

                catch
                {

                }
            }


        }
        //test zoom
        private void hv_PreviewMouseWheel(object sender, MouseWheelEventArgs e)
        {

            if (hv.Camera.LookDirection.Length >= 800 && e.Delta < 0)
            {
                Vector3D vava = hv.Camera.LookDirection;
                vava = Vector3D.Multiply(800 / vava.Length, vava);
                hv.Camera.LookDirection = vava;
            }

            if (hv.Camera.LookDirection.Length <= 5 && e.Delta > 0)
            {
                Vector3D vava = hv.Camera.LookDirection;
                vava.Normalize();
                vava = Vector3D.Multiply(5, vava);
                hv.Camera.LookDirection = vava;
            }
        }


        private void PUPPICanvas_dropon3d(object sender, DragEventArgs e)
        {

            mouseisdown = false;
            removeAllTracesDMR();
            removeAllTracesNMAS();
            string sev = "";
            dragip = false;
            //reset cursor back to arrow
            // this.Cursor = Cursors.Arrow;  
            //   Mouse.OverrideCursor = null; 
            //gotta get rid of the marker
            try
            {
                hv.Children.Remove(mousemarker);
            }
            catch
            {

            }
            issaved = false;
            //remove the drag mousemove
            hv.MouseMove -= dragoutputitem;
            hv.MouseMove -= dragOverNodeGesture;
            hv.MouseMove -= dragnode2move;
            var p = e.GetPosition(hv);

            Vector3D n;
            Point3D pos;
            var source = FindSource(p, out n, out pos);


            if (PUPPIGUISettings.tabletMode)
            {
                source = FindSourceTablet(p, out n, out pos);
            }

            if (source != null && source.Visual != null)
            {
                sev = source.Visual.GetName();
            }

            PUPPIModule pm = null;
            try
            {
                pm = e.Data.GetData("PUPPIModule") as PUPPIModule;

            }
            catch
            {
            }
            ModViz3DNode mnodesource = null;
            try
            {
                mnodesource = e.Data.GetData("ModViz3DNode") as ModViz3DNode;
            }
            catch
            {

            }
            ModelVisual3D selectedRec = null;
            try
            {
                selectedRec = e.Data.GetData("ModelVisual3D") as ModelVisual3D;
            }
            catch
            {

            }

            //rectangle selection move
            if ((selectedRec != null && selectedRec == dragSelectAreaRectangle) && thiscanvasdefinitelylocked == false && leftClickModeMove == true)
            {

                if (source == null)
                {
                    var ray = Viewport3DHelper.Point2DtoRay3D(hv.Viewport, p);
                    if (ray != null)
                    {
                        var pi = ray.PlaneIntersection(new Point3D(0, 0, PUPPIGUISettings.nodeHeight / 2), new Vector3D(0, 0, 1));
                        if (pi.HasValue)
                        {
                            pos = pi.Value;
                        }
                        else
                        {
                            pos = new Point3D(-99999, -99999, -99999);
                        }
                    }
                    else
                    {
                        pos = new Point3D(-99999, -99999, -99999);
                    }
                }

                if (pos.Z == -99999) return;

                //move node or selection to position


                if (nmasStartAc.Z == -99999 || nmasStart.Z == -99999) return;

                double ox = pos.X - nmasStart.X;
                double oy = pos.Y - nmasStart.Y;

                //and make sure we're not just clickdragging for nothing
                double cox = pos.X - nmasStartAc.X;
                double coy = pos.Y - nmasStartAc.Y;
                //check for any transforms
                //only one transform at one time
                //check if selectionm rectangle has transform
                if (dragSelectAreaRectangle != null && hv.Children.Contains(dragSelectAreaRectangle) && selstacks.Count > 0 && (Math.Abs(ox) >= PUPPIGUISettings.nodeSpacing || Math.Abs(oy) >= PUPPIGUISettings.nodeSpacing) && (Math.Abs(cox) >= PUPPIGUISettings.nodeSpacing || Math.Abs(coy) >= PUPPIGUISettings.nodeSpacing))
                {


                    canvasabouttochange();

                    //disable updating nodes until we are done
                    blockconnupdates = true;
                    List<ModViz3DNode> nm = new List<ModViz3DNode>();
                    //move all selected nodes
                    foreach (string g in selstacks)
                    {
                        ModViz3DNode mv = null;
                        if (stacks.TryGetValue(g, out mv))
                            if (mv != null && mv.parent == null) nm.Add(mv);

                    }
                    foreach (ModViz3DNode mv in nm)
                    {
                        mv.movestack(ox, oy);
                    }
                    foreach (ModViz3DNode mv in nm)
                    {
                        mv.fitroots(stacks);
                    }
                    deselectallnodes();
                    removeDragSelector();
                    // dragSelectAreaRectangle = null; 
                    blockconnupdates = false;
                    update_all_connectors();
                    try
                    {
                        cm.Transform.Value.SetIdentity();
                        if (hv.Children.IndexOf(cm) >= 0)
                        {
                            cm.UnBind();
                            hv.Children.Remove(cm);
                        }



                    }
                    catch
                    {
                    }


                }




                reset_all_transforms();
                update_grid();

            }
            else

                ////node move
                if ((mnodesource != null) && thiscanvasdefinitelylocked == false && leftClickModeMove == true)
            {

                if (source == null)
                {
                    var ray = Viewport3DHelper.Point2DtoRay3D(hv.Viewport, p);
                    if (ray != null)
                    {
                        var pi = ray.PlaneIntersection(new Point3D(0, 0, PUPPIGUISettings.nodeHeight / 2), new Vector3D(0, 0, 1));
                        if (pi.HasValue)
                        {
                            pos = pi.Value;
                        }
                        else
                        {
                            pos = new Point3D(-99999, -99999, -99999);
                        }
                    }
                    else
                    {
                        pos = new Point3D(-99999, -99999, -99999);
                    }
                }

                if (pos.Z == -99999) return;

                //move node or selection to position

                if (nmasStartAc.Z == -99999 || nmasStart.Z == -99999) return;

                double ox = pos.X - nmasStart.X;
                double oy = pos.Y - nmasStart.Y;

                //and make sure we're not just clickdragging for nothing
                double cox = pos.X - nmasStartAc.X;
                double coy = pos.Y - nmasStartAc.Y;


                //check for any transforms
                //only one transform at one time
                //check if selectionm rectangle has transform
                if (dragSelectAreaRectangle != null && hv.Children.Contains(dragSelectAreaRectangle) && selstacks.Count > 0 && (Math.Abs(ox) >= PUPPIGUISettings.nodeSpacing || Math.Abs(oy) >= PUPPIGUISettings.nodeSpacing) && (Math.Abs(cox) >= PUPPIGUISettings.nodeSpacing || Math.Abs(coy) >= PUPPIGUISettings.nodeSpacing))
                {


                    canvasabouttochange();

                    //disable updating nodes until we are done
                    blockconnupdates = true;
                    List<ModViz3DNode> nm = new List<ModViz3DNode>();
                    //move all selected nodes
                    foreach (string g in selstacks)
                    {
                        ModViz3DNode mv = null;
                        if (stacks.TryGetValue(g, out mv))
                            if (mv != null && mv.parent == null) nm.Add(mv);

                    }
                    foreach (ModViz3DNode mv in nm)
                    {
                        mv.movestack(ox, oy);
                    }
                    foreach (ModViz3DNode mv in nm)
                    {
                        mv.fitroots(stacks);
                    }
                    deselectallnodes();
                    removeDragSelector();
                    // dragSelectAreaRectangle = null; 
                    blockconnupdates = false;
                    update_all_connectors();
                    try
                    {
                        cm.Transform.Value.SetIdentity();
                        if (hv.Children.IndexOf(cm) >= 0)
                        {
                            cm.UnBind();
                            hv.Children.Remove(cm);
                        }



                    }
                    catch
                    {
                    }


                }

                else //if (mnodesource != null)
                     //move our node
                    if ((Math.Abs(ox) >= PUPPIGUISettings.nodeSpacing || Math.Abs(oy) >= PUPPIGUISettings.nodeSpacing) && (Math.Abs(cox) >= PUPPIGUISettings.nodeSpacing || Math.Abs(coy) >= PUPPIGUISettings.nodeSpacing))
                {






                    ModViz3DNode myroot = mnodesource.getroot();
                    //try to put stack on another node
                    ModViz3DNode foundBase = null;
                    if (source != null && source.Visual != null && PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.ThreeDimensional)
                    {
                        try
                        {
                            string svn = source.Visual.GetName();
                            foundBase = getMyNodeByVisualName(svn, source.Visual as ModelVisual3D);
                        }
                        catch
                        {
                            foundBase = null;
                        }
                    }

                    if (foundBase == null || foundBase.acceptschilds() == false)
                    {
                        canvasabouttochange();

                        //disable updating nodes until we are done
                        blockconnupdates = true;
                        myroot.movestack(ox, oy);

                        myroot.fitroots(stacks);
                        blockconnupdates = false;
                        update_all_connectors();
                    }
                    else
                    {

                        List<ModViz3DNode> nodesToAdd = new List<ModViz3DNode>();

                        myroot.getalllevelschildren(nodesToAdd);

                        nodesToAdd.Add(myroot);
                        for (int i = 0; i < nodesToAdd.Count; i++)
                        {
                            ModViz3DNode m = nodesToAdd[i];
                            try
                            {
                                if (m.myself != null)
                                {
                                    hv.Children.Remove(m.myself);
                                }
                                m.myself = null;
                            }
                            catch
                            {

                            }
                        }

                        nodesToAdd.Clear();
                        nodesToAdd.Add(myroot);
                        foundBase.moveontopof(nodesToAdd);


                    }





                    try
                    {
                        cm.Transform.Value.SetIdentity();
                        if (hv.Children.IndexOf(cm) >= 0)
                        {
                            cm.UnBind();
                            hv.Children.Remove(cm);
                        }



                    }
                    catch
                    {
                    }

                }







                reset_all_transforms();
                update_grid();

            }
            else
                    if (pm != null)
            {
                if (thiscanvasdefinitelylocked == false)
                {

                    //so we don't drop unique nodes
                    if (pm.unique == true && contains_unique_node(pm))
                    {
                        MessageBox.Show("Unique node of type " + pm.name + " already on canvas!");
                        return;
                    }
                    //drop in the undo, making sure it is different
                    canvasabouttochange();
                    //make sure we hit something that should respond to clicks
                    bool somethingthere = true;

                    if (source == null)
                    {
                        somethingthere = false;
                    }
                    else
                    {
                        if (ignoreclick.Contains(source.Visual))
                        {
                            somethingthere = false;
                        }
                    }

                    if (somethingthere == true)
                    {
                        try
                        {
                            string svn = source.Visual.GetName();
                            if (svn != "trialname" && svn != "grid" && svn.Contains("staticVisual") == false && svn.Contains("Conn_") == false && svn != "light" && svn != "manipulator" && svn.ElementAt(0) != 'I' && svn.ElementAt(0) != 'O')
                            {

                                ModelVisual3D vv = source.Visual as ModelVisual3D;
                                //if dropped on caption, take their parent 
                                if (vv.GetName().Contains("_Caption") || vv.GetName().Contains("_CustomChild"))
                                {
                                    vv = VisualTreeHelper.GetParent(vv) as ModelVisual3D;
                                }
                                if (vv == null) { return; }



                                //for now only if we click on topmost

                                Point3D topsource = new Point3D();
                                //top point
                                topsource = new Point3D(source.Model.Bounds.Location.X + source.Model.Bounds.SizeX * 0.5, source.Model.Bounds.Location.Y + source.Model.Bounds.SizeY * 0.5, source.Model.Bounds.Location.Z + source.Model.Bounds.SizeZ * 3 / 2);

                                Rect3D orloc = source.Model.Bounds;
                                string orGUID = vv.GetName();

                                ModViz3DNode gotnode = stacks[orGUID];
                                //check maximum number of childs
                                if (gotnode != null)
                                {
                                    if (gotnode.acceptschilds() == false)
                                    {
                                        return;
                                    }
                                }


                                //disable updating nodes until we are done
                                blockconnupdates = true;
                                blockfitroots = true;
                                ModViz3DNode newone = gotnode.addontopof(gotnode, null);
                                //get class name (subclass of PUPPImodule)

                                Type tm = pm.GetType();

                                if (tm == null)
                                {
                                    blockconnupdates = false;
                                    blockfitroots = false;
                                    return;
                                }
                                object pm1 = System.Activator.CreateInstance(tm);
                                //but we need to also keep the changed caption
                                if (pm.cleancap != "")
                                {
                                    (pm1 as PUPPIModule).cleancap = pm.cleancap;
                                    newone.displayname = pm.cleancap;
                                }

                                newone.setlogic(pm1 as PUPPIModule);
                                //if we have a custom renderer we need to replace the box with that
                                newone.useRenderer();
                                stacks.Add(newone.myself.GetName(), newone);
                                //make sure for unique nodes we replace box
                                if (newone.nodeCustomRenderer != null && newone.nodeCustomRenderer.use3D == true)
                                {
                                    newone.replacebox(newone.boundingBox);
                                    newone.bottompyramid(newone);
                                }

                                //also make sure to add unique node
                                if (pm.unique)
                                {
                                    unique_nodes.Add(pm);
                                }
                                blockfitroots = false;
                                gotnode.getroot().fitroots(stacks);

                                try
                                {
                                    cm.Transform.Value.SetIdentity();

                                    if (hv.Children.IndexOf(cm) >= 0)
                                    {

                                        cm.UnBind();
                                        hv.Children.Remove(cm);
                                    }
                                }
                                catch { }
                                blockconnupdates = false;
                                //calls refresh on connectors
                                update_all_connectors();


                            }

                        }
                        catch (Exception exy)
                        {
                            MessageBox.Show(exy.ToString());
                        }

                    }
                    else
                    {
                        var ray = Viewport3DHelper.Point2DtoRay3D(hv.Viewport, p);
                        if (ray != null)
                        {
                            var pi = ray.PlaneIntersection(new Point3D(0, 0, PUPPIGUISettings.nodeHeight / 2), new Vector3D(0, 0, 1));
                            if (pi.HasValue)
                            {

                                var pRound = new Point3D(Math.Round(pi.Value.X), Math.Round(pi.Value.Y), PUPPIGUISettings.nodeHeight / 2);
                                Rect3D newbounds = new Rect3D(pRound.X - PUPPIGUISettings.nodeSide * 0.5, pRound.Y - PUPPIGUISettings.nodeSide * 0.5, pRound.Z - PUPPIGUISettings.nodeHeight * 0.5, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeHeight);
                                //disable updating nodes until we are done
                                blockconnupdates = true;
                                blockfitroots = true;
                                ModViz3DNode newbox = new ModViz3DNode(newbounds, this);
                                Type tm = pm.GetType();

                                if (tm == null)
                                {
                                    blockconnupdates = false;
                                    blockfitroots = false;
                                    return;
                                }

                                object pm1 = System.Activator.CreateInstance(tm);
                                //but we need to also keep the changed caption
                                if (pm.cleancap != "")
                                {
                                    (pm1 as PUPPIModule).cleancap = pm.cleancap;
                                    newbox.displayname = pm.cleancap;
                                }
                                newbox.setlogic(pm1 as PUPPIModule);
                                newbox.useRenderer();
                                stacks.Add(newbox.myself.GetName(), newbox);
                                //make sure we add unique nodes so they don't get added again
                                if (pm.unique)
                                {
                                    unique_nodes.Add(pm);
                                }
                                blockfitroots = false;
                                newbox.fitroots(stacks);
                                blockconnupdates = false;
                                update_all_connectors();
                                try
                                {
                                    cm.Transform = Transform3D.Identity;
                                    if (hv.Children.IndexOf(cm) >= 0)
                                    {
                                        cm.UnBind();
                                        hv.Children.Remove(cm);
                                    }
                                }
                                catch { }
                            }
                        }

                    }
                    update_grid();

                }
            }
            //dragging an output over an input
            //making connection
            #region connect
            else
            {
                PUPPIInParameter pinp = null;
                try
                {
                    pinp = e.Data.GetData("PUPPIInParameter") as PUPPIInParameter;

                }
                catch
                {
                }
                if (pinp != null)
                {
                    if (thiscanvasdefinitelylocked == false)
                    {
                        //revert to opaque nodes
                        if (nodesaretransparent) makenodesnottransparent();
                        if (source != null && source.Visual != null && source.Visual.GetName() != null)
                        {
                            try
                            {
                                //if it's not found in top hit, go through other hits
                                if (source.Visual.GetName().ElementAt(0) != 'I')
                                {
                                    List<Viewport3DHelper.HitResult> FOS = FindOtherSources(p);
                                    foreach (Viewport3DHelper.HitResult ff in FOS)
                                    {
                                        if (ff.Visual != null && ff.Visual.GetName() != null && ff.Visual.GetName().ElementAt(0) == 'I')
                                        {
                                            source = ff;
                                            break;
                                        }
                                    }
                                }
                                if (source.Visual.GetName().ElementAt(0) == 'I')
                                {
                                    // string sss = updatemyPCStatus("Processing...");
                                    //destination node
                                    string[] words = source.Visual.GetName().Split('_');
                                    ModViz3DNode destnode = null;
                                    try
                                    {
                                        destnode = stacks[words[2]];
                                    }
                                    catch
                                    {
                                        destnode = null;
                                    }
                                    if (destnode == null)
                                    {
                                        removeAllTracesDCLS();
                                        // sss = updatemyPCStatus(sss);
                                        return;
                                    }

                                    PUPPIModule destmod = null;
                                    try
                                    {
                                        destmod = destnode.logical_representation;
                                    }
                                    catch
                                    {
                                        destmod = null;
                                    }
                                    if (destmod == null)
                                    {
                                        removeAllTracesDCLS();
                                        //sss = updatemyPCStatus(sss);
                                        return;
                                    }
                                    //destination input index
                                    int dinputindex = -1;
                                    try
                                    {
                                        dinputindex = Convert.ToInt32(words[1]);
                                    }
                                    catch
                                    {
                                        dinputindex = -1;
                                    }
                                    if (dinputindex == -1)
                                    {
                                        removeAllTracesDCLS();
                                        return;
                                    }
                                    ModViz3DInput destinput = destnode.vizinputs[dinputindex];
                                    if (destinput == null)
                                    {
                                        removeAllTracesDCLS();
                                        //sss = updatemyPCStatus(sss);
                                        return;
                                    }
                                    //source checks
                                    if (pinp.module == null)
                                    {
                                        removeAllTracesDCLS();
                                        //   sss = updatemyPCStatus(sss);
                                        return;
                                    }
                                    ModViz3DNode sourcenode = stacks[pinp.module.GUID.ToString()];
                                    if (sourcenode.logical_representation == null)
                                    {
                                        removeAllTracesDCLS();
                                        // sss = updatemyPCStatus(sss);
                                        return;
                                    }
                                    //already filled number max outgoing connections
                                    if (sourcenode.logical_representation.maxOutgoingConnections >= 0 && sourcenode.vizoutputs[pinp.outParIndex].outboundconns.Count == sourcenode.logical_representation.maxOutgoingConnections) return;

                                    //drop in the undo, making sure it is different
                                    canvasabouttochange();

                                    bool connected = destmod.connect_input(pinp, dinputindex, true); //.inputs[dinputindex] = pinp;
                                    if (connected == false)
                                    {
                                        //undome(); 
                                        removeAllTracesDCLS();
                                        //sss = updatemyPCStatus(sss);
                                        return;

                                    }


                                    //make connector
                                    //connector name format is
                                    //sourceGUID_sourceOutPutID_destinationGUID_destinationInputID

                                    //string cnf = "conn_" + destnode.vizinputs[dinputindex].inputVisualGUID;
                                    //string cnf = "conn_" + pinp.module.GUID.ToString() + "_" + pinp.outParIndex.ToString() + "_" + newnode.nodeGUID.ToString() + "_" + ii.ToString();

                                    string cnf = "conn_" + pinp.module.GUID.ToString() + "_" + pinp.outParIndex.ToString() + "_" + destmod.GUID.ToString() + "_" + words[1];
                                    ModViz3DConn newconnenctor = new ModViz3DConn(sourcenode, pinp.outParIndex, destnode, dinputindex, cnf);



                                    if (PUPPIGUISettings.useMultiThreading)
                                        newconnenctor.drawmethread();
                                    else newconnenctor.drawme();


                                    //if this has been deleted by a disconenct then the key is still in the dictionary
                                    if (connpaths.ContainsKey(newconnenctor.visualGUID) == true)
                                    {
                                        connpaths[newconnenctor.visualGUID] = newconnenctor;
                                    }
                                    else
                                    {
                                        connpaths.Add(newconnenctor.visualGUID, newconnenctor);
                                    }
                                    destinput.myconnector = newconnenctor;
                                    destinput.myinput = pinp;

                                    destmod.userdoIprocess();

                                    stacks[words[2]].update_inouts();
                                    // sss = updatemyPCStatus(sss);


                                }
                            }

                            catch (Exception exy)
                            {
                                MessageBox.Show("error on connect " + exy.ToString());
                            }

                        }
                    }
                }
                #endregion
                //dragging over node gesture or select
                else
                {
                    //selection region
                    ModelVisual3D mf = null;

                    try
                    {
                        mf = dragSelectAreaRectangle; // e.Data.GetData("ModelVisual3D") as ModelVisual3D;

                    }
                    catch
                    {
                        mf = null;
                    }
                    if (mf != null && leftClickModeMove)
                    {
                        if (thiscanvasdefinitelylocked == false)
                        {
                            //get selection
                            if (mf.Content != null)
                            {
                                Rect3D sb = mf.Content.Bounds;
                                select_canvas_nodes_by_region(sb);

                            }
                        }
                    }
                    else
                        if (!leftClickModeMove)
                    {
                        removeAllTracesGLS();
                        ModViz3DNode snode = null;

                        try
                        {
                            snode = e.Data.GetData("ModViz3DNode") as ModViz3DNode;

                        }
                        catch
                        {
                            snode = null;
                        }
                        if (snode != null)
                        {
                            bool gestureWasPerformed = false;
                            //check if source and destination nodes are the same to make gesture

                            //make sure we hit something that should respond to clicks
                            bool somethingthere = true;

                            if (source == null)
                            {
                                somethingthere = false;
                            }
                            else
                            {
                                if (ignoreclick.Contains(source.Visual))
                                {
                                    somethingthere = false;
                                }
                            }

                            if (somethingthere == true)
                            {
                                try
                                {
                                    string svn = source.Visual.GetName();
                                    if (svn != "trialname" && svn != "grid" && svn.Contains("staticVisual") == false && svn.Contains("Conn_") == false && svn != "light" && svn != "manipulator" && svn.ElementAt(0) != 'I' && svn.ElementAt(0) != 'O')
                                    {
                                        //string sss = updatemyPCStatus("Processing user action...");
                                        ModelVisual3D vv = source.Visual as ModelVisual3D;
                                        //if dropped on caption, take their parent 
                                        if (vv.GetName().Contains("_Caption") || vv.GetName().Contains("_CustomChild"))
                                        {
                                            vv = VisualTreeHelper.GetParent(vv) as ModelVisual3D;
                                        }
                                        if (vv == null)
                                        {
                                            //    sss = updatemyPCStatus(sss);  
                                            return;
                                        }



                                        //for now only if we click on topmost

                                        Point3D topsource = new Point3D();
                                        //top point
                                        topsource = new Point3D(source.Model.Bounds.Location.X + source.Model.Bounds.SizeX * 0.5, source.Model.Bounds.Location.Y + source.Model.Bounds.SizeY * 0.5, source.Model.Bounds.Location.Z + source.Model.Bounds.SizeZ * 3 / 2);

                                        Rect3D orloc = source.Model.Bounds;
                                        string orGUID = vv.GetName();

                                        ModViz3DNode gotnode = stacks[orGUID];
                                        //check maximum number of childs
                                        if (gotnode != null)
                                        {
                                            if (gotnode == snode)
                                            {
                                                if (snode.boundingBox.SizeX > 0 && snode.boundingBox.SizeZ > 0 && snode.boundingBox.SizeZ > 0)
                                                {
                                                    double startXRatio = (snode.xGestureStart - snode.boundingBox.X) / snode.boundingBox.SizeX;
                                                    double startYRatio = (snode.yGestureStart - snode.boundingBox.Y) / snode.boundingBox.SizeY;
                                                    double startZRatio = (snode.zGestureStart - snode.boundingBox.Z) / snode.boundingBox.SizeZ;
                                                    double endXRatio = (pos.X - snode.boundingBox.X) / snode.boundingBox.SizeX;
                                                    double endYRatio = (pos.Y - snode.boundingBox.Y) / snode.boundingBox.SizeY;
                                                    double endZRatio = (pos.Z - snode.boundingBox.Z) / snode.boundingBox.SizeZ;

                                                    double xDiagRatio = Math.Sqrt(Math.Pow((endXRatio - startXRatio), 2) + Math.Pow((endYRatio - startYRatio), 2) + Math.Pow((endZRatio - startZRatio), 2));
                                                    //Vector3D gestureMove = new Vector3D(pos.X - snode.xGestureStart, pos.Y - snode.yGestureStart,pos.Z-snode.zGestureStart);
                                                    PUPPIModule ppm = snode.logical_representation;
                                                    //do double click
                                                    if (ppm != null && xDiagRatio >= PUPPIGUISettings.dragGestureRecordFraction)
                                                    {
                                                        //drop in the undo, making sure it is different
                                                        canvasabouttochange();

                                                        ppm.gestureObjectMe(startXRatio, startYRatio, startZRatio, endXRatio, endYRatio, endZRatio);

                                                        snode.update_caption();
                                                        snode.update_inouts();
                                                        gestureWasPerformed = true;
                                                    }
                                                }
                                            }
                                        }
                                        // sss = updatemyPCStatus(sss); 
                                    }
                                }
                                catch
                                {

                                }
                            }
                            if (gestureWasPerformed == false)
                            {
                                if (dragonMyNode != null && dragonMyRe != "")
                                {
                                    if (dragonMyNode.nodeCustomRenderer != null)
                                    {
                                        dragonMyNode.nodeCustomRenderer.loadCustomRendererStateFromXML(dragonMyRe);
                                        forceNodeCustomRendererUpdate(dragonMyNode.nodeGUID.ToString());
                                    }
                                }

                            }
                            dragonMystart = new Point3D(-99999, -99999, -99999);
                            dragonMyRe = "";
                            dragonMyNode = null;
                        }


                        //regular mouseup
                        else
                        {
                            PUPPICanvas_MouseUp(null, null);
                        }

                    }
                }

            }
            try
            {
                hv.DragOver -= pandrag;

                hv.MouseMove -= move_marker;
                hv.DragOver -= drag_marker;

            }
            catch
            {


            }
            try
            {
                hv.DragOver -= drag_select;
                // hv.MouseMove -= dragSelection; 
            }
            catch
            {

            }
            removeAllTracesDCLS();


            //if (dragSelectAreaRectangle != null && hv.Children.Contains(dragSelectAreaRectangle))
            //{
            //    try
            //    {
            //        hv.Children.Remove(dragSelectAreaRectangle);
            //    }
            //    catch
            //    {

            //    }
            //}
            removeDragSelector();

            hv.MouseMove += move_marker;
            hv.DragOver += drag_marker;
            // if (droppedCanvasEvent != null && sev!="") droppedCanvasEvent(sev, EventArgs.Empty);
        }

        internal void doAGestureOnANode(string nid, double startXRatio, double startYRatio, double startZRatio, double endXRatio, double endYRatio, double endZRatio)
        {
            if (stacks.ContainsKey(nid))
            {
                ModViz3DNode snode = stacks[nid];
                if (snode == null || snode.logical_representation == null) return;
                double xDiagRatio = Math.Sqrt(Math.Pow((endXRatio - startXRatio), 2) + Math.Pow((endYRatio - startYRatio), 2) + Math.Pow((endZRatio - startZRatio), 2));

                PUPPIModule ppm = snode.logical_representation;
                if (xDiagRatio >= PUPPIGUISettings.dragGestureRecordFraction)
                {
                    //drop in the undo, making sure it is different
                    canvasabouttochange();
                    try
                    {
                        ppm.gestureObjectMe(startXRatio, startYRatio, startZRatio, endXRatio, endYRatio, endZRatio);
                    }
                    catch
                    {

                    }
                    snode.update_caption();
                    snode.update_inouts();
                }
            }
        }

        internal void doADoubleClickonANode(string nid, double clickXRatio, double clickYRatio, double clickZRatio)
        {
            if (stacks.ContainsKey(nid))
            {
                ModViz3DNode myviz = stacks[nid];
                if (myviz == null || myviz.logical_representation == null) return;
                PUPPIModule pm = myviz.logical_representation;

                if (pm != null)
                {
                    canvasabouttochange();
                    try
                    {

                        pm.doubleclickme(clickXRatio, clickYRatio, clickZRatio);
                    }
                    catch
                    {

                    }

                    myviz.update_caption();
                    myviz.update_inouts();
                }
            }
        }



        void removeAllTracesDCLS()
        {
            if (PUPPIGUISettings.drawLineWhenConnecting)
            {
                if (dragConnectLineShow != null && hv.Children.Contains(dragConnectLineShow))
                {
                    try
                    {
                        hv.Children.Remove(dragConnectLineShow);
                        //dragSelectAreaRectangle = null; 
                    }
                    catch
                    {

                    }
                }
                if (dragConnectLineShow != null && ignoreclick.Contains(dragConnectLineShow))
                {
                    try
                    {
                        ignoreclick.Remove(dragConnectLineShow);
                    }
                    catch
                    {

                    }
                }
                //if (dragConnectLineShow != null)
                //{
                try
                {
                    hv.DragOver -= drawMyLineOrigin;

                    //dragSelectAreaRectangle = null; 
                }
                catch
                {

                }
                //}
                if (dragConnectLineShow != null)
                {
                    try
                    {
                        // hv.DragLeave -= connLineDragLeave;

                        //dragSelectAreaRectangle = null; 
                    }
                    catch
                    {

                    }
                }
                dragConnectLineShow = null;
            }
        }

        //delete the arrow shown when moving node
        void removeAllTracesNMAS()
        {

            if (nodeMoveArrowShow != null && hv.Children.Contains(nodeMoveArrowShow))
            {
                try
                {
                    hv.Children.Remove(nodeMoveArrowShow);
                    //dragSelectAreaRectangle = null; 
                }
                catch
                {

                }
            }
            if (nodeMoveArrowShow != null && ignoreclick.Contains(nodeMoveArrowShow))
            {
                try
                {
                    ignoreclick.Remove(nodeMoveArrowShow);
                }
                catch
                {

                }
            }
            //if (dragConnectLineShow != null)
            //{
            try
            {
                hv.DragOver -= drawMyArrowOrigin;

                //dragSelectAreaRectangle = null; 
            }
            catch
            {

            }
            //}
            if (nodeMoveArrowShow != null)
            {
                try
                {
                    // hv.DragLeave -= connLineDragLeave;

                    //dragSelectAreaRectangle = null; 
                }
                catch
                {

                }
            }
            nodeMoveArrowShow = null;

        }

        void removeAllTracesGLS()
        {
            if (PUPPIGUISettings.drawGestureLine)
            {
                if (gestureLineShow != null && hv.Children.Contains(gestureLineShow))
                {
                    try
                    {
                        hv.Children.Remove(gestureLineShow);
                        //dragSelectAreaRectangle = null; 
                    }
                    catch
                    {

                    }
                }
                if (gestureLineShow != null && ignoreclick.Contains(gestureLineShow))
                {
                    try
                    {
                        ignoreclick.Remove(gestureLineShow);
                    }
                    catch
                    {

                    }
                }
                //if (gestureLineShow != null)
                //{
                try
                {
                    hv.DragOver -= drawMyGestureLineOverNode;

                    //dragSelectAreaRectangle = null; 
                }
                catch
                {

                }


                //}
                if (gestureLineShow != null)
                {
                    try
                    {
                        // hv.DragLeave -= connLineDragLeave;

                        //dragSelectAreaRectangle = null; 
                    }
                    catch
                    {

                    }
                }
                gestureLineShow = null;
            }
            try
            {
                hv.DragOver -= updatedMyNodeWhileDraggingOver;
            }
            catch
            {

            }
        }


        void removeAllTracesDMR()
        {
            if (PUPPIGUISettings.drawModuleDragToCanvas)
            {
                if (moduleDragMarker != null && hv.Children.Contains(moduleDragMarker))
                {
                    try
                    {
                        hv.Children.Remove(moduleDragMarker);
                        //dragSelectAreaRectangle = null; 
                    }
                    catch
                    {

                    }
                }
                if (moduleDragMarker != null && ignoreclick.Contains(moduleDragMarker))
                {
                    try
                    {
                        ignoreclick.Remove(moduleDragMarker);
                    }
                    catch
                    {

                    }
                }
                //if (gestureLineShow != null)
                //{
                try
                {
                    hv.DragOver -= drawMyModuleRepresentation;

                    //dragSelectAreaRectangle = null; 
                }
                catch
                {

                }
                //}
                if (moduleDragMarker != null)
                {
                    try
                    {
                        // hv.DragLeave -= connLineDragLeave;

                        //dragSelectAreaRectangle = null; 
                    }
                    catch
                    {

                    }
                }
                moduleDragMarker = null;
            }
        }

        //connects nodes programmatically
        internal bool connectNode2Node(int sourceGUID, int outPindex, int destGUID, int inPindex, bool savestate = true)
        {
            ModViz3DNode sn;

            if (stacks.ContainsKey(sourceGUID.ToString()))
                sn = stacks[sourceGUID.ToString()];
            else return false;
            if (sn.logical_representation == null) return false;

            ModViz3DNode dn;
            if (stacks.ContainsKey(destGUID.ToString()))
                dn = stacks[destGUID.ToString()];
            else return false;
            if (dn.logical_representation == null) return false;

            if (outPindex < 0 || outPindex >= sn.vizoutputs.Count) return false;
            if (inPindex < 0 || inPindex >= dn.vizinputs.Count) return false;


            //already filled number max outgoing connections
            if (sn.logical_representation.maxOutgoingConnections >= 0 && sn.vizoutputs[outPindex].outboundconns.Count == sn.logical_representation.maxOutgoingConnections) return false;

            //drop in the undo, making sure it is different
            if (savestate)
                canvasabouttochange();
            //create an input parameter and hook it up to the destination node
            PUPPIInParameter pinp = new PUPPIInParameter();
            pinp.getinputfrom(sn.logical_representation, outPindex);


            bool connected = dn.logical_representation.connect_input(pinp, inPindex, false);
            if (connected == false) return false;

            ModViz3DInput destinput = dn.vizinputs[inPindex];
            //make connector
            //connector name format is
            //sourceGUID_sourceOutPutID_destinationGUID_destinationInputID

            string cnf = "conn_" + pinp.module.GUID.ToString() + "_" + pinp.outParIndex.ToString() + "_" + dn.logical_representation.GUID.ToString() + "_" + inPindex.ToString();
            ModViz3DConn newconnenctor = new ModViz3DConn(sn, pinp.outParIndex, dn, inPindex, cnf);


            if (PUPPIGUISettings.useMultiThreading)
                newconnenctor.drawmethread();
            else newconnenctor.drawme();
            //if this has been deleted by a disconenct then the key is still in the dictionary
            if (connpaths.ContainsKey(newconnenctor.visualGUID) == true)
            {
                connpaths[newconnenctor.visualGUID] = newconnenctor;
            }
            else
            {
                connpaths.Add(newconnenctor.visualGUID, newconnenctor);
            }
            destinput.myconnector = newconnenctor;
            destinput.myinput = pinp;

            dn.logical_representation.doIprocess();
            dn.update_inouts();

            return true;
        }

        //connects nodes programmatically
        internal bool disconnectANodesInput(int destGUID, int inPindex, bool savestate = true)
        {


            ModViz3DNode dn;
            if (stacks.ContainsKey(destGUID.ToString()))
                dn = stacks[destGUID.ToString()];
            else return false;
            if (dn.logical_representation == null) return false;

            if (inPindex < 0 || inPindex >= dn.vizinputs.Count) return false;



            //drop in the undo, making sure it is different
            if (savestate)
                canvasabouttochange();

            dn.disconnectinput(inPindex);


            return true;
        }


        //resets the conenction matrices to redo full connection redraw
        internal void initconn_matrices()
        {
            //initializations
            d2collisionmodel.canvaslevelmap = d2collisionmodel.make_levelmap(this);
            d2collisionmodel.canvaslevelmap.getconoccupancymatrix(out connectorpath.nodeconnoccup, PUPPIGUISettings.nodeSpacing);
            //init connection matrices to clear
            connectorpath.initialize_cmatrix(connectorpath.nodeconnoccup, out connectorpath.hconncount);
            connectorpath.initialize_cmatrix(connectorpath.nodeconnoccup, out connectorpath.hconnmaze);
            connectorpath.initialize_cmatrix(connectorpath.nodeconnoccup, out connectorpath.vconncount);
            connectorpath.initialize_cmatrix(connectorpath.nodeconnoccup, out connectorpath.vconnmaze);
            //changed connections
            connectorpath.initialize_cmatrix(connectorpath.nodeconnoccup, out connectorpath.HconnsWereDrawnHere);
            connectorpath.initialize_cmatrix(connectorpath.nodeconnoccup, out connectorpath.VconnsWereDrawnHere);
            //and finally close off areas with too many connections
            d2collisionmodel.updatewithconns(connectorpath.nodeconnoccup, connectorpath.hconncount, out connectorpath.hconnmaze);
            d2collisionmodel.updatewithconns(connectorpath.nodeconnoccup, connectorpath.vconncount, out connectorpath.vconnmaze);
            connectorpath.noConnDrawnYet = true;
        }
        //updates all connectors because they are not updated with events when the stack changes
        //this is more lightweight than regenerate connections since they are only moved rather than reconnected
        private void update_all_connectors()
        {

            if (blockconnupdates) return;
            //  stopMouseEv(); 
            //test
            // Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
            //reset number of connections redrawn
            PUPPIDEBUG.PUPPIDebugger.conns_Redrawn = 0;
            if (PUPPIDebugger.debugenabled)
            {
                PUPPIDebugger.log(utils.StringConstants.beginupdateconnectionsdebuglog);
            }
            initconn_matrices();
            ////test
            //foreach (ModViz3DConn mvcc in connpaths.Values)
            //{
            //    //conn values can recycle guids so it can have null values
            //    if (mvcc != null)
            //    {
            //        if (mvcc.myself!=null )
            //        {
            //            if (hv.Children.Contains(mvcc.myself )  )
            //            {
            //                hv.Children.Remove(mvcc.myself);
            //                mvcc.myself = null; 
            //            }
            //        }
            //    }
            //}
            //test
            //Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
            foreach (ModViz3DConn mvcc in connpaths.Values)
            {
                //conn values can recycle guids so it can have null values
                if (mvcc != null)
                {
                    if (PUPPIGUISettings.useMultiThreading)
                        mvcc.drawmethread();
                    else mvcc.drawme();
                }
                //Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
            }
            if (PUPPIDebugger.debugenabled)
            {
                PUPPIDebugger.log(utils.StringConstants.endupdateconnectionsdebuglog);
                PUPPIDebugger.log(PUPPIDebugger.conns_Redrawn.ToString() + utils.StringConstants.connectionsredrawndebuglog);
            }
            //   resumeMouseEv(); 
        }

        //menu for changing rotation mode
        private void rotationmode_Click(object sender, RoutedEventArgs e)
        {


            if (rightclickmode.MouseAction == MouseAction.RightClick)
            {
                rightclickmode.MouseAction = MouseAction.None;
                rotationmode.Content = "Rght Clck Edit Mode";
            }
            else
            {
                rightclickmode.MouseAction = MouseAction.RightClick;
                rotationmode.Content = "Rght Clck Rot. Mode";

            }
            hv.RotateGesture = rightclickmode;


        }




        private void resetcam_Click(object sender, RoutedEventArgs e)
        {
            camera_reset();
        }

        //so we don't do crazy stuff
        internal static bool mouseisdown = false;
        private void PUPPICanvas_MouseDown(object sender, MouseButtonEventArgs e)
        {
            mouseisdown = true;
            if (e.ChangedButton == MouseButton.Middle) return;
            string sev = "";
            removeAllTracesDCLS();
            removeAllTracesGLS();
            removeAllTracesNMAS();
            //     removeAllTracesDMR();
            //try
            //{
            //    hv.MouseMove -= move_marker;
            //    hv.Children.Remove(mousemarker); 
            //}
            //catch
            //{

            //}

            issaved = false;
            try
            {
                if (usingmanip == false)
                {
                    var p = e.GetPosition(hv);

                    Vector3D n;
                    Point3D pos;
                    var source = FindSource(p, out n, out pos);
                    if (PUPPIGUISettings.tabletMode)
                    {
                        source = FindSourceTablet(p, out n, out pos);
                    }

                    #region leftclick
                    if ((e.ChangedButton == MouseButton.Left && !PUPPIGUISettings.tabletMode) || (PUPPIGUISettings.tabletMode && !tabletForceRight))
                    {
                        //make sure we hit something that should respond to clicks
                        bool somethingthere = true;

                        if (source == null || source.Visual == null)
                        {
                            somethingthere = false;
                        }
                        else
                        {
                            if (ignoreclick.Contains(source.Visual))
                            {
                                somethingthere = false;
                            }
                        }

                        if (somethingthere == true)
                        {
                            string svn = source.Visual.GetName();
                            sev = svn;
                            #region nodeclick
                            if (svn != null && svn != "trialname" && svn != "grid" && svn.Contains("staticVisual") == false && svn.Contains("Conn_") == false && svn != "light" && svn != "manipulator" && svn.ElementAt(0) != 'I' && svn.ElementAt(0) != 'O')
                            {

                                ModelVisual3D vv = source.Visual as ModelVisual3D;
                                //if dropped on caption, take their parent 
                                //also if dropped on child of custm renderer visual
                                if (vv.GetName().Contains("_Caption") || vv.GetName().Contains("_CustomChild"))
                                {
                                    vv = VisualTreeHelper.GetParent(vv) as ModelVisual3D;
                                }

                                if (vv == null) { return; }
                                //deselect
                                ModViz3DNode myviz = null;
                                //make sure we don't look at selection rectangle

                                if (vv.GetName() != "CSAR_PUPPICANVAS")
                                    try
                                    {
                                        myviz = stacks[vv.GetName()];
                                        if (myviz != null)
                                        {
                                            //if not in selection we clear selection otherwise we move everything
                                            if (!selstacks.Contains(myviz.nodeGUID.ToString()))
                                            {
                                                deselectallnodes();
                                            }

                                        }
                                    }
                                    catch
                                    {
                                        myviz = null;
                                    }



                                //manipulator
                                if (e.ClickCount == 1 && myviz != null)
                                {

                                    if (leftClickModeMove && thiscanvasdefinitelylocked == false)
                                    {

                                        updatemyPCStatusNW("Drag manipulator or node to move node or selection.", Brushes.DarkViolet);
                                        hv.MouseMove += dragnode2move;
                                        removemanipulator();
                                        hv.Children.Add(cm);




                                        //cm.Transform = new ScaleTransform3D(new Vector3D(vv.Content.Bounds.SizeX *0.5, vv.Content.Bounds.SizeY *0.5, 1), cm.Position);
                                        //cm.Offset = new Vector3D(vv.Content.Bounds.SizeX * 0.5, vv.Content.Bounds.SizeY * 0.5, 0);
                                        if (myviz.nodeCustomRenderer == null || myviz.nodeCustomRenderer.displacedBbox.SizeX == 0)
                                        {
                                            cm.Position = myviz.boundingBox.rectcenter();
                                            cm.Offset = new Vector3D(myviz.boundingBox.SizeX * 0.5, myviz.boundingBox.SizeY * 0.5, 0);
                                        }
                                        else
                                        {
                                            cm.Position = myviz.nodeCustomRenderer.displacedBbox.rectcenter();
                                            cm.Offset = new Vector3D(myviz.nodeCustomRenderer.displacedBbox.SizeX * 0.5, myviz.nodeCustomRenderer.displacedBbox.SizeY * 0.5, 0);
                                        }
                                        double st = Math.Max(1, hv.Camera.Position.DistanceTo(cm.Position) * 0.02);


                                        cm.Diameter = cm.initialD * st;
                                        cm.Length = cm.initialL * st;



                                        if (selstacks.Count == 0)
                                            cm.Bind(vv);
                                        else
                                        {
                                            //put the whole selection
                                            //ModelVisual3D m=new ModelVisual3D();

                                            //cm.Bind(m);
                                            if (dragSelectAreaRectangle != null)
                                            {

                                                hv.Children.Add(dragSelectAreaRectangle);
                                                //ignoreclick.Add(dragSelectAreaRectangle);
                                                cm.Bind(dragSelectAreaRectangle);
                                            }
                                            else
                                            {
                                                foreach (string s in selstacks)
                                                {
                                                    ModViz3DNode mv = null;
                                                    if (stacks.TryGetValue(s, out mv))
                                                    {
                                                        if (mv != null && mv.myself != null)
                                                        {
                                                            cm.Bind(mv.myself);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }

                                        }
                                        // usingmanip = true;
                                        //record custom gesture
                                        //if (!usingmanip )
                                        //   hv.DragOver += drawMyArrowOrigin;
                                    }
                                    else if (!leftClickModeMove)
                                    {
                                        string gestdesc = "";
                                        if (myviz != null && myviz.logical_representation != null)
                                        {
                                            gestdesc = myviz.logical_representation.gestureDescription;
                                        }
                                        //if gesture overriden 
                                        // if (myviz.logical_representation.GetType().GetMethod("gestureMe_userCode").DeclaringType == myviz.logical_representation.GetType())
                                        updatemyPCStatusNW("Drag over node to perform gesture " + gestdesc, Brushes.DarkViolet);
                                        //if drag over node overriden we do this

                                        hv.MouseMove += dragOverNodeGesture;
                                    }

                                }
                                else if (vv == dragSelectAreaRectangle && e.ClickCount == 1 && leftClickModeMove && thiscanvasdefinitelylocked == false && selstacks.Count > 0)
                                {
                                    updatemyPCStatusNW("Drag manipulator or rectangle to move selection.", Brushes.DarkViolet);
                                    hv.MouseMove += dragnode2move;
                                    removemanipulator();
                                    hv.Children.Add(cm);
                                    Rect3D dragsr = dragSelectAreaRectangle.Content.Bounds;
                                    if (dragsr.IsEmpty) return;

                                    cm.Position = dragsr.rectcenter();
                                    cm.Offset = new Vector3D(dragsr.SizeX * 0.5, dragsr.SizeY * 0.5, 0);
                                    double st = Math.Max(1, hv.Camera.Position.DistanceTo(cm.Position) * 0.02);


                                    cm.Diameter = cm.initialD * st;
                                    cm.Length = cm.initialL * st;



                                    if (selstacks.Count == 0)
                                        return;



                                    //  hv.Children.Add(dragSelectAreaRectangle);
                                    //ignoreclick.Add(dragSelectAreaRectangle);
                                    cm.Bind(dragSelectAreaRectangle);


                                }
                                else if (e.ClickCount == 2)
                                {
                                    // string sss = updatemyPCStatus("Processing user action...");
                                    try
                                    {



                                        if (myviz != null)
                                        {
                                            PUPPIModule pm = myviz.logical_representation;
                                            //do double click
                                            if (pm != null)
                                            {
                                                double clickXRatio = (pos.X - myviz.boundingBox.X) / myviz.boundingBox.SizeX;
                                                double clickYRatio = (pos.Y - myviz.boundingBox.Y) / myviz.boundingBox.SizeY;
                                                double clickZRatio = (pos.Z - myviz.boundingBox.Z) / myviz.boundingBox.SizeZ;


                                                pm.doubleclickme(clickXRatio, clickYRatio, clickZRatio);


                                                myviz.update_caption();
                                                myviz.update_inouts();
                                            }

                                        }
                                    }
                                    catch (Exception exy)
                                    {
                                        MessageBox.Show("Failed on doubleclikc " + exy.ToString());
                                    }
                                    // sss = updatemyPCStatus(sss);

                                }
                            }
                            #endregion
                            else if (source.Visual.GetType() == typeof(HelixToolkit.Wpf.TranslateManipulator) && thiscanvasdefinitelylocked == false)
                            {
                                //for dragging when we move marker

                                hv.MouseMove += letMyMouseGo;
                                usingmanip = true;


                            }
                            #region ioclick
                            else if ((source.Visual.GetName().ElementAt(0) == 'O' || source.Visual.GetName().ElementAt(0) == 'I') && thiscanvasdefinitelylocked == false)
                            {

                                removeAllTracesDMR();
                                updatemyPCStatusNW("Drag from outputs or connected inputs to unconnected inputs to connect nodes.", Brushes.DarkViolet);
                                //removeAllTracesDMR(); 
                                //double click connection
                                if (PUPPIGUISettings.doubleClickIOConnect && e.ClickCount == 2)
                                {
                                    //load node to connect
                                    if (source.Visual.GetName().ElementAt(0) == 'O')
                                    {
                                        doubleClickedOutput = source.Visual.GetName();
                                    }
                                    else if (source.Visual.GetName().ElementAt(0) == 'I')
                                    {
                                        if (doubleClickedOutput != "")
                                        {
                                            string testname = source.Visual.GetName();
                                            string[] words = testname.Split('_');
                                            ModViz3DNode destnode = null;
                                            try
                                            {
                                                destnode = stacks[words[2]];
                                            }
                                            catch
                                            {
                                                destnode = null;
                                            }
                                            if (destnode == null) return;
                                            int dNG = Convert.ToInt32(words[2]);
                                            PUPPIModule destmod = null;
                                            try
                                            {
                                                destmod = destnode.logical_representation;
                                            }
                                            catch
                                            {
                                                destmod = null;
                                            }
                                            if (destmod == null) return;
                                            //destination input index
                                            int dinputindex = -1;
                                            try
                                            {
                                                dinputindex = Convert.ToInt32(words[1]);
                                            }
                                            catch
                                            {
                                                dinputindex = -1;
                                            }
                                            if (dinputindex == -1) return;
                                            testname = doubleClickedOutput;
                                            words = testname.Split('_');
                                            ModViz3DNode sourcenode = null;
                                            try
                                            {
                                                sourcenode = stacks[words[2]];
                                            }
                                            catch
                                            {
                                                sourcenode = null;
                                            }
                                            if (sourcenode == null) return;
                                            int sNG = Convert.ToInt32(words[2]);
                                            PUPPIModule sourcemod = null;
                                            try
                                            {
                                                sourcemod = sourcenode.logical_representation;
                                            }
                                            catch
                                            {
                                                sourcemod = null;
                                            }
                                            if (sourcemod == null) return;
                                            //source output index
                                            int soutputindex = -1;
                                            try
                                            {
                                                soutputindex = Convert.ToInt32(words[1]);
                                            }
                                            catch
                                            {
                                                soutputindex = -1;
                                            }
                                            if (soutputindex == -1) return;
                                            bool cs = connectNode2Node(sNG, soutputindex, dNG, dinputindex);
                                            if (cs == false) MessageBox.Show("Failed to connect. Check for circular logic.");
                                        }
                                    }
                                }

                                else if (usingmanip == false && cm.Transform == Transform3D.Identity)
                                {
                                    // removeAllTracesDMR();

                                    if (PUPPIGUISettings.drawLineWhenConnecting)
                                    {

                                        if (hv.Children.Contains(dragConnectLineShow))
                                        {
                                            try
                                            {
                                                hv.Children.Remove(dragConnectLineShow);
                                            }
                                            catch
                                            {

                                            }

                                        }
                                        if (ignoreclick.Contains(dragConnectLineShow))
                                        {
                                            try
                                            {
                                                ignoreclick.Remove(dragConnectLineShow);
                                            }
                                            catch
                                            {

                                            }
                                        }
                                        dclsStart = new Point3D(-99999, -99999, -99999);
                                        //Point pp = p;
                                        //debugdraw(pp); 
                                        //drag output or input 
                                        hv.MouseMove += dragoutputitem;

                                        //hv.DragLeave += connLineDragLeave;
                                    }
                                }
                            }
                            #endregion
                            else
                            {
                                //try
                                //{
                                //    cm.Transform.Value.SetIdentity();

                                //    if (hv.Children.IndexOf(cm) >= 0)
                                //    {

                                //        cm.UnBind();
                                //        hv.Children.Remove(cm);
                                //    }


                                //}
                                //catch
                                //{
                                //}
                            }



                        }
                        else
                        {


                            if (e.ClickCount == 1)
                            {
                                if (source != null && source.Visual != null)
                                {

                                    if (source.Visual.GetName() == "manipulator")
                                    {
                                        try
                                        {
                                            if (cm != null)
                                            {
                                                cm.Transform.Value.SetIdentity();
                                                if (hv.Children.Contains(cm))
                                                {

                                                    cm.UnBind();
                                                    hv.Children.Remove(cm);
                                                }
                                            }


                                        }
                                        catch
                                        {
                                        }
                                    }
                                    else
                                    {
                                        //updatemyPCStatusNW("Drag modules onto the canvas to create nodes",Brushes.Violet );


                                    }
                                }
                                else
                                {
                                    //updatemyPCStatusNW("Drag modules onto the canvas to create nodes",Brushes.Violet );
                                }
                                //hv.MouseMove += dragSelection;
                                if (!usingmanip)
                                {

                                    try
                                    {
                                        hv.Children.Remove(mousemarker);

                                    }
                                    catch
                                    {

                                    }
                                    try
                                    {

                                        hv.MouseMove -= move_marker;
                                        hv.DragOver -= drag_marker;
                                    }
                                    catch
                                    {

                                    }



                                    if (e.LeftButton == MouseButtonState.Pressed && leftClickModeMove)
                                    {
                                        var ray = new Ray3D();

                                        ray = null;
                                        ray = Viewport3DHelper.Point2DtoRay3D(hv.Viewport, p);


                                        if (ray != null)
                                        {


                                            var pi = ray.PlaneIntersection(new Point3D(0, 0, PUPPIGUISettings.textRaise), new Vector3D(0, 0, 1));
                                            if (pi.HasValue)
                                            {

                                                myPCselStart = new Point3D(pi.Value.X, pi.Value.Y, 0);
                                                removemanipulator();

                                                hv.DragOver += drag_select;
                                                hv.DragOver += pandrag;
                                                DataObject dragData = new DataObject("ModelVisual3D", dragSelectAreaRectangle);
                                                DragDrop.DoDragDrop(hv, dragData, DragDropEffects.Move);
                                            }
                                        }
                                    }



                                }
                                try
                                {
                                    hv.MouseMove -= move_marker;
                                    hv.DragOver -= drag_marker;
                                }
                                catch
                                {

                                }
                                hv.MouseMove += move_marker;
                                hv.DragOver += drag_marker;

                            }

                            //if (e.ClickCount == 1)
                            // {
                            //if (source != null && source.Visual != null)
                            // {
                            //remove manipulator
                            //if (source.Visual.GetName() == "manipulator")
                            //{
                            //try
                            //{
                            //    if (cm!=null)
                            //    {
                            //        cm.Transform.Value.SetIdentity();
                            //        if (hv.Children.Contains(cm)  )

                            //        {

                            //            cm.UnBind();
                            //            hv.Children.Remove(cm);
                            //        }
                            //    }


                            //}
                            //catch
                            //{
                            //}
                            //}
                            // }
                            // else
                            // {


                            //     removemanipulator();

                            //}
                        }


                    }
                    #endregion
                    #region rightclick
                    else if (((e.ChangedButton == MouseButton.Right && !PUPPIGUISettings.tabletMode) || (PUPPIGUISettings.tabletMode && tabletForceRight)) && rightclickmode.MouseAction == MouseAction.None)
                    {

                        if (thiscanvasdefinitelylocked) return;
                        //make sure we hit something that should respond to clicks
                        bool somethingthere = true;

                        if (source == null || source.Visual == null)
                        {
                            somethingthere = false;
                        }
                        else
                        {
                            if (ignoreclick.Contains(source.Visual))
                            {
                                somethingthere = false;
                            }
                        }

                        if (somethingthere == true)
                        {
                            string svn = source.Visual.GetName();
                            sev = svn;
                            if (svn != "trialname" && svn != "grid" && svn.Contains("staticVisual") == false && svn.Contains("Conn_") == false && svn != "light" && svn != "manipulator" && svn.ElementAt(0) != 'I' && svn.ElementAt(0) != 'O')
                            {

                                ModelVisual3D vv = source.Visual as ModelVisual3D;
                                //if dropped on caption, take their parent 
                                if (vv.GetName().Contains("_Caption") || vv.GetName().Contains("_CustomChild"))
                                {
                                    vv = VisualTreeHelper.GetParent(vv) as ModelVisual3D;
                                }
                                if (vv == null) { return; }

                                try
                                {
                                    ModViz3DNode myviz = stacks[vv.GetName()];
                                    if (myviz != null)
                                    {
                                        //cannot let user set list level if we override prcoess.
                                        noderightclickmenu.nodeaffected = myviz;
                                        //if we can paste on top
                                        if (noderightclickmenu.Items.Contains(noderightclickmenu.toPaste))
                                        {
                                            if (!myviz.acceptschilds() || myviz.mycanvas.clipboardXMLRepresentation == "") noderightclickmenu.toPaste.IsEnabled = false; else noderightclickmenu.toPaste.IsEnabled = true;
                                        }
                                        PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer pnc = null;
                                        try
                                        {
                                            pnc = myviz.logical_representation as PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer;
                                        }
                                        catch
                                        {
                                            pnc = null;
                                        }
                                        if (pnc != null)
                                        {
                                            noderightclickmenu.explodeContainerMenuItem.IsEnabled = true;
                                        }
                                        else
                                        {
                                            noderightclickmenu.explodeContainerMenuItem.IsEnabled = false;
                                        }
                                        //if not selected we can select it
                                        if (!myviz.mycanvas.selstacks.Contains(myviz.nodeGUID.ToString()))
                                        {
                                            noderightclickmenu.addselnodestack.IsEnabled = true;
                                            noderightclickmenu.removeselnodestack.IsEnabled = false;
                                        }
                                        else
                                        {
                                            noderightclickmenu.addselnodestack.IsEnabled = false;
                                            noderightclickmenu.removeselnodestack.IsEnabled = true;
                                        }
                                        if (myviz.logical_representation.completeProcessOverride == true)
                                        { noderightclickmenu.setlistlevel.IsEnabled = false; }
                                        else
                                        {
                                            noderightclickmenu.setlistlevel.IsEnabled = true;

                                            if (myviz.list_level == 0)
                                            {
                                                noderightclickmenu.setlistlevel.Header = "Item/List Mode (=1 Item)";
                                            }
                                            else
                                            {
                                                noderightclickmenu.setlistlevel.Header = "Item/List Mode (=List)";
                                            }
                                        }

                                        if (myviz.hiddenOnLockedCanvas)
                                        {
                                            noderightclickmenu.hmnolc.IsEnabled = false;
                                            noderightclickmenu.smnolc.IsEnabled = true;
                                        }
                                        else
                                        {
                                            noderightclickmenu.hmnolc.IsEnabled = true;
                                            noderightclickmenu.smnolc.IsEnabled = false;
                                        }

                                        if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.ThreeDimensional)
                                        {
                                            if (myviz.parent == null)
                                            {
                                                noderightclickmenu.splitmystackatnode.IsEnabled = false;
                                            }
                                            else
                                            {
                                                noderightclickmenu.splitmystackatnode.IsEnabled = true;
                                            }
                                        }
                                        noderightclickmenu.IsOpen = true;

                                    }
                                }
                                catch (Exception exy)
                                {

                                }

                            }
                            //menu for input
                            else if (source.Visual.GetName().ElementAt(0) == 'I')
                            {
                                //destination node
                                string[] words = source.Visual.GetName().Split('_');
                                ModViz3DNode destnode = null;
                                try
                                {
                                    destnode = stacks[words[2]];
                                }
                                catch
                                {
                                    destnode = null;
                                }
                                if (destnode == null) return;

                                PUPPIModule destmod = null;
                                try
                                {
                                    destmod = destnode.logical_representation;
                                }
                                catch
                                {
                                    destmod = null;
                                }
                                if (destmod == null) return;
                                //destination input index
                                int dinputindex = -1;
                                try
                                {
                                    dinputindex = Convert.ToInt32(words[1]);
                                }
                                catch
                                {
                                    dinputindex = -1;
                                }
                                if (dinputindex == -1) return;
                                inputrightclickmenu.nodeaffected = destnode;
                                inputrightclickmenu.inputaffected = dinputindex;
                                if (destmod.inputs[dinputindex].module == null)
                                {
                                    inputrightclickmenu.discItem.IsEnabled = false;
                                    inputrightclickmenu.goToSource.IsEnabled = false;
                                    inputrightclickmenu.setItem.IsEnabled = true;
                                    inputrightclickmenu.setItemTree.IsEnabled = true;
                                    inputrightclickmenu.setFromModule.IsEnabled = true;
                                    inputrightclickmenu.suggestModule.IsEnabled = true;

                                }
                                else
                                {
                                    inputrightclickmenu.discItem.IsEnabled = true;
                                    inputrightclickmenu.goToSource.IsEnabled = true;
                                    inputrightclickmenu.setItem.IsEnabled = false;
                                    inputrightclickmenu.setItemTree.IsEnabled = false;
                                    inputrightclickmenu.setFromModule.IsEnabled = false;
                                    inputrightclickmenu.suggestModule.IsEnabled = false;

                                }
                                if (destmod.completeProcessOverride) inputrightclickmenu.autoListMode.IsEnabled = false; else inputrightclickmenu.autoListMode.IsEnabled = true;
                                if (destmod.inputs[dinputindex].inputAutomaticListMode) inputrightclickmenu.autoListMode.Header = "Auto-List Enabled"; else inputrightclickmenu.autoListMode.Header = "Auto-List Disabled";
                                string modval = "null";
                                try
                                {
                                    modval = destnode.logical_representation.inputs[dinputindex].module.outputs[destnode.logical_representation.inputs[dinputindex].outParIndex].ToString();
                                }
                                catch
                                {
                                    modval = "null";
                                }
                                //  inputrightclickmenu.Items[0] = new System.Windows.Forms.ToolStripLabel("Input: " + destnode.logical_representation.inputnames[dinputindex] + " " + modval );
                                inputrightclickmenu.t.Header = "Input " + destnode.logical_representation.inputnames[dinputindex].Substring(0, Math.Min(20, destnode.logical_representation.inputnames[dinputindex].Length));
                                inputrightclickmenu.t.ToolTip = "Input: " + destnode.logical_representation.inputnames[dinputindex];

                                inputrightclickmenu.v.Header = "Value " + modval.Substring(0, Math.Min(20, modval.Length));
                                inputrightclickmenu.v.ToolTip = "Value: " + modval;


                                inputrightclickmenu.IsOpen = true;
                            }
                            //output options
                            else if (source.Visual.GetName().ElementAt(0) == 'O')
                            {
                                //destination node (node we are on)
                                string[] words = source.Visual.GetName().Split('_');
                                ModViz3DNode destnode = null;
                                try
                                {
                                    destnode = stacks[words[2]];
                                }
                                catch
                                {
                                    destnode = null;
                                }
                                if (destnode == null) return;

                                PUPPIModule destmod = null;
                                try
                                {
                                    destmod = destnode.logical_representation;
                                }
                                catch
                                {
                                    destmod = null;
                                }
                                if (destmod == null) return;
                                //output index
                                int outindex = -1;
                                try
                                {
                                    outindex = Convert.ToInt32(words[1]);
                                }
                                catch
                                {
                                    outindex = -1;
                                }
                                if (outindex == -1) return;


                                outputrightclickmenu.nodeaffected = destnode;
                                outputrightclickmenu.outputaffected = outindex;
                                string modval = "null";
                                try
                                {
                                    modval = destnode.logical_representation.outputs[outindex].ToString();
                                }
                                catch
                                {
                                    modval = "null";
                                }
                                //  inputrightclickmenu.Items[0] = new System.Windows.Forms.ToolStripLabel("Input: " + destnode.logical_representation.inputnames[dinputindex] + " " + modval );
                                //outputrightclickmenu.t.Header = "Output " + destnode.logical_representation.outputnames[outindex].Substring(0, Math.Min(10, destnode.logical_representation.outputnames[outindex].Length)) + "," + modval.Substring(0, Math.Min(10, modval.Length));
                                //outputrightclickmenu.t.ToolTip = "Output: " + destnode.logical_representation.outputnames[outindex] + " , Value: " + modval;

                                outputrightclickmenu.t.Header = "Output " + destnode.logical_representation.outputnames[outindex].Substring(0, Math.Min(20, destnode.logical_representation.outputnames[outindex].Length));
                                outputrightclickmenu.t.ToolTip = "Output: " + destnode.logical_representation.outputnames[outindex];

                                outputrightclickmenu.v.Header = "Value " + modval.Substring(0, Math.Min(20, modval.Length));
                                outputrightclickmenu.v.ToolTip = "Value: " + modval;

                                if (destnode.logical_representation.listprocess == true || destnode.logical_representation.outputs[outindex] == null)
                                {
                                    outputrightclickmenu.mycanvasoutputobjectproperties.IsEnabled = false;
                                }
                                else
                                {
                                    outputrightclickmenu.mycanvasoutputobjectproperties.IsEnabled = true;
                                }

                                outputrightclickmenu.IsOpen = true;

                            }
                        }
                        //right click on blank space
                        else
                        {
                            var ray = Viewport3DHelper.Point2DtoRay3D(hv.Viewport, p);
                            if (ray != null)
                            {
                                var pi = ray.PlaneIntersection(new Point3D(0, 0, PUPPIGUISettings.nodeHeight / 2), new Vector3D(0, 0, 1));
                                if (pi.HasValue)
                                {

                                    canvasrightclickmenu.mycanvas = this;
                                    canvasrightclickmenu.position = new Point3D(pi.Value.X, pi.Value.Y, 0);
                                    canvasrightclickmenu.IsOpen = true;
                                }
                            }
                        }
                    }
                    #endregion

                }

            }
            catch (Exception exy) { }

            if (sev != null && sev != "")
            {
                if (e.ChangedButton == MouseButton.Right)
                {
                    sev = "RB_" + sev;
                }
                else
                {
                    sev = "LB_" + sev;
                }
            }
            if (clickedCanvasEvent != null && sev != null && sev != "") clickedCanvasEvent(sev, EventArgs.Empty);
        }

        void connLineDragLeave(object sender, DragEventArgs e)
        {
            //since this fires even when not leaving, gotta check coordinates
            Point p = e.GetPosition(hv);
            if (p.X < 2 || p.X > canvasview.Width - 2 || p.Y < PUPPIGUISettings.windowButtonHeight + 2 || p.Y > canvasview.Height - 2)
            {
                if (hv.Children.Contains(dragConnectLineShow))
                {
                    try
                    {
                        hv.Children.Remove(dragConnectLineShow);
                    }
                    catch
                    {

                    }
                }
                if (ignoreclick.Contains(dragConnectLineShow))
                {
                    try
                    {
                        ignoreclick.Remove(dragConnectLineShow);
                    }
                    catch
                    {

                    }
                }
                try
                {
                    hv.DragOver -= drawMyLineOrigin;
                }
                catch
                {

                }
            }
        }

        //draw arrow as we drag node to move
        void drawMyArrowOrigin(object sender, DragEventArgs e)
        {
            if (hv.Children.Contains(nodeMoveArrowShow))
            {
                try
                {
                    hv.Children.Remove(nodeMoveArrowShow);
                }
                catch
                {

                }

            }
            if (ignoreclick.Contains(nodeMoveArrowShow))
            {
                try
                {
                    ignoreclick.Remove(nodeMoveArrowShow);
                }
                catch
                {

                }
            }

            var p = e.GetPosition(hv);

            Vector3D n;
            Point3D pos = new Point3D(-99999, -99999, -99999);
            var source = FindSource(p, out n, out pos);
            if (source == null)
            {
                var ray = Viewport3DHelper.Point2DtoRay3D(hv.Viewport, p);
                if (ray != null)
                {
                    var pi = ray.PlaneIntersection(new Point3D(0, 0, PUPPIGUISettings.nodeHeight / 2), new Vector3D(0, 0, 1));
                    if (pi.HasValue)
                    {
                        pos = pi.Value;
                    }
                    else
                    {
                        pos = new Point3D(-99999, -99999, -99999);
                    }
                }
                else
                {
                    pos = new Point3D(-99999, -99999, -99999);
                }
            }
            if (nmasStart.Z != -99999 && pos.Z != -99999)
            {
                //need to make sure this is not the thing found when dragging
                Point3D pa = pos;
                pa.Offset(0, 0, PUPPIGUISettings.ioHeight * 0.5);
                nodeMoveArrowShow = new ArrowVisual3D();

                double st = Math.Max(1, hv.Camera.Position.DistanceTo(pa) * 0.02);




                nodeMoveArrowShow.Diameter = PUPPIGUISettings.solidConnectionSize * st;
                nodeMoveArrowShow.SetName("Movinode");
                nodeMoveArrowShow.Point1 = nmasStart;
                nodeMoveArrowShow.Point2 = pa;
                nodeMoveArrowShow.Material = new DiffuseMaterial(new SolidColorBrush(Color.FromRgb(0, 255, 0)));


                ignoreclick.Add(nodeMoveArrowShow);
                hv.Children.Add(nodeMoveArrowShow);
            }
            showhatsunder(p);
        }

        void drawMyLineOrigin(object sender, DragEventArgs e)
        {
            if (hv.Children.Contains(dragConnectLineShow))
            {
                try
                {
                    hv.Children.Remove(dragConnectLineShow);
                }
                catch
                {

                }

            }
            if (ignoreclick.Contains(dragConnectLineShow))
            {
                try
                {
                    ignoreclick.Remove(dragConnectLineShow);
                }
                catch
                {

                }
            }

            var p = e.GetPosition(hv);

            Vector3D n;
            Point3D pos = new Point3D(-99999, -99999, -99999);
            var source = FindSource(p, out n, out pos);
            if (source == null)
            {
                var ray = Viewport3DHelper.Point2DtoRay3D(hv.Viewport, p);
                if (ray != null)
                {
                    var pi = ray.PlaneIntersection(new Point3D(0, 0, PUPPIGUISettings.nodeHeight / 2), new Vector3D(0, 0, 1));
                    if (pi.HasValue)
                    {
                        pos = pi.Value;
                    }
                    else
                    {
                        pos = new Point3D(-99999, -99999, -99999);
                    }
                }
                else
                {
                    pos = new Point3D(-99999, -99999, -99999);
                }
            }
            if (dclsStart.Z != -99999 && pos.Z != -99999)
            {
                //need to make sure this is not the thing found when dragging
                Point3D pa = pos;
                pa.Offset(0, 0, PUPPIGUISettings.ioHeight * 0.5);
                dragConnectLineShow = new LinesVisual3D();
                dragConnectLineShow.DepthOffset = 1;
                dragConnectLineShow.SetName("DraggingConn");
                dragConnectLineShow.Points.Add(dclsStart);
                dragConnectLineShow.Points.Add(pa);
                dragConnectLineShow.Color = Color.FromRgb(255, 0, 0);
                dragConnectLineShow.Thickness = PUPPIGUISettings.wireConnectionSize;
                ignoreclick.Add(dragConnectLineShow);
                hv.Children.Add(dragConnectLineShow);
            }
            showhatsunder(p);
        }


        void updatedMyNodeWhileDraggingOver(object sender, DragEventArgs e)
        {

            var p = e.GetPosition(hv);

            Vector3D n;
            Point3D pos = new Point3D(-99999, -99999, -99999);
            var source = FindSource(p, out n, out pos);
            //only if something is there otherwise it doesn't make sense
            if (source == null)
            {
                return;
            }
            string svn = source.Visual.GetName();

            if (svn != null && svn != "trialname" && svn != "grid" && svn.Contains("staticVisual") == false && svn.Contains("Conn_") == false && svn != "light" && svn != "manipulator" && svn.ElementAt(0) != 'I' && svn.ElementAt(0) != 'O')
            {

                ModelVisual3D vv = source.Visual as ModelVisual3D;
                if (vv == null) { return; }
                if (vv.GetName() == "CSAR_PUPPICANVAS") return;

                if (vv.GetName().Contains("_Caption") || vv.GetName().Contains("_CustomChild"))
                {
                    vv = VisualTreeHelper.GetParent(vv) as ModelVisual3D;
                }

                if (vv == null) { return; }

                ModViz3DNode myviz = null;


                try
                {
                    myviz = stacks[vv.GetName()];

                }
                catch
                {
                    myviz = null;
                }
                if (myviz == null) return;
                if (myviz == dragonMyNode && myviz.boundingBox.SizeX > 0 && myviz.boundingBox.SizeY > 0 && myviz.boundingBox.SizeZ > 0)
                {
                    double startXRatio = (dragonMystart.X - myviz.boundingBox.X) / myviz.boundingBox.SizeX;
                    double startYRatio = (dragonMystart.Y - myviz.boundingBox.Y) / myviz.boundingBox.SizeY;
                    double startZRatio = (dragonMystart.Z - myviz.boundingBox.Z) / myviz.boundingBox.SizeZ;
                    double endXRatio = (pos.X - myviz.boundingBox.X) / myviz.boundingBox.SizeX;
                    double endYRatio = (pos.Y - myviz.boundingBox.Y) / myviz.boundingBox.SizeY;
                    double endZRatio = (pos.Z - myviz.boundingBox.Z) / myviz.boundingBox.SizeZ;
                    if (myviz.logical_representation != null)
                    {
                        myviz.logical_representation.dragOver_visualUpdate_me(startXRatio, startYRatio, startZRatio, endXRatio, endYRatio, endZRatio);
                    }
                }

            }
        }

        void drawMyGestureLineOverNode(object sender, DragEventArgs e)
        {
            if (hv.Children.Contains(gestureLineShow))
            {
                try
                {
                    hv.Children.Remove(gestureLineShow);
                }
                catch
                {

                }

            }
            if (ignoreclick.Contains(gestureLineShow))
            {
                try
                {
                    ignoreclick.Remove(gestureLineShow);
                }
                catch
                {

                }
            }

            var p = e.GetPosition(hv);

            Vector3D n;
            Point3D pos = new Point3D(-99999, -99999, -99999);
            var source = FindSource(p, out n, out pos);
            //only if something is there otherwise it doesn't make sense
            if (source == null)
            {
                return;
            }
            if (glsStart.Z != -99999 && pos.Z != -99999)
            {
                //need to make sure this is not the thing found when dragging
                Point3D pa = pos;
                // pa.Offset(0, 0, PUPPIGUISettings.ioHeight * 0.5);
                gestureLineShow = new LinesVisual3D();

                gestureLineShow.DepthOffset = 0.0001;
                gestureLineShow.SetName("DraggingGesture");
                gestureLineShow.Points.Add(glsStart);
                //not all the way to stop it from hitting itself
                Vector3D vao = pa - glsStart;
                Point3D pao = glsStart + vao * 0.95;
                gestureLineShow.Points.Add(pao);
                // gestureLineShow.Color = Color.FromRgb(0, 0, 255);
                gestureLineShow.Color = Color.FromArgb(200, 0, 0, 255);
                gestureLineShow.Thickness = PUPPIGUISettings.wireConnectionSize * 2;
                ignoreclick.Add(gestureLineShow);
                hv.Children.Add(gestureLineShow);
            }
        }

        void drawMyModuleRepresentation(object sender, DragEventArgs e)
        {
            if (hv.Children.Contains(moduleDragMarker))
            {
                try
                {
                    hv.Children.Remove(moduleDragMarker);
                }
                catch
                {

                }

            }
            if (ignoreclick.Contains(moduleDragMarker))
            {
                try
                {
                    ignoreclick.Remove(moduleDragMarker);
                }
                catch
                {

                }
            }

            var p = e.GetPosition(hv);

            Vector3D n;
            Point3D pos = new Point3D(-99999, -99999, -99999);
            var source = FindSource(p, out n, out pos);
            if (source == null)
            {
                var ray = Viewport3DHelper.Point2DtoRay3D(hv.Viewport, p);
                if (ray != null)
                {
                    var pi = ray.PlaneIntersection(new Point3D(0, 0, PUPPIGUISettings.nodeHeight / 2), new Vector3D(0, 0, 1));
                    if (pi.HasValue)
                    {
                        pos = pi.Value;
                    }
                    else
                    {
                        pos = new Point3D(-99999, -99999, -99999);
                    }
                }
                else
                {
                    pos = new Point3D(-99999, -99999, -99999);
                }
            }
            if (pos.Z != -99999)
            {
                //need to make sure this is not the thing found when dragging
                Point3D pa = pos;
                //pa.Offset(0, 0, PUPPIGUISettings.ioHeight * 0.5);
                moduleDragMarker = new BillboardTextVisual3D();

                moduleDragMarker.Position = pa;
                moduleDragMarker.DepthOffset = 1e-3;
                moduleDragMarker.Width = PUPPIGUISettings.nodeSpacing;
                moduleDragMarker.Height = PUPPIGUISettings.nodeSpacing;
                moduleDragMarker.Text = mDMtext;
                moduleDragMarker.Background = new SolidColorBrush(Colors.AliceBlue);
                ignoreclick.Add(moduleDragMarker);
                hv.Children.Add(moduleDragMarker);
            }
            showhatsunder(p);
        }

        private void dragOverNodeGesture(object sender, MouseEventArgs e)
        {
            //deselect
            removeDragSelector();
            removeAllTracesDCLS();
            //    removeAllTracesDMR();
            if (!usingmanip)
            {

                try
                {
                    hv.Children.Remove(mousemarker);

                }
                catch
                {

                }
                try
                {

                    hv.MouseMove -= move_marker;
                    hv.DragOver -= drag_marker;
                }
                catch
                {

                }


                if (e.LeftButton == MouseButtonState.Pressed)
                {
                    removemanipulator();
                    var p = e.GetPosition(hv);


                    //debugdraw(p);

                    Vector3D n;
                    Point3D pos;
                    var source = FindSource(p, out n, out pos);
                    //format for inputs outputs Iindex_guid
                    if (source != null)
                    {
                        string testname = "";
                        try
                        {
                            testname = source.Visual.GetName();
                            if (testname == null) return;
                            ModelVisual3D vv = source.Visual as ModelVisual3D;
                            if (vv.GetName().Contains("_Caption") || vv.GetName().Contains("_CustomChild"))
                            {
                                vv = VisualTreeHelper.GetParent(vv) as ModelVisual3D;
                            }

                            if (vv == null) { return; }

                            try
                            {
                                ModViz3DNode myviz = stacks[vv.GetName()];
                                //if (myviz != null) deselectallnodes();
                                //myviz.xGestureStart = e.GetPosition(hv).X;
                                // myviz.yGestureStart = e.GetPosition(hv).Y;
                                myviz.xGestureStart = pos.X;
                                myviz.yGestureStart = pos.Y;
                                myviz.zGestureStart = pos.Z;
                                if (PUPPIGUISettings.drawGestureLine)
                                {
                                    glsStart.X = pos.X;
                                    glsStart.Y = pos.Y;
                                    glsStart.Z = pos.Z;
                                    hv.DragOver += drawMyGestureLineOverNode;
                                }
                                //
                                if (myviz.nodeCustomRenderer != null)
                                {
                                    if (myviz.logical_representation.GetType().GetMethod("dragOver_visualUpdate_usercode").DeclaringType == myviz.logical_representation.GetType())
                                    {
                                        dragonMyNode = myviz;
                                        dragonMyRe = myviz.nodeCustomRenderer.saveCustomRendererStateToXML();
                                        dragonMystart = new Point3D(pos.X, pos.Y, pos.Z);
                                        hv.DragOver += updatedMyNodeWhileDraggingOver;
                                    }
                                }

                                DataObject dragData = new DataObject("ModViz3DNode", myviz);
                                DragDrop.DoDragDrop(hv, dragData, DragDropEffects.Move);

                            }
                            catch
                            {

                            }

                        }
                        catch
                        {

                            return;
                        }
                    }
                }
                try
                {
                    hv.MouseMove -= move_marker;
                    hv.DragOver -= drag_marker;
                }
                catch
                {

                }
                hv.MouseMove += move_marker;
                hv.DragOver += drag_marker;
            }
        }
        //private void dragSelection(object sender, MouseEventArgs e)
        //{
        //    if (!usingmanip)
        //    {

        //        try
        //        {
        //            hv.Children.Remove(mousemarker);

        //        }
        //        catch
        //        {

        //        }
        //        try
        //        {

        //            hv.MouseMove -= move_marker;
        //            hv.DragOver -= drag_marker;
        //        }
        //        catch
        //        {

        //        }



        //        if (e.LeftButton == MouseButtonState.Pressed)
        //        {
        //            removemanipulator();
        //            var p = e.GetPosition(hv);


        //            //debugdraw(p);

        //            Vector3D n;

        //            var source = FindSource(p, out n, out myPCselStart);
        //            hv.DragOver += drag_select; 
        //            DataObject dragData = new DataObject("ModelVisual3D",dragSelectAreaRectangle );
        //            DragDrop.DoDragDrop(hv, dragData, DragDropEffects.Move);
        //        }



        //    }
        //    try
        //    {
        //        hv.MouseMove -= move_marker;
        //        hv.DragOver -= drag_marker;
        //    }
        //    catch
        //    {

        //    }
        //    hv.MouseMove += move_marker;
        //    hv.DragOver += drag_marker;

        //}

        //selection start
        Point3D myPCselStart;



        //finds the first hit

        Viewport3DHelper.HitResult FindSource(Point p, out Vector3D normal, out Point3D pos)
        {

            var hits = Viewport3DHelper.FindHits(hv.Viewport, p);

            foreach (var h in hits)
            {
                pos = h.Position;
                normal = h.Normal;
                return h;//.Model;
            }

            ////try around
            //if (PUPPIGUISettings.tabletMode && tryTab  )
            //{
            //    Point p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange, p.Y);
            //    hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            //    foreach (var h in hits)
            //    {
            //        pos = h.Position;
            //        normal = h.Normal;
            //        return h;//.Model;
            //    }
            //     p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange, p.Y);
            //    hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            //    foreach (var h in hits)
            //    {
            //        pos = h.Position;
            //        normal = h.Normal;
            //        return h;//.Model;
            //    }
            //    p1 = new Point(p.X , p.Y - PUPPIGUISettings.tabletTouchRange);
            //    hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            //    foreach (var h in hits)
            //    {
            //        pos = h.Position;
            //        normal = h.Normal;
            //        return h;//.Model;
            //    }
            //    p1 = new Point(p.X , p.Y + PUPPIGUISettings.tabletTouchRange);
            //    hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            //    foreach (var h in hits)
            //    {
            //        pos = h.Position;
            //        normal = h.Normal;
            //        return h;//.Model;
            //    }
            //    p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange, p.Y - PUPPIGUISettings.tabletTouchRange);
            //    hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            //    foreach (var h in hits)
            //    {
            //        pos = h.Position;
            //        normal = h.Normal;
            //        return h;//.Model;
            //    }
            //    p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange, p.Y + PUPPIGUISettings.tabletTouchRange);
            //    hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            //    foreach (var h in hits)
            //    {
            //        pos = h.Position;
            //        normal = h.Normal;
            //        return h;//.Model;
            //    }
            //    p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange, p.Y - PUPPIGUISettings.tabletTouchRange);
            //    hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            //    foreach (var h in hits)
            //    {
            //        pos = h.Position;
            //        normal = h.Normal;
            //        return h;//.Model;
            //    }
            //    p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange, p.Y + PUPPIGUISettings.tabletTouchRange);
            //    hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            //    foreach (var h in hits)
            //    {
            //        pos = h.Position;
            //        normal = h.Normal;
            //        return h;//.Model;
            //    }
            //}
            pos = new Point3D();
            normal = new Vector3D();
            return null;
        }

        Viewport3DHelper.HitResult FindSourceTablet(Point p, out Vector3D normal, out Point3D pos)
        {

            var hits = Viewport3DHelper.FindHits(hv.Viewport, p);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }

            Point p1 = new Point();

            //**********************  quarter


            p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange * 0.25, p.Y);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange * 0.25, p.Y);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X, p.Y - PUPPIGUISettings.tabletTouchRange * 0.25);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X, p.Y + PUPPIGUISettings.tabletTouchRange * 0.25);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange * 0.25, p.Y - PUPPIGUISettings.tabletTouchRange * 0.25);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange * 0.25, p.Y + PUPPIGUISettings.tabletTouchRange * 0.25);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange * 0.25, p.Y - PUPPIGUISettings.tabletTouchRange * 0.25);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange * 0.25, p.Y + PUPPIGUISettings.tabletTouchRange * 0.25);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }


            //*********************** half


            p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange * 0.5, p.Y);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange * 0.5, p.Y);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X, p.Y - PUPPIGUISettings.tabletTouchRange * 0.5);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X, p.Y + PUPPIGUISettings.tabletTouchRange * 0.5);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange * 0.5, p.Y - PUPPIGUISettings.tabletTouchRange * 0.5);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange * 0.5, p.Y + PUPPIGUISettings.tabletTouchRange * 0.5);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange * 0.5, p.Y - PUPPIGUISettings.tabletTouchRange * 0.5);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange * 0.5, p.Y + PUPPIGUISettings.tabletTouchRange * 0.5);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }

            //********************* 3/4


            p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange * 0.75, p.Y);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange * 0.75, p.Y);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X, p.Y - PUPPIGUISettings.tabletTouchRange * 0.75);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X, p.Y + PUPPIGUISettings.tabletTouchRange * 0.75);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange * 0.75, p.Y - PUPPIGUISettings.tabletTouchRange * 0.75);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange * 0.75, p.Y + PUPPIGUISettings.tabletTouchRange * 0.75);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange * 0.75, p.Y - PUPPIGUISettings.tabletTouchRange * 0.75);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange * 0.75, p.Y + PUPPIGUISettings.tabletTouchRange * 0.75);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }


            //*************************

            //try around

            p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange, p.Y);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange, p.Y);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X, p.Y - PUPPIGUISettings.tabletTouchRange);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X, p.Y + PUPPIGUISettings.tabletTouchRange);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange, p.Y - PUPPIGUISettings.tabletTouchRange);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange, p.Y + PUPPIGUISettings.tabletTouchRange);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange, p.Y - PUPPIGUISettings.tabletTouchRange);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange, p.Y + PUPPIGUISettings.tabletTouchRange);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }

            //now try values in between
            p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange * 0.5, p.Y);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange * 0.5, p.Y);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X, p.Y - PUPPIGUISettings.tabletTouchRange * 0.5);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X, p.Y + PUPPIGUISettings.tabletTouchRange * 0.5);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange * 0.5, p.Y - PUPPIGUISettings.tabletTouchRange * 0.5);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X - PUPPIGUISettings.tabletTouchRange * 0.5, p.Y + PUPPIGUISettings.tabletTouchRange * 0.5);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange * 0.5, p.Y - PUPPIGUISettings.tabletTouchRange * 0.5);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            p1 = new Point(p.X + PUPPIGUISettings.tabletTouchRange * 0.5, p.Y + PUPPIGUISettings.tabletTouchRange * 0.5);
            hits = Viewport3DHelper.FindHits(hv.Viewport, p1);

            foreach (var h in hits)
            {
                if (h.Visual != null && !ignoreclick.Contains(h.Visual))
                {

                    pos = h.Position;
                    normal = h.Normal;
                    return h;
                }
            }
            pos = new Point3D();
            normal = new Vector3D();
            return null;
        }

        //finds the other hits

        List<Viewport3DHelper.HitResult> FindOtherSources(Point p)
        {
            List<Viewport3DHelper.HitResult> hitsfound = new List<Viewport3DHelper.HitResult>();
            var hits = Viewport3DHelper.FindHits(hv.Viewport, p);
            int hc = 0;
            foreach (var h in hits)
            {
                if (hc > 0)
                {
                    hitsfound.Add(h as Viewport3DHelper.HitResult);
                }
                hc++;
            }

            return hitsfound;
        }


        //when a mouse command is finished. mostly for moving stuff with the manipulator
        private void PUPPICanvas_MouseUp(object sender, MouseButtonEventArgs e)
        {
            mouseisdown = false;
            if (e.ChangedButton == MouseButton.Middle) return;
            //removeAllTracesDMR(); 
            //removeAllTracesDCLS();
            dragip = false;
            //we are not using manipulator anymore
            usingmanip = false;
            if (leftClickModeMove)
            {
                if (thiscanvasdefinitelylocked == false)
                {
                    //check for any transforms
                    //only one transform at one time
                    //check if selectionm rectangle has transform
                    if (dragSelectAreaRectangle != null)
                    {
                        if (hv.Children.Contains(dragSelectAreaRectangle))
                        {
                            double ox = 0;
                            double oy = 0;

                            ox = dragSelectAreaRectangle.Transform.Value.OffsetX;
                            oy = dragSelectAreaRectangle.Transform.Value.OffsetY;
                            if (ox != 0 || oy != 0)
                            {
                                canvasabouttochange();

                                //disable updating nodes until we are done
                                blockconnupdates = true;
                                List<ModViz3DNode> nm = new List<ModViz3DNode>();
                                //move all selected nodes
                                foreach (string g in selstacks)
                                {
                                    ModViz3DNode mv = null;
                                    if (stacks.TryGetValue(g, out mv))
                                        if (mv != null && mv.parent == null) nm.Add(mv);

                                }
                                foreach (ModViz3DNode mv in nm)
                                {
                                    mv.movestack(ox, oy);
                                }
                                foreach (ModViz3DNode mv in nm)
                                {
                                    mv.fitroots(stacks);
                                }
                                deselectallnodes();
                                removeDragSelector();
                                blockconnupdates = false;
                                update_all_connectors();
                                try
                                {
                                    cm.Transform.Value.SetIdentity();
                                    if (hv.Children.IndexOf(cm) >= 0)
                                    {
                                        cm.UnBind();
                                        hv.Children.Remove(cm);
                                    }



                                }
                                catch
                                {
                                }
                                reset_all_transforms();

                            }
                            reset_all_transforms();
                        }
                    }


                    foreach (ModelVisual3D m3d in hv.Children)
                    {
                        string modname = "";
                        try
                        {
                            modname = m3d.GetName();
                            if (modname == null)
                            {
                                modname = "";
                            }
                        }
                        catch
                        {
                            modname = "";
                        }
                        if (modname != "" && modname != "trialname" && modname != "grid" && modname.Contains("staticVisual") == false && modname != "light" && modname != "manipulator")// && modname.ElementAt(0) != 'I' && modname.ElementAt(0) != 'O')
                        {
                            double ox = 0;
                            double oy = 0;
                            //if (m3d.Transform.Value.OffsetX != 0 || m3d.Transform.Value.OffsetY != 0)
                            //{
                            ox = m3d.Transform.Value.OffsetX;
                            oy = m3d.Transform.Value.OffsetY;


                            try
                            {
                                m3d.Transform = Transform3D.Identity;
                            }
                            catch
                            {

                            }
                            //}//custom nodes 
                            //else if (m3d.Children.Count>1 && (  m3d.Children[0].Transform.Value.OffsetX != 0 || m3d.Children[0].Transform.Value.OffsetY != 0))
                            //{
                            //    ox = m3d.Children[0].Transform.Value.OffsetX;
                            //    oy = m3d.Children[0].Transform.Value.OffsetY;
                            //}

                            //if (m3d.Transform.Value.OffsetX != 0 || m3d.Transform.Value.OffsetY != 0)
                            if (ox != 0 || oy != 0)
                            {

                                canvasabouttochange();

                                //disable updating nodes until we are done
                                blockconnupdates = true;



                                //we know that normally only one object moved at one time
                                //base
                                ModViz3DNode myviz = null;
                                try
                                {
                                    myviz = stacks[m3d.GetName()];
                                }
                                catch
                                {
                                    myviz = null;
                                }
                                if (myviz != null)
                                {
                                    ModViz3DNode myroot = myviz.getroot();

                                    myroot.movestack(ox, oy);

                                    myroot.fitroots(stacks);
                                }




                                blockconnupdates = false;
                                update_all_connectors();
                                try
                                {
                                    cm.Transform.Value.SetIdentity();
                                    if (hv.Children.IndexOf(cm) >= 0)
                                    {
                                        cm.UnBind();
                                        hv.Children.Remove(cm);
                                    }



                                }
                                catch
                                {
                                }
                                //reset_all_transforms();
                                break;
                            }
                        }
                        reset_all_transforms();
                    }
                    //  reset_all_transforms();
                    update_grid();
                }
            }
            try
            {
                //no more dragging
                hv.DragOver -= pandrag;
                hv.MouseMove -= move_marker;
                hv.DragOver -= drag_marker;
            }
            catch
            {

            }
            try
            {
                hv.MouseMove -= letMyMouseGo;
            }
            catch
            {

            }
            try
            {
                hv.DragOver -= drag_select;
            }
            catch
            {

            }
            try
            {
                // hv.DragOver -= dragnode2move ;
            }
            catch
            {

            }
            hv.MouseMove += move_marker;
            hv.DragOver += drag_marker;




        }
        void reset_all_transforms()
        {
            //return;
            foreach (ModelVisual3D m3d in hv.Children)
            {
                if (m3d.Transform != null)
                    m3d.Transform.Value.SetIdentity();
            }
            if (transformed != null)
            {
                transformed.Transform = Transform3D.Identity;
                transformed = null;
            }
        }
        //debug drawing on 2d screen to see mouse position
        void debugdraw(Point pos)
        {
            // Create a red Ellipse.
            Ellipse myEllipse = new Ellipse();

            // Create a SolidColorBrush with a red color to fill the  
            // Ellipse with.
            SolidColorBrush mySolidColorBrush = new SolidColorBrush();

            // Describes the brush's color using RGB values.  
            // Each value has a range of 0-255.
            mySolidColorBrush.Color = Color.FromArgb(255, 255, 255, 0);
            myEllipse.Fill = mySolidColorBrush;
            myEllipse.StrokeThickness = 2;
            myEllipse.Stroke = Brushes.Black;

            // Set the width and height of the Ellipse.
            myEllipse.Width = 10;
            myEllipse.Height = 10;
            myEllipse.Margin = new Thickness(pos.X, pos.Y, 10, 10);

            // Add the Ellipse to theview
            canvasview.Children.Add(myEllipse);
        }



        //when dragging from output to input

        void dragoutputitem(object sender, MouseEventArgs e)
        {
            // removeAllTracesDMR();
            removeAllTracesGLS();
            //if (!usingmanip)
            //{
            try
            {
                hv.Children.Remove(mousemarker);

            }
            catch
            {

            }
            try
            {

                hv.MouseMove -= move_marker;
                hv.DragOver -= drag_marker;
            }
            catch
            {

            }


            if (e.LeftButton == MouseButtonState.Pressed)
            {

                var p = e.GetPosition(hv);


                //debugdraw(p);

                Vector3D n;
                Point3D pos;
                var source = FindSource(p, out n, out pos);
                //format for inputs outputs Iindex_guid
                #region willdropon
                if (source != null)
                {
                    string testname = "";
                    try
                    {
                        testname = source.Visual.GetName();
                        if (testname == null) return;
                    }
                    catch
                    {

                        return;
                    }

                    if (testname.Length == 0) return;
                    dragip = true;
                    //figure out where a connection line would start
                    //ModelVisual3D showLineOrigin = source.Visual as ModelVisual3D;
                    ////if we drag off a text
                    //if (testname.Contains("Value") || testname.Contains("Name"))
                    //{
                    //    showLineOrigin = VisualTreeHelper.GetParent(showLineOrigin) as ModelVisual3D;
                    //}
                    ////get line start point
                    //if (showLineOrigin != null) dclsStart = showLineOrigin.getBBRecursive().rectcenter();

                    if (testname.ElementAt(0) == 'O')
                    {
                        //change the cursor
                        //  Mouse.OverrideCursor = Cursors.Hand;   
                        //this.Cursor = Cursors.Hand;  
                        makenodestransparent();
                        //so the camera pans
                        hv.DragOver += pandrag;
                        ModelVisual3D d3origin = source.Visual as ModelVisual3D;
                        //if we drag off a text
                        if (testname.Contains("Value") || testname.Contains("Name"))
                        {
                            d3origin = VisualTreeHelper.GetParent(d3origin) as ModelVisual3D;
                        }

                        if (d3origin != null)
                        {
                            if (PUPPIGUISettings.drawLineWhenConnecting)
                            {
                                // ModelVisual3D showLineOrigin = d3origin;
                                //if (showLineOrigin != null) dclsStart = showLineOrigin.getBBRecursive().rectcenter();
                                dclsStart = pos;
                                dclsStart.Offset(0, 0, -PUPPIGUISettings.ioHeight * 0.5);
                            }
                            //create input parameter to drop on other input
                            PUPPIInParameter pinp = new PUPPIInParameter();

                            string[] words = testname.Split('_');
                            PUPPIModule pinpsource = null;
                            // oc.SetName("O_"+icnt.ToString()+"_"+nodeGUID.ToString());
                            try
                            {
                                pinpsource = stacks[words[2]].logical_representation;
                            }
                            catch
                            {

                                return;
                            }
                            if (pinpsource != null)
                            {
                                //output parameter index
                                int opr = -1;
                                try
                                {
                                    opr = Convert.ToInt32(words[1]);
                                }
                                catch
                                {
                                    opr = -1;
                                }

                                bool successfulconn = pinp.getinputfrom(pinpsource, opr);
                                if (successfulconn == true)
                                {
                                    try
                                    {
                                        hv.DragOver += drawMyLineOrigin;
                                    }
                                    catch
                                    {

                                    }
                                    DataObject dragData = new DataObject("PUPPIInParameter", pinp);
                                    DragDrop.DoDragDrop(hv, dragData, DragDropEffects.Move);
                                }
                            }


                        }
                    }
                    //if we drag from an input
                    else if (testname.ElementAt(0) == 'I')
                    {


                        ModelVisual3D d3origin = source.Visual as ModelVisual3D;
                        //if we drag off a text
                        if (testname.Contains("Value") || testname.Contains("Name"))
                        {
                            d3origin = VisualTreeHelper.GetParent(d3origin) as ModelVisual3D;
                        }

                        if (d3origin != null)
                        {
                            if (PUPPIGUISettings.drawLineWhenConnecting)
                            {
                                //ModelVisual3D showLineOrigin = d3origin;
                                //if (showLineOrigin != null) dclsStart = showLineOrigin.getBBRecursive().rectcenter();
                                dclsStart = pos;
                                dclsStart.Offset(0, 0, -PUPPIGUISettings.ioHeight * 0.5);
                            }
                        }

                        //change the cursor
                        // this.Cursor = Cursors.Hand;  
                        //  Mouse.OverrideCursor = Cursors.Hand;   
                        makenodestransparent();
                        //destination node
                        string[] words = testname.Split('_');
                        ModViz3DNode destnode = null;
                        try
                        {
                            destnode = stacks[words[2]];
                        }
                        catch
                        {
                            destnode = null;
                        }
                        if (destnode == null) return;

                        PUPPIModule destmod = null;
                        try
                        {
                            destmod = destnode.logical_representation;
                        }
                        catch
                        {
                            destmod = null;
                        }
                        if (destmod == null) return;
                        //destination input index
                        int dinputindex = -1;
                        try
                        {
                            dinputindex = Convert.ToInt32(words[1]);
                        }
                        catch
                        {
                            dinputindex = -1;
                        }
                        if (dinputindex == -1) return;
                        //so the camera pans
                        hv.DragOver += pandrag;
                        //now we can connect the output that is connected to this input
                        PUPPIInParameter pinp = new PUPPIInParameter();
                        PUPPIModule pinpsource = destmod.inputs[dinputindex].module;
                        int opr = destmod.inputs[dinputindex].outParIndex;
                        bool successfulconn = pinp.getinputfrom(pinpsource, opr);
                        if (successfulconn == true)
                        {
                            try
                            {
                                hv.DragOver += drawMyLineOrigin;
                            }
                            catch
                            {

                            }
                            DataObject dragData = new DataObject("PUPPIInParameter", pinp);
                            DragDrop.DoDragDrop(hv, dragData, DragDropEffects.Move);
                        }

                    }

                }
                #endregion
                ////draw line
                //else
                //{


                //}
            }
            try
            {
                hv.MouseMove -= move_marker;
                hv.DragOver -= drag_marker;
            }
            catch
            {

            }
            hv.MouseMove += move_marker;
            hv.DragOver += drag_marker;
            //}

        }

        //when node to move it
        void dragnode2move(object sender, MouseEventArgs e)
        {

            if (!usingmanip && leftClickModeMove && thiscanvasdefinitelylocked == false)
            {
                try
                {
                    hv.Children.Remove(mousemarker);

                }
                catch
                {

                }
                try
                {

                    hv.MouseMove -= move_marker;
                    hv.DragOver -= drag_marker;
                }
                catch
                {

                }


                if (e.LeftButton == MouseButtonState.Pressed)
                {

                    var p = e.GetPosition(hv);


                    //debugdraw(p);

                    Vector3D n;
                    Point3D pos;
                    var source = FindSource(p, out n, out pos);


                    if (source != null)
                    {
                        string testname = "";
                        try
                        {
                            testname = source.Visual.GetName();
                            if (testname == null) return;
                        }
                        catch
                        {

                            return;
                        }

                        if (testname.Length == 0) return;
                        //make sure node
                        if (testname != "trialname" && testname != "grid" && testname.Contains("staticVisual") == false && testname.Contains("Conn_") == false && testname != "light" && testname != "manipulator" && testname.ElementAt(0) != 'I' && testname.ElementAt(0) != 'O')
                        {

                            ModelVisual3D vv = source.Visual as ModelVisual3D;
                            //if dropped on caption, take their parent 
                            //also if dropped on child of custm renderer visual
                            if (vv.GetName().Contains("_Caption") || vv.GetName().Contains("_CustomChild"))
                            {
                                vv = VisualTreeHelper.GetParent(vv) as ModelVisual3D;
                            }






                            if (vv != null)
                            {

                                //extra check
                                if (vv.GetName() == null || vv.GetName().Length == 0) return;



                                ModViz3DNode dragmovesourcenode = null;
                                //so we avoid selection rectangle
                                if (vv.GetName() != "CSAR_PUPPICANVAS")
                                {


                                    try
                                    {
                                        dragmovesourcenode = stacks[vv.GetName()];
                                    }
                                    catch
                                    {

                                        return;
                                    }
                                }
                                if (pos != null)
                                    nmasStartAc = pos;
                                else nmasStartAc = new Point3D(-99999, -99999, -99999);
                                if (dragmovesourcenode != null)
                                {

                                    Rect3D dragbb = dragmovesourcenode.boundingBox;
                                    if (dragbb.IsEmpty) return;
                                    nmasStart = dragbb.rectcenter();
                                    //start from node top so more visible
                                    nmasStart.Z = dragbb.Location.Z + dragbb.SizeZ;
                                    //so the camera pans
                                    hv.DragOver += pandrag;
                                    //so line gets drawn
                                    hv.DragOver += drawMyArrowOrigin;
                                    DataObject dragData = new DataObject("ModViz3DNode", dragmovesourcenode);
                                    DragDrop.DoDragDrop(hv, dragData, DragDropEffects.Move);

                                }
                                else if (vv == dragSelectAreaRectangle)
                                {
                                    Rect3D dragbb = dragSelectAreaRectangle.getBBRecursive();
                                    if (dragbb.IsEmpty) return;
                                    nmasStart = dragbb.rectcenter();
                                    //start from node top so more visible
                                    nmasStart.Z = dragbb.Location.Z + dragbb.SizeZ;
                                    //so the camera pans
                                    hv.DragOver += pandrag;
                                    //so line gets drawn
                                    hv.DragOver += drawMyArrowOrigin;
                                    DataObject dragData = new DataObject("ModelVisual3D", dragSelectAreaRectangle);
                                    DragDrop.DoDragDrop(hv, dragData, DragDropEffects.Move);
                                }


                            }
                        }
                    }

                }
                try
                {
                    hv.MouseMove -= move_marker;
                    hv.DragOver -= drag_marker;
                }
                catch
                {

                }
                hv.MouseMove += move_marker;
                hv.DragOver += drag_marker;
            }
            removeAllTracesDCLS();
            removeAllTracesDMR();
            removeAllTracesGLS();
            removeAllTracesNMAS();

        }



        //gets the bounding box of all objects
        private Rect3D bbox()
        {
            d2collisionmodel levelredo = new d2collisionmodel();
            foreach (ModViz3DNode mv in stacks.Values)
            {
                if (mv.parent == null)
                {
                    ////just in case
                    if (mv.myself != null)
                    {
                        levelredo.footprints.Add(mv.boundingBox.padme(PUPPIGUISettings.nodeSpacing * 2));
                    }
                }
            }
            levelredo.recalculate_perimeter();
            return levelredo.region_perimeter;
        }

        //updates the grid size to match all the objects
        private void update_grid()
        {



            //new grid
            GridLinesVisual3D newgrid = new GridLinesVisual3D();

            newgrid.Center = new Point3D(0, 0, 0);
            // Width="8" Length="8" MinorDistance="1" MajorDistance="1" Thickness="0.01"
            newgrid.Width = 8;
            newgrid.Length = 8;
            newgrid.MinorDistance = gv3d.MinorDistance;
            newgrid.MajorDistance = gv3d.MajorDistance;
            newgrid.Thickness = gv3d.Thickness;
            newgrid.Material = gv3d.Material;
            newgrid.SetName("grid");
            int gindex = hv.Children.IndexOf(gv3d);
            Rect3D rperim = bbox();

            newgrid.Length = Math.Max(2 * Math.Max(Math.Abs(rperim.Location.X), Math.Abs(rperim.Location.X + rperim.SizeX)) + 1, 8);

            newgrid.Width = Math.Max(2 * Math.Max(Math.Abs(rperim.Location.Y), Math.Abs(rperim.Location.Y + rperim.SizeY)) + 1, 8);
            if (PUPPIGUISettings.showGridOnCanvas) hv.Children[gindex] = newgrid;
            ignoreclick[ignoreclick.IndexOf(gv3d)] = newgrid;
            gv3d = newgrid;

        }
        //utility function to read an xml file
        //if isfile is true it reads from the file specified, otherwise the string is the xml data
        //for import, it displaces nodes
        void readxml(string filenamepath, out Dictionary<string, ModViz3DNode> newstacks, bool isfile, int nodeGUIDdisplace = 0)
        {
            //stopMouseEv(); 
            newstacks = new Dictionary<string, ModViz3DNode>();
            XmlDocument doc = new XmlDocument();
            try
            {
                if (isfile)
                {
                    doc.Load(filenamepath);
                }
                else
                {
                    doc.LoadXml(filenamepath);
                }
            }
            catch (Exception exy)
            {
                if (PUPPIDebugger.debugenabled)
                {
                    PUPPIDebugger.log("Load file error: " + filenamepath + " " + exy.ToString());
                }
                // resumeMouseEv(); 
                return;
            }

            //first pass, load nodes
            ModViz3DNode testnode = null;
            XmlNodeList nodes = doc.DocumentElement.SelectNodes("/canvas/node");

            foreach (XmlNode mynode in nodes)
            {
                try
                {
                    testnode = new ModViz3DNode();
                    //view reference
                    testnode.mycanvas = this;
                    testnode.myview = this.hv;
                    //module pass
                    PUPPIModule mm = null;
                    //saved settings
                    string ss = "";
                    foreach (XmlNode childnode in mynode.ChildNodes)
                    {
                        if (childnode.Name == "PUPPImodule")
                        {
                            //get the class by name
                            //from all loaded assemblies

                            Type tm = null;
                            string tName = childnode.InnerText;
                            tm = PUPPIModel.AutomaticPUPPImodulesCreator.findTypeByName(tName);

                            if (tm == null)
                            {
                                throw new Exception("nullmodule");
                            }

                            object pm1 = System.Activator.CreateInstance(tm);
                            mm = pm1 as PUPPIModule;

                        }
                        if (childnode.Name == "savedSettings")
                        {
                            ss = childnode.InnerText;
                        }
                    }
                    if (ss != "") mm.initOnLoad(ss);
                    testnode.logical_representation = mm;

                    string rendererLoad = "";
                    foreach (XmlNode childnode in mynode.ChildNodes)
                    {
                        if (childnode.Name == "nodeCustomRenderer")
                        {
                            rendererLoad = childnode.InnerText;
                        }

                        if (childnode.Name == "guid")
                        {
                            testnode.nodeGUID = Convert.ToInt32(childnode.InnerText) + nodeGUIDdisplace;
                        }

                        if (childnode.Name == "displayname")
                        {
                            testnode.displayname = childnode.InnerText;
                        }


                        if (childnode.Name == "baseindex")
                        {
                            testnode.baseindex = Convert.ToInt16(childnode.InnerText);
                        }

                        if (childnode.Name == "xpos")
                        {
                            testnode.myposition.X = Convert.ToDouble(childnode.InnerText);
                        }
                        if (childnode.Name == "ypos")
                        {
                            testnode.myposition.Y = Convert.ToDouble(childnode.InnerText);
                        }
                        if (childnode.Name == "listlevel")
                        {
                            testnode.setlistlevel(Convert.ToInt16(childnode.InnerText));

                        }
                        if (childnode.Name == "hidden")
                        {
                            testnode.hiddenOnLockedCanvas = Convert.ToBoolean(childnode.InnerText);
                        }

                        if (childnode.Name == "solid")
                        {
                            testnode.isSolid = Convert.ToBoolean(childnode.InnerText);
                        }

                        if (childnode.Name == "nodeBBOX")
                        {
                            try
                            {
                                char[] sp = { ',' };
                                string[] sss = childnode.InnerText.Split(sp);
                                if (sss.Length == 6)
                                {
                                    testnode.boundingBox = new Rect3D(Convert.ToDouble(sss[0]), Convert.ToDouble(sss[1]), Convert.ToDouble(sss[2]), Convert.ToDouble(sss[3]), Convert.ToDouble(sss[4]), Convert.ToDouble(sss[5]));
                                }
                            }
                            catch
                            {

                            }
                        }

                        //if (childnode.Name == "listlevel")
                        //{
                        //    testnode.setlistlevel(Convert.ToInt16(childnode.InnerText));

                        //}
                        //if (childnode.Name == "nodeScript")
                        //{
                        //    testnode.script = childnode.InnerText;

                        //}


                    }
                    if (testnode != null)
                    {
                        testnode.setRenderer();
                        if (testnode.nodeCustomRenderer != null && rendererLoad != "")
                        {
                            try
                            {
                                testnode.nodeCustomRenderer.loadCustomRendererStateFromXML(rendererLoad);
                            }
                            catch (Exception exy)
                            {
                                if (PUPPIDebugger.debugenabled)
                                {
                                    PUPPIDebugger.log("Failed to initialize renderer saved state " + testnode.nodeGUID.ToString() + " " + exy.ToString());
                                }
                            }
                        }
                        newstacks.Add(testnode.nodeGUID.ToString(), testnode);
                    }
                }
                catch (Exception exy)
                {
                    if (PUPPIDebugger.debugenabled)
                    {
                        PUPPIDebugger.log("XML Instantiation error: " + mynode.InnerText + " " + exy.ToString());
                    }
                }

            }
            //second pass, connect nodes
            nodes = doc.DocumentElement.SelectNodes("/canvas/node");
            foreach (XmlNode mynode in nodes)
            {
                try
                {
                    //guid has to be the first item
                    testnode = newstacks[(Convert.ToInt32(mynode.ChildNodes[0].InnerText) + nodeGUIDdisplace).ToString()];


                    foreach (XmlNode childnode in mynode.ChildNodes)
                    {





                        if (childnode.Name == "parentguid")
                        {
                            //null parent or circular reference (issues with files created from other sources)
                            if (childnode.InnerText != "" && Convert.ToInt32(childnode.InnerText) + nodeGUIDdisplace != testnode.nodeGUID && PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.ThreeDimensional)
                            {
                                testnode.parent = newstacks[(Convert.ToInt32(childnode.InnerText) + nodeGUIDdisplace).ToString()];

                                newstacks[(Convert.ToInt32(childnode.InnerText) + nodeGUIDdisplace).ToString()].childs.Add(testnode);
                            }
                        }

                        if (childnode.Name == "connector")
                        {
                            //for an input conenctor we need to know which input on the current node
                            //the node it connects to and which output on that node
                            // <inputindex>1</inputindex>
                            //  <nodeguid>3</nodeguid>
                            //<outputindex>2</outputindex>
                            try
                            {
                                XmlNode ii = childnode.ChildNodes[0];
                                int inputindex = Convert.ToInt32(ii.InnerText);
                                ii = childnode.ChildNodes[1];

                                PUPPIModule sourcemodule = newstacks[(Convert.ToInt32(ii.InnerText) + nodeGUIDdisplace).ToString()].logical_representation;



                                ii = childnode.ChildNodes[2];
                                int outparindex = Convert.ToInt32(ii.InnerText);
                                ////finally the boolean
                                //ii = childnode.ChildNodes[3];
                                //bool isoptional = Convert.ToBoolean(ii.InnerText);  


                                testnode.logical_representation.inputs[inputindex].module = sourcemodule;
                                testnode.logical_representation.inputs[inputindex].outParIndex = outparindex;
                                //testnode.logical_representation.inputs[inputindex].isoptional= isoptional;
                                //set up so that when this changes we get a notification
                                testnode.logical_representation.inputs[inputindex].sourcenodeevent(sourcemodule);
                                //conenct the logic to appropriate events to pass it along to the destination
                                testnode.logical_representation.connectevent(testnode.logical_representation.inputs[inputindex]);
                            }
                            catch
                            {

                            }
                        }

                        if (childnode.Name == "output")
                        {

                            try
                            {
                                XmlNode oi = childnode.ChildNodes[0];
                                // .SelectSingleNode("/connector/inputindex");
                                int outputindex = Convert.ToInt32(oi.InnerText);
                                //for single entry
                                if (testnode.list_level == 0)
                                {
                                    XmlNode ov = childnode.ChildNodes[1];
                                    // but we can still have lists and grids this way
                                    if (testnode.logical_representation.outputs[outputindex].GetType() == typeof(ArrayList))
                                    {
                                        testnode.logical_representation.outputs[outputindex] = readALfromXMLstring(ov.InnerText);
                                    }
                                    else
                                    {
                                        testnode.logical_representation.outputs[outputindex] = Convert.ChangeType(ov.InnerText, testnode.logical_representation.outputs[outputindex].GetType());
                                    }
                                }
                                else
                                {
                                    int numberelems = childnode.ChildNodes.Count - 1;
                                    //needed for correct display
                                    testnode.setlistlevel(testnode.list_level, numberelems);
                                    //get the output type from default
                                    Type otype = testnode.logical_representation.outputs[outputindex].GetType();
                                    ArrayList olist = new ArrayList();
                                    for (int olcount = 1; olcount <= numberelems; olcount++)
                                    {
                                        XmlNode ov = childnode.ChildNodes[olcount];
                                        olist.Add(Convert.ChangeType(ov.InnerText, otype));
                                    }
                                    testnode.logical_representation.outputs[outputindex] = olist;

                                }
                            }
                            catch
                            {

                            }
                        }
                        //auto list
                        if (childnode.Name == "input")
                        {
                            XmlNode ii = childnode.ChildNodes[0];

                            int inputindex = Convert.ToInt32(ii.InnerText);
                            XmlNode iv = childnode.ChildNodes[1];
                            testnode.logical_representation.inputs[inputindex].inputAutomaticListMode = Convert.ToBoolean(iv.InnerText);

                        }
                    }


                }
                catch (Exception exy)
                {
                    if (PUPPIDebugger.debugenabled)
                    {
                        PUPPIDebugger.log("XML Node Connection error: " + mynode.InnerText + " " + exy.ToString());
                    }
                }
            }
            //  resumeMouseEv(); 

        }
        //reads a string from a text into an array list or grid
        internal static ArrayList readALfromXMLstring(string xmlstring)
        {
            //a 2d grid
            ArrayList res = new ArrayList();
            if (xmlstring.Contains("GRID__"))
            {
                xmlstring = xmlstring.Replace("GRID__", "");
                string[] lines = xmlstring.Split(new string[] { "\n" }, StringSplitOptions.None);
                foreach (string gline in lines)
                {
                    if (gline != "")
                    {
                        ArrayList groww = new ArrayList();
                        string[] rline = gline.Split(new string[] { "__" }, StringSplitOptions.None);
                        foreach (string sb in rline)
                        {
                            groww.Add(sb);
                        }
                        res.Add(groww);
                    }

                }
            }
            //a list
            else if (xmlstring.Contains("LIST__"))
            {
                xmlstring = xmlstring.Replace("LIST__", "");
                string[] rline = xmlstring.Split(new string[] { "__" }, StringSplitOptions.None);
                foreach (string sb in rline)
                {
                    res.Add(sb);
                }
            }
            return res;

        }

        //clears all the object visuals from the 3d window
        void clearobjects(bool fullreset)
        {
            //while (stacks.Values.Count > 0)
            //{
            //    try
            //    {
            //        ModViz3DNode todelete = stacks.Values.ToArray()[0];
            //        todelete.delete();
            //    }
            //    catch
            //    {
            //    }

            //}
            //stacks.Clear();
            //gotta wait for it to update first
            //stopMouseEv();
            //  hv.Children.Clear();
            //stacks.Clear();  
            Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
            //Dispatcher.CurrentDispatcher.  


            initme(this.tlef, this.ttop, this.twid, this.thei, fullreset);
            // Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
            ModViz3DNode.GUIDcount = 0;
            //   resumeMouseEv();

        }
        //refreshes the stacks in the 3d window
        //fitall enabled if loading from a file where positions might be wrong
        void pushnewstacks(Dictionary<string, ModViz3DNode> newstacks, bool fitall = false, Dictionary<string, connectorpath> hascps = null)
        {
            blockconnupdates = true;
            //bool retryme = true;
            //int numtries = 0;
            stacks = newstacks;
            //render elements
            //while (retryme == true && numtries <= newstacks.Count)
            //{
            //retryme = false;

            //try parallel
            //  Parallel.ForEach(stacks.Values, newnode =>
            foreach (ModViz3DNode newnode in stacks.Values)
            {

                //if connections, we need to rely on existing bounding boxes
                if (hascps == null)
                {

                    //bottom node
                    if (newnode.parent == null) // || newnode.parent.myself!=null    )
                    {


                        newnode.renderme();

                        //make sure coords in node spacing

                        //render its children recursively so we don't get null in bottom pyramid
                        newnode.renderchildren();


                    }
                }
                else
                {
                    newnode.rendermebox();
                }

                //increase GUID to make sure we don't get errors when we make new nodes
                if (newnode.nodeGUID >= ModViz3DNode.GUIDcount)
                {
                    ModViz3DNode.GUIDcount = newnode.nodeGUID + 1;
                }

            }
            //numtries++;
            //}     //need to update captions and conenctors

            //delete before messing with tjhem without updates
            //foreach (ModViz3DNode newnode in stacks.Values)
            //{

            //    newnode.deleteall_inouts(); 
            //}
            PUPPIruntimesettings.graphicalnodeupdatestates pe = PUPPIruntimesettings.currentstate;
            if (fitall && hascps == null)
                PUPPIruntimesettings.currentstate = PUPPIruntimesettings.graphicalnodeupdatestates.IsNotReady;
            //need to fit roots too
            //if (stacks.Count > 0)
            //{

            //    if (fitall && hascps==null)
            //    {
            //        foreach (ModViz3DNode mr in stacks.Values)
            //        {
            //            if (mr.parent == null) mr.fitroots(stacks);
            //            // break;
            //        }
            //        // fitallroots(stacks);
            //    }
            //    update_grid();
            //}
            PUPPIruntimesettings.currentstate = pe;
            //update node connectors
            foreach (ModViz3DNode newnode in stacks.Values)
            {
                newnode.update_caption();
                if (hascps == null)
                    newnode.update_inouts(false);
                else
                    newnode.update_inouts(true);
            }


            if (stacks.Count > 0)
            {

                if (fitall && hascps == null)
                {
                    foreach (ModViz3DNode mr in stacks.Values)
                    {
                        //this for nodes not updated by update in outs
                        if (mr.parent == null && mr.logical_representation != null && mr.logical_representation.inputs.Count == 0 && mr.logical_representation.outputs.Count == 0)
                        {
                            mr.fitroots(stacks);
                        }
                        // break;
                    }
                    // fitallroots(stacks);
                }
                update_grid();
            }


            //for (int nu = 0; nu < nodestoupdate.Count; nu++)
            //{
            //    nodestoupdate[nu].update_caption();
            //    nodestoupdate[nu].update_inouts();
            //}
            nodestoupdate.Clear();
            //need to make this as a list in order to be able to delete
            List<ModViz3DNode> checkunique = stacks.Values.ToList<ModViz3DNode>();
            //to include unique nodes and for legacy purposes delete the duplicates
            foreach (ModViz3DNode mr in checkunique)
            {
                if (mr.logical_representation.unique)
                {
                    if (contains_unique_node(mr.logical_representation))
                    {
                        mr.delete(true);
                    }
                    //need to readd
                    unique_nodes.Add(mr.logical_representation);

                }
            }
            blockconnupdates = false;
            //generates all the connections
            regenerate_connections(false, hascps);




        }

        internal bool collapseSelectionToContainerNode(out string msg, out int nGI, string coco = "Container")
        {
            if (PUPPIDebugger.debugenabled)
            {
                PUPPIDebugger.log("Started " + utils.StringConstants.collapselection);
            }
            nGI = -1;
            msg = "";
            if (selstacks.Count == 0) return false;
            //figure out if any nodes output to both inside and outside the selection
            Dictionary<string, ModViz3DNode> cs = new Dictionary<string, ModViz3DNode>();
            Dictionary<string, ModViz3DNode> ncs = new Dictionary<string, ModViz3DNode>(stacks);
            foreach (string s in selstacks)
            {
                cs.Add(s, stacks[s]);
                ncs.Remove(s);
            }
            foreach (ModViz3DNode mi in cs.Values)
            {
                if (mi.logical_representation.canBeInContainer == false)
                {

                    msg = mi.logical_representation.name + " cannot be in a container";
                    if (PUPPIDebugger.debugenabled)
                    {
                        PUPPIDebugger.log("Failed " + utils.StringConstants.collapselection + " " + msg);
                    }
                    return false;
                }
                for (int i = 0; i < mi.logical_representation.outputs.Count; i++)
                {
                    List<ModViz3DNode> di = mi.getAllNodesDownstream(i);
                    bool sc = false;
                    bool nsc = false;
                    foreach (ModViz3DNode zi in di)
                    {
                        if (cs.ContainsValue(zi)) sc = true;
                        if (ncs.ContainsValue(zi)) nsc = true;
                        if (sc && nsc) { msg = "There is at least one output which connects boths inside and outside the selection. Cannot collapse selection. Use Pass Through nodes to create additional outputs to avoid this issue."; return false; }

                    }
                }

            }
            canvasabouttochange();
            string os = my_old_pc_status;
            updatemyPCStatus("Please wait,collapsing " + cs.Count + " nodes to container...");

            selstacks.Clear();
            string em = "";
            PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer peu = collapseToContainer(cs, out em, coco);
            if (peu == null)
            {
                if (PUPPIDebugger.debugenabled)
                {
                    PUPPIDebugger.log("Failed " + utils.StringConstants.collapselection);
                }
                //nothing created with these
                if (em != "empty" && em != "circularity")
                    undome();
                if (em == "empty")
                {
                    msg = "Empty container node!";
                }
                else
                    if (em == "circularity")
                {
                    msg = "Circular connection through container, try different nodes";
                }
                else
                {
                    msg = em;
                }

                updatemyPCStatus(os);
                return false;
            }
            nGI = peu.GUID;
            updatemyPCStatus(os);
            if (PUPPIDebugger.debugenabled)
            {
                PUPPIDebugger.log("Completed " + utils.StringConstants.collapselection);
            }
            return true;
        }
        //looks through all 
        internal bool checkConAn(PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer p)
        {
            List<string> reco = new List<string>();
            foreach (string ss in p.PMsmOutMap)
            {

                char[] ser = { '_' };
                string[] s = ss.Split(ser);
                PUPPIModule pi = p.PMsubModules[Convert.ToInt16(s[1])];
                int outputPIIndex = Convert.ToInt32(s[2]);
                try
                {
                    ModViz3DNode me = stacks[pi.GUID.ToString()];
                    //disconnect all nodes connected to output
                    List<ModViz3DNode> l = me.getAllNodesDownstream(outputPIIndex);

                    foreach (ModViz3DNode m in l)
                    {
                        PUPPIModule pml = m.logical_representation;
                        foreach (string ssa in p.PMsmInMap)
                        {


                            string[] sa = ssa.Split(ser);
                            PUPPIModule pia = p.PMsubModules[Convert.ToInt16(sa[1])];
                            PUPPIModule ppp = null;
                            int inputPIIndex = Convert.ToInt32(sa[2]);
                            try
                            {

                                ppp = pia.inputs[inputPIIndex].module;

                            }
                            catch
                            {
                                ppp = null;
                            }
                            if (ppp != null)
                            {
                                if (pml.check_ancestry(pml, ppp)) return true;
                            }
                        }
                    }
                }
                catch
                { }
            }



            return false;
        }
        PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer collapseToContainer(Dictionary<string, ModViz3DNode> colstacks, out string errmsg, string cocaption = "Container")
        {
            // string sss = updatemyPCStatus("Collapsing to container...");
            errmsg = "";
            List<PUPPIModule> cT = new List<PUPPIModule>();
            //get the modules to put inside this container
            foreach (ModViz3DNode m in colstacks.Values)
            {
                //if (m.logical_representation.cleancap == "" && m.displayname!="") m.logical_representation.cleancap = m.displayname;
                if (m.displayname != "") m.logical_representation.cleancap = m.displayname;
                cT.Add(m.logical_representation);

            }
            if (cT.Count == 0) return null;
            PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer p = new PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer(cT);
            if (checkConAn(p))
            {
                errmsg = "circularity";
                // sss = updatemyPCStatus(sss); 
                return null;

            }
            if (p.PMsubModules.Count == 0)
            {
                errmsg = "empty";
                //  sss = updatemyPCStatus(sss);
                return null;
            }
            blockconnupdates = true;
            //figure out what the unsatisfied inputs and outputs are connected to
            Dictionary<int, PUPPIInParameter> recoi = new Dictionary<int, PUPPIInParameter>();
            //disconnect those inputs and outputs
            foreach (string ss in p.PMsmInMap)
            {

                char[] ser = { '_' };
                string[] s = ss.Split(ser);
                PUPPIModule pi = p.PMsubModules[Convert.ToInt16(s[1])];
                int inputPIIndex = Convert.ToInt32(s[2]);
                try
                {
                    PUPPIInParameter pih = new PUPPIInParameter();
                    pih.module = pi.inputs[inputPIIndex].module;
                    pih.outParIndex = pi.inputs[inputPIIndex].outParIndex;
                    pih.isoptional = pi.inputs[inputPIIndex].isoptional;
                    pih.inputAutomaticListMode = pi.inputs[inputPIIndex].inputAutomaticListMode;
                    recoi.Add(Convert.ToInt16(s[0]), pih);
                    ModViz3DNode me = stacks[pi.GUID.ToString()];
                    me.disconnectinput(inputPIIndex);

                }
                catch (Exception exy)
                {
                    errmsg = exy.ToString();
                    //MessageBox.Show(exy.ToString());
                }

            }
            //GUID_input_output
            List<string> reco = new List<string>();
            foreach (string ss in p.PMsmOutMap)
            {

                char[] ser = { '_' };
                string[] s = ss.Split(ser);
                PUPPIModule pi = p.PMsubModules[Convert.ToInt16(s[1])];
                int outputPIIndex = Convert.ToInt32(s[2]);
                try
                {
                    ModViz3DNode me = stacks[pi.GUID.ToString()];
                    //disconnect all nodes connected to output
                    List<ModViz3DNode> l = me.getAllNodesDownstream(outputPIIndex);
                    bool ff = false;
                    foreach (ModViz3DNode m in l)
                    {
                        PUPPIModule pml = m.logical_representation;
                        int iii = 0;
                        foreach (PUPPIInParameter pmli in pml.inputs)
                        {

                            if (pmli.module == pi)
                            {
                                m.disconnectinput(iii);
                                // reco.Add(m.nodeGUID.ToString() + "_" + iii.ToString() + "_" + outputPIIndex.ToString());
                                reco.Add(m.nodeGUID.ToString() + "_" + iii.ToString() + "_" + s[0]);
                                ff = true;
                                break;
                            }
                            iii++;
                            //if (ff == true) break;
                        }
                    }
                }
                catch (Exception exy)
                {
                    errmsg = exy.ToString();
                    // MessageBox.Show(exy.ToString());
                }
            }



            //delete visuals for nodes and connections
            foreach (PUPPIModule pi in p.PMsubModules)
            {
                try
                {
                    ModViz3DNode me = stacks[pi.GUID.ToString()];
                    for (int iiii = 0; iiii < pi.inputs.Count; iiii++)
                    {
                        me.deleteInputConnectionVisual(iiii);
                    }
                }
                catch (Exception exy)
                {
                    errmsg = exy.ToString();
                    //MessageBox.Show(exy.ToString());
                }
            }
            //to place node at average position of collapsed nodes
            double ax = 0;
            double ay = 0;
            foreach (PUPPIModule pi in p.PMsubModules)
            {
                try
                {
                    ModViz3DNode me = stacks[pi.GUID.ToString()];
                    ax += me.myposition.X;
                    ay += me.myposition.Y;
                    me.deletevisuals();

                    stacks.Remove(pi.GUID.ToString());

                }
                catch (Exception exy)
                {
                    errmsg = exy.ToString();
                    ///MessageBox.Show(exy.ToString());
                }
            }
            ax /= p.PMsubModules.Count;
            ay /= p.PMsubModules.Count;
            //render node
            addAContainerNodeToTheCanvas(new Point3D(ax, ay, 0), p);
            ModViz3DNode nc = null;
            try
            {
                nc = stacks[p.GUID.ToString()];

            }
            catch (Exception Exy)
            {
                nc = null;
            }
            if (nc == null)
            {
                blockconnupdates = false;
                errmsg = "No container created";
                // sss = updatemyPCStatus(sss); 
                return null;
            }
            //connect inputs and outputs
            foreach (KeyValuePair<int, PUPPIInParameter> pao in recoi)
            {
                int iii = pao.Key;
                PUPPIInParameter gao = pao.Value;
                if (gao.module != null)
                {
                    bool b = connectNode2Node(gao.module.GUID, gao.outParIndex, p.GUID, iii, false);
                    if (!b)
                    {
                        errmsg = "Failed to reconnect inputs";
                        blockconnupdates = false;
                        //    sss = updatemyPCStatus(sss);
                        return null;
                    }
                }


            }
            foreach (string sasa in reco)
            {
                char[] ser = { '_' };
                string[] sa = sasa.Split(ser, StringSplitOptions.None);
                bool b = connectNode2Node(p.GUID, Convert.ToInt16(sa[2]), Convert.ToInt16(sa[0]), Convert.ToInt16(sa[1]), false);
                if (!b)
                {
                    blockconnupdates = false;
                    errmsg = "Failed to reconnect outputs";
                    // sss = updatemyPCStatus(sss);
                    return null;
                }
            }
            //to view canvas when pausing code
            // Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);

            blockconnupdates = false;
            regenerate_connections(false);
            // p.doIprocess();

            p.userdoIprocess();
            nc.displayname = cocaption;
            nc.update_caption();
            // sss = updatemyPCStatus(sss);
            return p;
        }



        //fits roots from a specified stack onto a grid of blocks to make it quicker
        void fitrootsblocks(Dictionary<string, ModViz3DNode> fitstacks)
        {
            //get the blocks
            List<BlockOfNodes> lb = BlockOfNodes.splitintoblocks(fitstacks);
            //fit the roots inside blocks
            for (int i = 0; i < lb.Count; i++)
            {
                lb[i].fitblockroots();
            }
            //now fit the blocks
            d2collisionmodel levelredo = new d2collisionmodel();
            for (int i = 0; i < lb.Count; i++)
            {
                //pad them so we get the streets
                levelredo.footprints.Add(lb[i].boundingbox.padme(PUPPIGUISettings.nodeSpacing));
            }
            levelredo.recompute(0);
            //now move blocks
            for (int i = 0; i < lb.Count; i++)
            {
                lb[i].movewholeblock(levelredo.footprints[i].rectcenter());
            }


        }



        //adds a new batch of stacks for import and maybe area copy paste
        void addmorestacks(Dictionary<string, ModViz3DNode> newstacks, bool fitall = false, double xadd = 999999.0, double yadd = 999999.0)
        {
            blockconnupdates = true;
            //bool retryme = true;
            int numtries = 0;
            //existing bounding box
            Rect3D bobo = bbox();
            //get minimum and maximum position on new stacks
            double minx = 100000000;
            double miny = 100000000;
            double maxx = -100000000;
            double maxy = -100000000;
            foreach (ModViz3DNode nnode in newstacks.Values)
            {

                if (nnode.parent == null)
                {
                    if (nnode.myposition.X < minx) minx = nnode.myposition.X;
                    if (nnode.myposition.Y < miny) miny = nnode.myposition.Y;
                    if (nnode.myposition.X > maxx) maxx = nnode.myposition.X;
                    if (nnode.myposition.Y > maxy) maxy = nnode.myposition.Y;
                }
            }
            //extraspace 
            double extrax = maxx - minx;
            double extray = maxy - miny;
            //put them in

            //render elements
            //while (retryme == true && numtries <= newstacks.Count)
            //{
            //retryme = false;
            //new dict with insterted stacks and new keys
            //Dictionary<string, ModViz3DNode> newnewstacks=new Dictionary<string,ModViz3DNode>();
            //update index
            int startindex = ModViz3DNode.GUIDcount + 1;
            foreach (ModViz3DNode newnode in newstacks.Values)
            {

                //newnode.nodeGUID = startindex + newnode.nodeGUID;
                //newnode.logical_representation.GUID = startindex + newnode.nodeGUID;
                //bottom node
                if (newnode.parent == null) // || newnode.parent.myself!=null    )
                {
                    if (xadd == 999999.0 && yadd == 999999.0)
                    {
                        newnode.myposition.X = bobo.Location.X + bobo.SizeX + PUPPIGUISettings.nodeSpacing + newnode.myposition.X - minx;
                        newnode.myposition.Y = bobo.Location.Y + bobo.SizeY + PUPPIGUISettings.nodeSpacing + newnode.myposition.Y - miny;
                    }
                    else
                    {
                        newnode.myposition.X = xadd + PUPPIGUISettings.nodeSpacing + newnode.myposition.X - minx;
                        newnode.myposition.Y = yadd + PUPPIGUISettings.nodeSpacing + newnode.myposition.Y - miny;
                        fitall = true;

                    }
                    newnode.renderme();

                    //make sure coords in node spacing

                    //render its children recursively so we don't get null in bottom pyramid
                    newnode.renderchildren();


                }

                //increase GUID to make sure we don't get errors when we make new nodes
                if (newnode.nodeGUID >= ModViz3DNode.GUIDcount)
                {
                    ModViz3DNode.GUIDcount = newnode.nodeGUID + 1;
                }
                stacks.Add(newnode.nodeGUID.ToString(), newnode);


                //newnewstacks.Add(newnode.nodeGUID.ToString(), newnode);  

            }


            // numtries++;
            //}     //need to update captions and conenctors

            ////update node connectors
            //foreach (ModViz3DNode newnode in newstacks.Values)
            //{
            //    //also update input node guid 

            //    newnode.update_inouts();
            //}

            //need to fit roots too
            if (newstacks.Count > 0)
            {


                //call fit roots on all
                if (fitall)
                {
                    //try this way hope faster
                    // fitrootsblocks(stacks); 
                    ////fitallroots(newstacks); 
                    foreach (ModViz3DNode mr in newstacks.Values)
                    {
                        if (mr.parent == null && mr.logical_representation != null && mr.logical_representation.inputs.Count == 0 && mr.logical_representation.outputs.Count == 0)
                        {
                            mr.fitroots(stacks);
                        }

                        // if (mr.parent == null) mr.fitroots(stacks);

                    }
                }
                update_grid();
            }
            //need to make this as a list in order to be able to delete
            List<ModViz3DNode> checkunique = newstacks.Values.ToList<ModViz3DNode>();
            //to include unique nodes and for legacy purposes delete the duplicates
            foreach (ModViz3DNode mr in checkunique)
            {
                if (mr.logical_representation.unique)
                {
                    if (contains_unique_node(mr.logical_representation))
                    {
                        mr.delete(true);
                    }
                    //need to readd
                    unique_nodes.Add(mr.logical_representation);

                }
            }

            blockconnupdates = false;
            //generates all the connections
            regenerate_connections(false);

        }
        //deletes and recreates all connections
        internal void regenerate_connections(bool forcerun, Dictionary<string, connectorpath> mycs = null)
        {
            //   stopMouseEv(); 
            //disable processing
            PUPPIruntimesettings.processyesno = false;
            //reset number of connections redrawn
            PUPPIDEBUG.PUPPIDebugger.conns_Redrawn = 0;
            if (PUPPIDebugger.debugenabled)
            {
                PUPPIDebugger.log(utils.StringConstants.beginregenerateconnectionsdebuglog);
            }

            //            string os = my_old_pc_status;
            //          updatemyPCStatus("Please wait,regenerating connections...");
            //finally, connect nodes visually with connector paths
            //delete all connections from the window too
            ModViz3DNode fr = null;
            foreach (ModViz3DConn mvc in connpaths.Values)
            {
                try
                {
                    //  hv.Children.Remove(mvc.myself);
                    //mvc.sourcenode.NodeChanged -= mvc.nodechanged;
                    mvc.deletevisual();

                }
                catch (Exception exy)
                {

                }

            }
            //foreach (ModViz3DNode co in stacks.Values  )
            //{
            //    if (co.parent==null )
            //    {
            //        fr = co;
            //        break;
            //    }
            //}
            //if (fr!=null) fr.fitroots(stacks); 
            connpaths.Clear();
            initconn_matrices();

            //to view canvas when pausing code
            //Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);


            foreach (ModViz3DNode newnode in stacks.Values)
            {

                //reset connector output
                for (int i = 0; i < newnode.logical_representation.outputs.Count; i++)
                {
                    newnode.vizoutputs[i].outboundconns.Clear();
                }
            }

            foreach (ModViz3DNode newnode in stacks.Values)
            {

                int ii = 0;

                foreach (PUPPIInParameter pinp in newnode.logical_representation.inputs)
                {
                    if (pinp != null && pinp.module != null)
                    {

                        //create the visual representation of the connector
                        string cnf = "conn_" + pinp.module.GUID.ToString() + "_" + pinp.outParIndex.ToString() + "_" + newnode.nodeGUID.ToString() + "_" + ii.ToString();

                        ModViz3DConn newconnenctor = new ModViz3DConn(stacks[pinp.module.GUID.ToString()], pinp.outParIndex, newnode, ii, cnf);
                        if (mycs == null)
                        {
                            if (PUPPIGUISettings.useMultiThreading)
                                newconnenctor.drawmethread();
                            else newconnenctor.drawme();
                        }
                        else
                        {

                            if (mycs.ContainsKey(cnf))
                            {
                                newconnenctor.drawme(mycs[cnf]);
                            }
                            else
                            {
                                newconnenctor.drawme();
                            }

                        }
                        //if this has been deleted by a disconenct then the key is still in the dictionary
                        if (connpaths.ContainsKey(newconnenctor.visualGUID) == true)
                        {
                            connpaths[newconnenctor.visualGUID] = newconnenctor;
                        }
                        else
                        {
                            connpaths.Add(newconnenctor.visualGUID, newconnenctor);
                        }
                        newnode.vizinputs[ii].myconnector = newconnenctor;
                        newnode.vizinputs[ii].myinput = pinp;

                    }
                    ii++;

                }

            }
            if (forcerun)
            {
                PUPPIruntimesettings.processyesno = true;

            }
            else
            {
                PUPPIruntimesettings.processyesno = PUPPIruntimesettings.liveupdate;
            }
            //to view canvas when pausing code
            //Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
            //  resumeMouseEv();
            runPUPPIprogram();

            //to view canvas when pausing code
            //Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
            // updatemyPCStatus(os);
            PUPPIruntimesettings.processyesno = PUPPIruntimesettings.liveupdate;
            if (PUPPIDebugger.debugenabled)
            {
                PUPPIDebugger.log(utils.StringConstants.endregenerateconnectionsdebuglog);
                PUPPIDebugger.log(PUPPIDebugger.conns_Redrawn.ToString() + utils.StringConstants.connectionsredrawndebuglog);
            }

        }

        //if we have a dictionary
        //internal void redraw_dconnections(bool forcerun,Dictionary<string,connectorpath > mycs )
        //{

        //    PUPPIruntimesettings.processyesno = false;
        //    //reset number of connections redrawn
        //    PUPPIDEBUG.PUPPIDebugger.conns_Redrawn = 0;
        //    if (PUPPIDebugger.debugenabled)
        //    {
        //        PUPPIDebugger.log(utils.StringConstants.beginregenerateconnectionsdebuglog);
        //    }

        //    ModViz3DNode fr = null;
        //    foreach (ModViz3DConn mvc in connpaths.Values)
        //    {
        //        try
        //        {

        //            mvc.deletevisual();

        //        }
        //        catch (Exception exy)
        //        {

        //        }

        //    }

        //    connpaths.Clear();
        //    initconn_matrices();




        //    foreach (ModViz3DNode newnode in stacks.Values)
        //    {

        //        //reset connector output
        //        for (int i = 0; i < newnode.logical_representation.outputs.Count; i++)
        //        {
        //            newnode.vizoutputs[i].outboundconns.Clear();
        //        }
        //    }

        //    foreach (ModViz3DNode newnode in stacks.Values)
        //    {

        //        int ii = 0;

        //        foreach (PUPPIInParameter pinp in newnode.logical_representation.inputs)
        //        {
        //            if (pinp != null && pinp.module != null)
        //            {

        //                //create the visual representation of the connector
        //                string cnf = "conn_" + pinp.module.GUID.ToString() + "_" + pinp.outParIndex.ToString() + "_" + newnode.nodeGUID.ToString() + "_" + ii.ToString();

        //                ModViz3DConn newconnenctor = new ModViz3DConn(stacks[pinp.module.GUID.ToString()], pinp.outParIndex, newnode, ii, cnf);



        //                if (PUPPIGUISettings.useMultiThreading)
        //                    newconnenctor.drawmethread();
        //                else
        //                {   
        //                    if ()
        //                    newconnenctor.drawme();
        //                }
        //                //if this has been deleted by a disconenct then the key is still in the dictionary
        //                if (connpaths.ContainsKey(newconnenctor.visualGUID) == true)
        //                {
        //                    connpaths[newconnenctor.visualGUID] = newconnenctor;
        //                }
        //                else
        //                {
        //                    connpaths.Add(newconnenctor.visualGUID, newconnenctor);
        //                }
        //                newnode.vizinputs[ii].myconnector = newconnenctor;
        //                newnode.vizinputs[ii].myinput = pinp;

        //            }
        //            ii++;

        //        }

        //    }
        //    if (forcerun)
        //    {
        //        PUPPIruntimesettings.processyesno = true;

        //    }
        //    else
        //    {
        //        PUPPIruntimesettings.processyesno = PUPPIruntimesettings.liveupdate;
        //    }

        //    runPUPPIprogram();



        //    PUPPIruntimesettings.processyesno = PUPPIruntimesettings.liveupdate;
        //    if (PUPPIDebugger.debugenabled)
        //    {
        //        PUPPIDebugger.log(utils.StringConstants.endregenerateconnectionsdebuglog);
        //        PUPPIDebugger.log(PUPPIDebugger.conns_Redrawn.ToString() + utils.StringConstants.connectionsredrawndebuglog);
        //    }

        //}
        //executes the program for certain types of actions not in live update
        //might need to be made faster

        internal void resetSTOF()
        {
            foreach (ModViz3DNode newnode in stacks.Values)
            {
                if (newnode.logical_representation != null)
                {
                    if (newnode.logical_representation.numbercalls > 0)
                    {
                        newnode.logical_representation.numbercalls = 1;
                    }
                }
            }
        }

        internal void runPUPPIprogram()
        {
            //  stopMouseEv(); 
            //string ss = updatemyPCStatus("Running...");
            if (PUPPIDebugger.debugenabled)
            {
                PUPPIDebugger.log(utils.StringConstants.startedfullprogramrundebuglog);
            }

            //prevent stack overflow
            resetSTOF();

            //update to hold downstream processing until upstream complete
            foreach (ModViz3DNode newnode in stacks.Values)
            {
                int z = newnode.logical_representation.mandinputs();
                if (z == newnode.logical_representation.inputs.Count)
                {
                    newnode.logical_representation.upstreamleft = z;
                }
                //figure out what is connected
                else
                {
                    newnode.logical_representation.upstreamleft = 0;
                    for (int imi = 0; imi < newnode.logical_representation.inputs.Count; imi++)
                    {
                        if (newnode.logical_representation.inputs[imi].module != null)
                        {
                            newnode.logical_representation.upstreamleft++;
                        }
                    }
                }

            }
            foreach (ModViz3DNode newnode in stacks.Values)
            {
                //only process when we have a starter module - or modules with no mandatory inputs
                if (newnode.vizinputs.Count == 0)
                {

                    newnode.logical_representation.doIprocess();
                    //to view canvas when pausing code
                    // Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);

                }
                //check empty mandinpus
                else
                {
                    int z = newnode.logical_representation.mandinputs();
                    if (z == 0)
                    {
                        bool runme = true;
                        //check connected
                        for (int imi = 0; imi < newnode.logical_representation.inputs.Count; imi++)
                        {
                            if (newnode.logical_representation.inputs[imi].module != null)
                            {
                                runme = false;
                                break;
                            }
                        }
                        if (runme) newnode.logical_representation.doIprocess();
                    }


                }
                // newnode.update_inouts();
            }
            if (PUPPIDebugger.debugenabled)
            {
                PUPPIDebugger.log(utils.StringConstants.endedfullprogramrundebuglog);
            }
            // ss = updatemyPCStatus(ss);
            //  resumeMouseEv(); 
        }


        //adds node and children to stacks array
        void addstacktostack(ModViz3DNode stack2add)
        {
            ModViz3DNode testf = null;
            try
            {
                testf = stacks[stack2add.nodeGUID.ToString()];
            }
            catch
            {
                testf = null;
            }
            if (testf != null)
            {
                //throw new Exception("node id exists "+stack2add.nodeGUID.ToString()) ;
                //increase guid
                stack2add.nodeGUID = ModViz3DNode.GUIDcount;
                ModViz3DNode.GUIDcount++;
            }
            stacks.Add(stack2add.nodeGUID.ToString(), stack2add);
            if (stack2add.nodeGUID >= ModViz3DNode.GUIDcount) ModViz3DNode.GUIDcount = stack2add.nodeGUID + 1;
            foreach (ModViz3DNode ch in stack2add.childs)
            {
                addstacktostack(ch);
            }
        }
        internal event EventHandler newCanvasEvent;
        internal event EventHandler clickedCanvasEvent;
        // internal event EventHandler droppedCanvasEvent;
        //clears everything,fresh canvas
        internal void newcanvas(bool nP = false)
        {
            if (issaved == false && nP == false)
            {
                MessageBoxResult m = MessageBox.Show("You have unsaved changes.", "Continue?", MessageBoxButton.OKCancel);

                if (m == MessageBoxResult.Cancel)
                {
                    return;
                }
            }

            if (newCanvasEvent != null) newCanvasEvent(this, EventArgs.Empty);
            //Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
            clearobjects(true);
            if (PUPPIDebugger.debugenabled)
            {
                PUPPIDebugger.log("new canvas");
            }
            string ss = updatemyPCStatus("New Canvas");
            fileCurLdd = "";

        }
        internal event EventHandler loadCanvasEvent;
        //open and save internal functions called from menu
        internal void openfile(string fTO = "")
        {

            if (issaved == false && fTO == "")
            {
                MessageBoxResult m = MessageBox.Show("You have unsaved changes.", "Continue?", MessageBoxButton.OKCancel);

                if (m == MessageBoxResult.Cancel)
                {
                    return;
                }
            }

            if (loadCanvasEvent != null) loadCanvasEvent(this, EventArgs.Empty);


            // Show open file dialog box
            Nullable<bool> result;
            if (fTO == "")
                result = dlg.ShowDialog();
            else
                result = true;
            // Process open file dialog box results 
            if (result == true)
            {
                //set property to keep between runs
                if (fTO == "")
                {
                    PUPPI.Properties.Settings.Default.savedfolder = System.IO.Path.GetDirectoryName(dlg.FileName);
                    PUPPI.Properties.Settings.Default.Save();
                }
                // Open document 
                string filename = "";
                if (fTO == "")
                    filename = dlg.FileName;
                else
                    filename = fTO;

                fileCurLdd = filename;
                string os = updatemyPCStatus("Loading " + filename + " ...");
                if (PUPPIDebugger.debugenabled)
                {
                    PUPPIDebugger.log(utils.StringConstants.startedopeningfiledebuglog + filename);
                }
                PUPPIruntimesettings.check_all_security();
                Dictionary<string, ModViz3DNode> newstacks = new Dictionary<string, ModViz3DNode>();
                try
                {
                    bool slc = PUPPIruntimesettings.liveupdate;
                    //Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
                    clearobjects(true);
                    //makes sure it is not updating live if it doesn't have to
                    // if (slc == false) slupd8(); 
                    readxml(filename, out newstacks, true);

                }
                catch (Exception exy)
                {
                    if (fTO == "")
                        System.Windows.Forms.MessageBox.Show("Error loading file!: \n" + exy.ToString());
                    else if (PUPPIDebugger.debugenabled)
                    {
                        PUPPIDebugger.log("Error loading file!: \n" + exy.ToString());
                    }
                    os = updatemyPCStatus(os);
                    return;
                }
                pushnewstacks(newstacks, true);
                if (PUPPIDebugger.debugenabled)
                {
                    PUPPIDebugger.log("finished opening file " + filename);
                }
                dlg.InitialDirectory = null;
                os = updatemyPCStatus(filename);
            }


        }


        //exports a 3d snapshot
        internal void exportcanvassnapshot(string eP = "")
        {
            Nullable<bool> result = true;

            Microsoft.Win32.SaveFileDialog d = new Microsoft.Win32.SaveFileDialog();
            string filename = eP;
            if (eP == "")
            {
                d.Filter = Exporters.Filter;
                d.DefaultExt = Exporters.DefaultExtension;
                result = d.ShowDialog();
                filename = d.FileName;
            }
            if (result == true)
            {
                try
                {
                    Viewport3DHelper.Export(hv.Viewport, filename);
                }
                catch (Exception exy)
                {
                    if (eP == "")
                    {
                        MessageBox.Show("Failed to export canvas to file " + filename);
                    }
                    else
                    {
                        if (PUPPIDebugger.debugenabled)
                        {
                            PUPPIDebugger.log("Failed to export canvas to file " + exy.ToString());
                        }
                    }

                }



            }
        }
        internal event EventHandler importCanvasEvent;
        internal void importfile(string iF = "")
        {

            if (importCanvasEvent != null) importCanvasEvent(this, EventArgs.Empty);
            // Show open file dialog box
            Nullable<bool> result = true;

            if (iF == "") result = dlg.ShowDialog();

            // Process open file dialog box results 
            if (result == true)
            {

                //set property to keep between runs

                if (iF == "")
                {
                    PUPPI.Properties.Settings.Default.savedfolder = System.IO.Path.GetDirectoryName(dlg.FileName);
                    PUPPI.Properties.Settings.Default.Save();
                }
                string curcap = setliveupdate.Content.ToString();
                setliveupdate.Content = "Loading...";


                // Open document 
                string filename = iF;

                if (iF == "") filename = dlg.FileName;
                string ss = updatemyPCStatus("Importing " + filename + " ...");
                if (PUPPIDebugger.debugenabled)
                {
                    PUPPIDebugger.log("started importing file " + filename);
                }
                Dictionary<string, ModViz3DNode> newstacks = new Dictionary<string, ModViz3DNode>();
                try
                {
                    //to be able to undo this
                    canvasabouttochange();
                    readxml(filename, out newstacks, true, ModViz3DNode.GUIDcount + 1);

                }
                catch (Exception exy)
                {
                    if (iF == "")
                        System.Windows.Forms.MessageBox.Show("Error importing file!: \n" + exy.ToString());
                    else
                    {
                        if (PUPPIDebugger.debugenabled)
                        {
                            PUPPIDebugger.log("Error importing file!: \n" + exy.ToString());
                        }
                    }
                    setliveupdate.Content = curcap;
                    return;
                }
                addmorestacks(newstacks, true);
                if (PUPPIDebugger.debugenabled)
                {
                    PUPPIDebugger.log("finished importing file " + filename);
                }
                if (iF == "")
                    dlg.InitialDirectory = null;
                setliveupdate.Content = curcap;
                ss = updatemyPCStatus(ss);
            }

        }
        //as a container
        internal void importfileAC(string iF = "")
        {

            if (importCanvasEvent != null) importCanvasEvent(this, EventArgs.Empty);
            // Show open file dialog box
            Nullable<bool> result = true;

            if (iF == "") result = dlg.ShowDialog();

            // Process open file dialog box results 
            if (result == true)
            {

                //set property to keep between runs

                if (iF == "")
                {
                    PUPPI.Properties.Settings.Default.savedfolder = System.IO.Path.GetDirectoryName(dlg.FileName);
                    PUPPI.Properties.Settings.Default.Save();
                }
                string curcap = setliveupdate.Content.ToString();
                setliveupdate.Content = "Loading...";


                // Open document 
                string filename = iF;

                if (iF == "") filename = dlg.FileName;
                string ss = updatemyPCStatus("Importing " + filename + " as container ...");
                if (PUPPIDebugger.debugenabled)
                {
                    PUPPIDebugger.log("started importing file as container " + filename);
                }
                Dictionary<string, ModViz3DNode> newstacks = new Dictionary<string, ModViz3DNode>();
                try
                {
                    //to be able to undo this
                    canvasabouttochange();
                    readxml(filename, out newstacks, true, ModViz3DNode.GUIDcount + 1);

                }
                catch (Exception exy)
                {
                    if (iF == "")
                        System.Windows.Forms.MessageBox.Show("Error importing file as container!: \n" + exy.ToString());
                    else
                    {
                        if (PUPPIDebugger.debugenabled)
                        {
                            PUPPIDebugger.log("Error importing file as container!: \n" + exy.ToString());
                        }
                    }
                    setliveupdate.Content = curcap;
                    return;
                }
                string msg = "";
                foreach (ModViz3DNode mi in newstacks.Values)
                {
                    if (mi.logical_representation.canBeInContainer == false)
                    {

                        msg = mi.logical_representation.name + " cannot be in a container";
                        if (PUPPIDebugger.debugenabled)
                        {
                            PUPPIDebugger.log("Failed " + utils.StringConstants.collapselection + " " + msg);
                        }
                        if (iF == "") MessageBox.Show(msg);
                        return;
                    }
                    //for (int i = 0; i < mi.logical_representation.outputs.Count; i++)
                    //{
                    //    List<ModViz3DNode> di = mi.getAllNodesDownstream(i);
                    //    bool sc = false;
                    //    bool nsc = false;
                    //    foreach (ModViz3DNode zi in di)
                    //    {
                    //        if (cs.ContainsValue(zi)) sc = true;
                    //        if (ncs.ContainsValue(zi)) nsc = true;
                    //        if (sc && nsc) { msg = "There is at least one output which connects boths inside and outside the selection. Cannot collapse selection. Use Pass Through nodes to create additional outputs to avoid this issue."; return false; }

                    //    }
                    //}

                }
                string fwe = System.IO.Path.GetFileNameWithoutExtension(filename);
                if (fwe == "") fwe = "Container";
                string em = "";
                PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer peu = collapseToContainer(newstacks, out em, fwe);
                if (peu == null)
                {
                    if (PUPPIDebugger.debugenabled)
                    {
                        PUPPIDebugger.log("Failed " + utils.StringConstants.collapselection);
                    }
                    //nothing created with these
                    if (em != "empty" && em != "circularity")
                        undome();
                    if (em == "empty")
                    {
                        msg = "Empty container node!";
                    }
                    else
                        if (em == "circularity")
                    {
                        msg = "Circular connection through container, try different nodes";
                    }
                    else
                    {
                        msg = em;
                    }
                    if (iF == "") MessageBox.Show(msg);
                    return;
                }

                if (PUPPIDebugger.debugenabled)
                {
                    PUPPIDebugger.log("Completed " + utils.StringConstants.collapselection);
                }

                if (PUPPIDebugger.debugenabled)
                {
                    PUPPIDebugger.log("finished importing file as container " + filename);
                }
                if (iF == "")
                    dlg.InitialDirectory = null;
                setliveupdate.Content = curcap;
                ss = updatemyPCStatus(ss);
            }

        }

        internal void saveas(List<ModViz3DNode> nts, bool fullsave = true, string sT = "")
        {


            // Show save file dialog box
            Nullable<bool> result = true;
            if (sT == "") result = dlsave.ShowDialog();

            // Process save file dialog box results 
            if (result == true)
            {
                //set property to keep between runs
                PUPPI.Properties.Settings.Default.savedfolder = System.IO.Path.GetDirectoryName(dlsave.FileName);
                PUPPI.Properties.Settings.Default.Save();
                // Save document 
                string filename = sT;
                if (filename == "") filename = dlsave.FileName;
                PUPPIruntimesettings.check_all_security();
                try
                {
                    string nott = "";
                    savexml(filename, nts, true, out nott);
                    if (fullsave) issaved = true;
                    if (issaved)
                    {
                        string ss = updatemyPCStatus(filename);
                        fileCurLdd = filename;
                    }
                }
                catch (Exception exy)
                {
                    //interactive
                    if (sT == "")
                        System.Windows.Forms.MessageBox.Show("Error saving file: " + exy.ToString());
                    else
                    {
                        if (PUPPIDebugger.debugenabled)
                        {
                            PUPPIDebugger.log("Error saving file: " + exy.ToString());
                        }
                    }
                }
                if (sT == "")
                {
                    dlsave.InitialDirectory = null;
                }
            }
        }
        //exports the selected nodes
        internal void export_selected_nodes(string sT = "")
        {
            List<ModViz3DNode> e = new List<ModViz3DNode>();
            if (selstacks.Count > 0)
            {
                foreach (string s in selstacks)
                {
                    ModViz3DNode g = null;
                    stacks.TryGetValue(s, out g);
                    if (g != null) e.Add(g);

                }
                if (e.Count > 0)
                    saveas(e, false, sT);
            }
        }

        //exports the selected nodes
        internal void delete_selected_nodes()
        {
            if (selstacks.Count > 0)
            {
                canvasabouttochange();
                string os = my_old_pc_status;
                updatemyPCStatus("Please wait,deleting " + selstacks.Count + " selected nodes...");
                PUPPIruntimesettings.processyesno = false;
                blockconnupdates = true;
                List<ModViz3DNode> e = new List<ModViz3DNode>();
                while (selstacks.Count > 0)
                {
                    ModViz3DNode d = null;
                    stacks.TryGetValue(selstacks[0], out d);
                    if (d != null)
                    {
                        while (d.parent != null && selstacks.Contains(d.parent.nodeGUID.ToString())) d = d.parent;
                        d.deletestack();
                    }
                }
                blockconnupdates = false;
                update_all_connectors();

                PUPPIruntimesettings.processyesno = PUPPIruntimesettings.liveupdate;

                runPUPPIprogram();
                updatemyPCStatus(os);

            }
        }


        internal void set_hidden_selected_nodes_on_locked_canvas(bool lo)
        {
            for (int i = 0; i < selstacks.Count; i++)
            {
                ModViz3DNode d = null;
                stacks.TryGetValue(selstacks[i], out d);
                if (d != null)
                {
                    d.setNodeHiddenLockedCanvasStatus(lo);
                    //d.hiddenOnLockedCanvas = lo;
                    //List<ModViz3DNode> dc=new List<ModViz3DNode>();
                    //d.getalllevelschildren(dc); 
                    //foreach (ModViz3DNode dcc in dc)
                    //{
                    //    dcc.hiddenOnLockedCanvas = lo;
                    //}
                }
            }
        }

        //exits the whole thing
        internal void exitapplication()
        {
            if (issaved == false)
            {
                MessageBoxResult m = MessageBox.Show("You have unsaved changes.", "Continue?", MessageBoxButton.OKCancel);

                if (m == MessageBoxResult.Cancel)
                {
                    return;
                }
            }
            // Application.Current.Shutdown(0);
            Environment.Exit(0);
        }
        ////gets the script for node
        //internal string getNodeScript(string nodeGUID)
        //{
        //    string retscript = "";
        //    if (stacks.ContainsKey(nodeGUID))
        //    {
        //        retscript = stacks[nodeGUID].script;
        //    }
        //    return retscript;
        //}
        //internal void setNodeScript(string nodeGUID, string fullScriptData)
        //{
        //    if (stacks.ContainsKey(nodeGUID))
        //    {
        //        stacks[nodeGUID].script = fullScriptData;
        //    }
        //}

        internal Dictionary<string, string> getMyNodesOnCanvas()
        {
            Dictionary<string, string> n = new Dictionary<string, string>();
            foreach (ModViz3DNode m in stacks.Values)
            {
                n.Add(m.nodeGUID.ToString(), m.ToString());
            }
            return n;
        }



        internal List<string> getNodesThatAreSelectedOnCanvas()
        {
            List<string> g = new List<string>();
            if (selstacks == null) return g;
            foreach (string bing in selstacks)
            {
                g.Add(bing);
            }
            return g;
        }

        internal string getMyNodeOnCanvasDescription(string ng)
        {
            if (stacks.ContainsKey(ng))
                return stacks[ng].ToString();
            else return "Invalid GUID";
        }

        internal void tellMyNodeOnCanvasToProcess(string ng)
        {
            if (stacks.ContainsKey(ng))
            {
                ModViz3DNode mg = stacks[ng];
                mg.logical_representation.doIprocess();
            }
        }

        internal bool setMyNodeOnCanvasOutput(string ng, int oi, object v)
        {
            try
            {
                if (stacks.ContainsKey(ng))
                {
                    ModViz3DNode mg = stacks[ng];
                    if (oi > -1 && oi < mg.logical_representation.outputs.Count)
                    {
                        mg.logical_representation.outputs[oi] = v;
                        List<PUPPIModule> ds = mg.logical_representation.getDownstreamModules(oi);
                        foreach (PUPPIModule pm in ds)
                        {
                            pm.doIprocess();
                        }
                    }
                    else
                    {
                        return false;
                    }
                }
                else
                {
                    return false;
                }
            }
            catch
            {
                return false;
            }
            return true;
        }



        internal bool setMyNodeOnCanvasInput(string ng, int ii, object v)
        {

            if (stacks.ContainsKey(ng))
            {
                ModViz3DNode mg = stacks[ng];
                if (ii > -1 && ii < mg.logical_representation.inputs.Count)
                {

                    PUPPIModule mip = mg.logical_representation;
                    PUPPIInParameter pi = mip.inputs[ii];
                    if (pi.module != null)
                    {
                        pi.module.outputs[pi.outParIndex] = v;
                        mip.userdoIprocess();
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return false;
            }
        }


        //internal bool setMyNodeOnCanvasInput(PUPPIModule sourceme,string ng, int ii, object v,bool setorno)
        //{

        //    if (stacks.ContainsKey(ng))
        //    {
        //        ModViz3DNode mg = stacks[ng];
        //        if (ii > -1 && ii < mg.logical_representation.inputs.Count)
        //        {
        //            upi = new ArrayList();
        //            int iii = 0;
        //            for (iii = 0; iii < mg.logical_representation.inputs.Count; iii++)
        //            {
        //                PUPPIInParameter pi = mg.logical_representation.inputs[iii];
        //                if (iii != ii)
        //                {
        //                    if (pi.module != null)
        //                    {
        //                        upi.Add(pi.module.outputs[pi.outParIndex]);
        //                    }
        //                    else
        //                    {
        //                        upi.Add(null);
        //                    }
        //                }
        //                else
        //                {
        //                    upi.Add(v);
        //                }
        //            }
        //            pn = ng;
        //            if (setorno )

        //            try
        //            {
        //                sourceme.prochan += new PUPPIModule.processhandler(havemynodeprocessexplicit);
        //            }
        //            catch

        //            {

        //            }
        //            else
        //            try
        //            {
        //                sourceme.prochan -= new PUPPIModule.processhandler(havemynodeprocessexplicit);
        //            }
        //            catch
        //            {

        //            }
        //            return true;
        //        }
        //        else
        //        {

        //            return false;
        //        }
        //    }
        //    else
        //    {
        //        return false;
        //    }
        //}

        //string pn = "";
        //ArrayList upi = null;
        //internal void havemynodeprocessexplicit()//string ng, ArrayList inputs)
        //{
        //    if (stacks.ContainsKey(pn))
        //    {
        //        ModViz3DNode mg = stacks[pn];
        //        mg.logical_representation.resetUSLD();
        //        mg.logical_representation.increaseUSLD(new List<PUPPIInParameter>());
        //        mg.logical_representation.processExplicit(upi);  
        //    }
        //}

        internal bool getANodeBoundingBoxByGUID(string ng, out double xStart, out double yStart, out double zStart, out double xSize, out double ySize, out double zSize)
        {
            xStart = 0;
            yStart = 0;
            zStart = 0;

            xSize = 0;
            ySize = 0;
            zSize = 0;
            if (stacks.ContainsKey(ng))
            {

                ModViz3DNode m = stacks[ng];
                if (m != null && m.boundingBox != null)
                {
                    xStart = m.boundingBox.X;
                    yStart = m.boundingBox.Y;
                    zStart = m.boundingBox.Z;

                    xSize = m.boundingBox.SizeX;
                    ySize = m.boundingBox.SizeY;
                    zSize = m.boundingBox.SizeZ;

                    return true;
                }
            }
            return false;
        }


        //to save to a certain xml file. called by saveas
        internal string saveCanvasRepresentationToXML()
        {
            List<ModViz3DNode> sv = null;
            try
            {
                sv = new List<ModViz3DNode>(stacks.Values);
            }
            catch
            {
                sv = null;
            }
            if (sv == null) sv = new List<ModViz3DNode>();

            List<ModViz3DConn> myConns = null;
            try
            {
                myConns = new List<ModViz3DConn>(connpaths.Values);
            }
            catch
            {
                myConns = null;

            }
            if (myConns == null) myConns = new List<ModViz3DConn>();
            string xmldata = "";
            XmlDocument doc = new XmlDocument();

            XmlNode canvasElem;
            //write the canvas
            canvasElem = doc.CreateNode(XmlNodeType.Element, "canvas", "");
            XmlNode timeelem = doc.CreateNode(XmlNodeType.Element, "lastChanged", "");
            timeelem.InnerText = DateTime.Now.ToString();
            canvasElem.AppendChild(timeelem);
            XmlNode runelem = doc.CreateNode(XmlNodeType.Element, "currentlyRunning", "");
            runelem.InnerText = (PUPPIModule.concurrentProcesses > 0).ToString();
            canvasElem.AppendChild(runelem);
            for (int nc = 0; nc < sv.Count; nc++)
            {


                ModViz3DNode writenode = sv[nc];
                if (writenode == null) continue;
                //each node
                XmlNode nodeelem = doc.CreateNode(XmlNodeType.Element, "node", "");
                XmlNode nodeStringeleme = doc.CreateNode(XmlNodeType.Element, "details", "");
                nodeStringeleme.InnerText = writenode.ToString();
                nodeelem.AppendChild(nodeStringeleme);
                if (writenode.vizinputs != null)
                    foreach (ModViz3DInput mvi in writenode.vizinputs)
                    {
                        if (mvi == null) continue;
                        XmlNode nodeInputeleme = doc.CreateNode(XmlNodeType.Element, "input", "");
                        nodeInputeleme.InnerText = mvi.ToString();
                        nodeelem.AppendChild(nodeInputeleme);
                    }
                if (writenode.vizoutputs != null)
                    foreach (ModViz3DOutput mvi in writenode.vizoutputs)
                    {
                        if (mvi == null) continue;
                        XmlNode nodeInputeleme = doc.CreateNode(XmlNodeType.Element, "output", "");
                        nodeInputeleme.InnerText = mvi.ToString();
                        nodeelem.AppendChild(nodeInputeleme);
                    }


                canvasElem.AppendChild(nodeelem);

            }
            //and connection lines
            for (int nc = 0; nc < myConns.Count; nc++)
            {


                ModViz3DConn writeconn = myConns[nc];
                if (writeconn == null) continue;
                //each node
                XmlNode connelem = doc.CreateNode(XmlNodeType.Element, "conn", "");
                connelem.InnerText = writeconn.ToString();
                canvasElem.AppendChild(connelem);

            }


            doc.AppendChild(canvasElem);


            xmldata = doc.OuterXml;
            return xmldata;
        }
        internal string saveCanvasRepresentationToXMLNoHI()
        {
            List<ModViz3DNode> sv = null;
            try
            {
                sv = new List<ModViz3DNode>(stacks.Values);
            }
            catch
            {
                sv = null;
            }
            if (sv == null) sv = new List<ModViz3DNode>();

            List<ModViz3DConn> myConns = null;
            try
            {
                myConns = new List<ModViz3DConn>(connpaths.Values);
            }
            catch
            {
                myConns = null;

            }
            if (myConns == null) myConns = new List<ModViz3DConn>();
            string xmldata = "";
            XmlDocument doc = new XmlDocument();

            XmlNode canvasElem;
            //write the canvas
            canvasElem = doc.CreateNode(XmlNodeType.Element, "canvas", "");
            XmlNode timeelem = doc.CreateNode(XmlNodeType.Element, "lastChanged", "");
            timeelem.InnerText = DateTime.Now.ToString();
            canvasElem.AppendChild(timeelem);
            XmlNode runelem = doc.CreateNode(XmlNodeType.Element, "currentlyRunning", "");
            runelem.InnerText = (PUPPIModule.concurrentProcesses > 0).ToString();
            canvasElem.AppendChild(runelem);
            for (int nc = 0; nc < sv.Count; nc++)
            {


                ModViz3DNode writenode = sv[nc];
                if (writenode.hiddenOnLockedCanvas) continue;
                if (writenode == null) continue;
                //each node
                XmlNode nodeelem = doc.CreateNode(XmlNodeType.Element, "node", "");
                XmlNode nodeStringeleme = doc.CreateNode(XmlNodeType.Element, "details", "");
                nodeStringeleme.InnerText = writenode.ToString();
                nodeelem.AppendChild(nodeStringeleme);
                if (writenode.vizinputs != null)
                    foreach (ModViz3DInput mvi in writenode.vizinputs)
                    {
                        if (mvi == null) continue;
                        XmlNode nodeInputeleme = doc.CreateNode(XmlNodeType.Element, "input", "");
                        nodeInputeleme.InnerText = mvi.ToString();
                        nodeelem.AppendChild(nodeInputeleme);
                    }
                if (writenode.vizoutputs != null)
                    foreach (ModViz3DOutput mvi in writenode.vizoutputs)
                    {
                        if (mvi == null) continue;
                        XmlNode nodeInputeleme = doc.CreateNode(XmlNodeType.Element, "output", "");
                        nodeInputeleme.InnerText = mvi.ToString();
                        nodeelem.AppendChild(nodeInputeleme);
                    }


                canvasElem.AppendChild(nodeelem);

            }

            doc.AppendChild(canvasElem);


            xmldata = doc.OuterXml;
            return xmldata;
        }
        //to save to a certain xml file. called by saveas
        internal void savexml(string filenamepath, List<ModViz3DNode> sv, bool savetofile, out string xmldata)
        {
            xmldata = "";
            XmlDocument doc = new XmlDocument();

            XmlNode canvasElem;
            //write the canvas
            canvasElem = doc.CreateNode(XmlNodeType.Element, "canvas", "");
            //XmlElement root = doc.DocumentElement;
            for (int nc = 0; nc < sv.Count; nc++)
            {

                //ModViz3DNode writenode = stacks.Values.ToArray()[nc];
                ModViz3DNode writenode = sv[nc];
                if (writenode == null) continue;
                //each node
                XmlNode nodeelem = doc.CreateNode(XmlNodeType.Element, "node", "");
                XmlNode guideleme = doc.CreateNode(XmlNodeType.Element, "guid", "");
                guideleme.InnerText = writenode.nodeGUID.ToString();
                nodeelem.AppendChild(guideleme);


                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "displayname", "");
                dispeleme.InnerText = writenode.displayname;
                nodeelem.AppendChild(dispeleme);

                XmlNode hdl = doc.CreateNode(XmlNodeType.Element, "hidden", "");
                hdl.InnerText = writenode.hiddenOnLockedCanvas.ToString();
                nodeelem.AppendChild(hdl);

                XmlNode sld = doc.CreateNode(XmlNodeType.Element, "solid", "");
                sld.InnerText = writenode.isSolid.ToString();
                nodeelem.AppendChild(sld);


                XmlNode xpose = doc.CreateNode(XmlNodeType.Element, "xpos", "");
                xpose.InnerText = writenode.myposition.X.ToString();
                nodeelem.AppendChild(xpose);

                XmlNode baseindexe = doc.CreateNode(XmlNodeType.Element, "baseindex", "");
                baseindexe.InnerText = writenode.baseindex.ToString();
                nodeelem.AppendChild(baseindexe);


                XmlNode ypose = doc.CreateNode(XmlNodeType.Element, "ypos", "");
                ypose.InnerText = writenode.myposition.Y.ToString();
                nodeelem.AppendChild(ypose);
                //save bounding box so we don't have to pyramid undo /redo, maybe client server
                XmlNode bboxc = doc.CreateNode(XmlNodeType.Element, "nodeBBOX", "");
                bboxc.InnerText = writenode.boundingBox.ToString();
                nodeelem.AppendChild(bboxc);

                XmlNode PUPPImodelem = doc.CreateNode(XmlNodeType.Element, "PUPPImodule", "");
                if (writenode.logical_representation != null)
                {
                    PUPPImodelem.InnerText = writenode.logical_representation.GetType().ToString();
                }
                nodeelem.AppendChild(PUPPImodelem);
                //save custom node data
                if (writenode.logical_representation != null)
                {
                    string s = writenode.logical_representation.saveSettings();
                    if (s != null && s != "")
                    {
                        XmlNode cs = doc.CreateNode(XmlNodeType.Element, "savedSettings", "");
                        cs.InnerText = s;
                        nodeelem.AppendChild(cs);
                    }
                }

                //array level - written after module
                XmlNode ll = doc.CreateNode(XmlNodeType.Element, "listlevel", "");
                ll.InnerText = writenode.list_level.ToString();
                nodeelem.AppendChild(ll);


                XmlNode pareeleme = doc.CreateNode(XmlNodeType.Element, "parentguid", "");
                if (writenode.parent != null)
                {
                    pareeleme.InnerText = writenode.parent.nodeGUID.ToString();
                }
                else
                {
                    pareeleme.InnerText = "";
                }
                nodeelem.AppendChild(pareeleme);
                ////script 
                //XmlNode scxml = doc.CreateNode(XmlNodeType.Element, "nodeScript", "");
                //scxml.InnerText = writenode.script;
                //nodeelem.AppendChild(scxml);

                //XmlNode lol = doc.CreateNode(XmlNodeType.Element, "listlevel", "");
                //lol.InnerText = writenode.list_level.ToString();
                //nodeelem.AppendChild(lol);

                for (int inc = 0; inc < writenode.logical_representation.inputs.Count; inc++)
                {
                    //write inputs
                    PUPPIInParameter ppi = writenode.logical_representation.inputs[inc];
                    if (ppi == null) continue;
                    if (ppi.module == null) continue;
                    XmlNode conneleme = doc.CreateNode(XmlNodeType.Element, "connector", "");


                    // <inputindex>1</inputindex>
                    //  <nodeguid>3</nodeguid>
                    //<outputindex>2</outputindex>
                    XmlNode inieleme = doc.CreateNode(XmlNodeType.Element, "inputindex", "");
                    inieleme.InnerText = inc.ToString();
                    conneleme.AppendChild(inieleme);

                    XmlNode ininodeleme = doc.CreateNode(XmlNodeType.Element, "nodeguid", "");
                    if (ppi.module != null) { ininodeleme.InnerText = ppi.module.GUID.ToString(); }
                    else
                    {
                        ininodeleme.InnerText = "";
                    }
                    conneleme.AppendChild(ininodeleme);

                    XmlNode outpareleme = doc.CreateNode(XmlNodeType.Element, "outputindex", "");
                    outpareleme.InnerText = ppi.outParIndex.ToString();
                    conneleme.AppendChild(outpareleme);

                    //XmlNode isoptional = doc.CreateNode(XmlNodeType.Element, "isoptional", "");
                    //isoptional.InnerText = ppi.isoptional.ToString();
                    //conneleme.AppendChild(isoptional);

                    nodeelem.AppendChild(conneleme);
                }
                //if no inputs, write output values if possible
                //because otherwise the values would come from inputs
                if (writenode.logical_representation.inputs.Count == 0)
                {
                    for (int outs = 0; outs < writenode.logical_representation.outputs.Count; outs++)
                    {

                        if (writenode.logical_representation.outputs[outs] == null) continue;
                        XmlNode outeleme = doc.CreateNode(XmlNodeType.Element, "output", "");
                        //index
                        XmlNode outindeleme = doc.CreateNode(XmlNodeType.Element, "outputindex", "");
                        outindeleme.InnerText = outs.ToString();
                        outeleme.AppendChild(outindeleme);
                        //this is for single value
                        if (writenode.list_level == 0)
                        {

                            //arraylists need to be addressed for stuff such as grid inputs
                            //value
                            XmlNode outvaleleme = doc.CreateNode(XmlNodeType.Element, "outputvalue", "");
                            if (writenode.logical_representation.outputs[outs].GetType() == typeof(ArrayList))
                            {
                                outvaleleme.InnerText = writearraytostring(writenode.logical_representation.outputs[outs] as ArrayList);
                            }
                            else
                            {

                                try
                                {
                                    outvaleleme.InnerText = writenode.logical_representation.outputs[outs].ToString();
                                }
                                catch
                                {
                                }
                            }
                            outeleme.AppendChild(outvaleleme);
                        }
                        else
                        {

                            try
                            {
                                ArrayList myovals = writenode.logical_representation.outputs[outs] as ArrayList;
                                for (int ooc = 0; ooc < myovals.Count; ooc++)
                                {
                                    //value
                                    XmlNode outvaleleme = doc.CreateNode(XmlNodeType.Element, "outputvalue", "");
                                    outvaleleme.InnerText = myovals[ooc].ToString();
                                    outeleme.AppendChild(outvaleleme);
                                }

                            }
                            catch
                            {

                            }
                        }

                        nodeelem.AppendChild(outeleme);
                    }
                }
                //input settings
                else
                {
                    for (int ints = 0; ints < writenode.logical_representation.inputs.Count; ints++)
                    {

                        if (writenode.logical_representation.inputs[ints] == null) continue;
                        XmlNode inteleme = doc.CreateNode(XmlNodeType.Element, "input", "");
                        //index
                        XmlNode intindeleme = doc.CreateNode(XmlNodeType.Element, "inputindex", "");
                        intindeleme.InnerText = ints.ToString();
                        inteleme.AppendChild(intindeleme);
                        //autolist
                        XmlNode outvaleleme = doc.CreateNode(XmlNodeType.Element, "autoListMode", "");
                        outvaleleme.InnerText = writenode.logical_representation.inputs[ints].inputAutomaticListMode.ToString();
                        inteleme.AppendChild(outvaleleme);
                        nodeelem.AppendChild(inteleme);
                    }
                }
                //save custom node representation
                if (writenode.nodeCustomRenderer != null)
                {

                    XmlNode nCR = doc.CreateNode(XmlNodeType.Element, "nodeCustomRenderer", "");
                    nCR.InnerText = writenode.nodeCustomRenderer.saveCustomRendererStateToXML();
                    nodeelem.AppendChild(nCR);

                }




                canvasElem.AppendChild(nodeelem);

            }
            doc.AppendChild(canvasElem);
            //root.AppendChild(canvasElem);

            // doc.PreserveWhitespace = true;
            if (savetofile)
            {
                XmlTextWriter writer = new XmlTextWriter(filenamepath, null);
                writer.Formatting = Formatting.Indented;
                doc.Save(writer);
                writer.Close();
            }
            else
            {
                //save to string
                xmldata = doc.OuterXml;

            }


        }
        //writes an arraylist to a string for xml save
        //saves as grid or list type
        //this is for inputs not defined as list inputs
        internal static string writearraytostring(ArrayList myoutput)
        {
            try
            {
                if (myoutput.Count == 0) return "";
                string stringed = "";
                //check if grid
                //first four letters
                if ((myoutput[0]).GetType() == typeof(ArrayList))
                {
                    stringed = stringed + "GRID__";
                    foreach (ArrayList gridroww in myoutput)
                    {
                        //write row
                        for (int jj = 0; jj < gridroww.Count; jj++)
                        {
                            string itm = gridroww[jj].ToString();
                            stringed += itm;
                            if (jj == gridroww.Count - 1)
                            {   //move to next row
                                stringed += '\n';
                            }
                            else
                            {   //move to next item, put in separator
                                stringed += "__";
                            }
                        }
                    }


                }
                else
                {
                    //write a list format
                    stringed += "LIST__";
                    //write row
                    for (int jj = 0; jj < myoutput.Count; jj++)
                    {
                        string itm = myoutput[jj].ToString();
                        stringed += itm;
                        if (jj == myoutput.Count - 1)
                        {
                        }
                        else
                        {   //move to next item, put in separator
                            stringed += "__";
                        }
                    }
                }
                return stringed;
            }



            catch
            {
                return "";
            }
        }

        //cuts to internal custom clipboard node and children
        void cutstacktoclip(ModViz3DNode tobecutnode)
        {

        }
        //puts stuff in clipboard with option to clear first
        internal void update_clipboard_singlestack(ModViz3DNode clonedstack, bool clearfirst)
        {
            if (clearfirst)
            {
                clipstacks.Clear();

            }
            List<ModViz3DNode> ch = new List<ModViz3DNode>();
            clonedstack.getalllevelschildren(ch);
            ch.Add(clonedstack);
            //need to check if nodes from stack already copied to clipboard
            //if clipboard cleared this won't matter
            if (clipstacks.Values.Count > 0)
            {

                foreach (ModViz3DNode cs in ch)
                {
                    ModViz3DNode testf = null;
                    try
                    {
                        testf = clipstacks[cs.nodeGUID.ToString()];
                    }
                    catch
                    {
                        testf = null;
                    }
                    if (testf != null)
                    {
                        //can't do that
                        return;
                    }
                }
            }
            //foreach (ModViz3DNode cs in ch)
            //{
            //clipstacks.Add(cs.nodeGUID.ToString(),  cs);  
            //}

            clipstacks.Add(clonedstack.nodeGUID.ToString(), clonedstack);

        }
        //converts a stack dict into a single tower
        //makes a stack into a vertical tower
        internal ModViz3DNode makestackverticaltowers(Dictionary<string, ModViz3DNode> toclipstacks)
        {

            List<ModViz3DNode> alc = new List<ModViz3DNode>();
            foreach (ModViz3DNode m in toclipstacks.Values)
            {
                if (m.parent == null)
                {
                    alc.Add(m);
                    List<ModViz3DNode> lc = new List<ModViz3DNode>();
                    m.getalllevelschildren(lc);
                    alc.AddRange(lc);
                }
            }
            //get the first one as base
            ModViz3DNode b = alc[0];
            alc.Remove(b);
            ModViz3DNode soma = b;
            foreach (ModViz3DNode m in alc)
            {
                if (m.parent != null)
                {
                    m.parent.childs.Remove(m);
                }
                soma.addnodechild(m);

                soma = m;

            }
            return b;

        }

        //paste function
        internal void pastefromclip(Point3D position)
        {
            string oss = my_old_pc_status;
            ////seems like it doesn't work unless in-outs get updated before connections get updated
            //List<ModViz3DNode> toUpdate = new List<ModViz3DNode>();
            ////make sure we can paste
            //if (clipstacks.Values.Count > 0)
            //{
            //    foreach (ModViz3DNode pc in clipstacks.Values)
            //    {
            //        //only the bottom nodes cause we add childrem
            //        if (pc.parent == null)
            //        {


            //            Rect3D defaultbox = position.makedefaultbox();


            //            ModViz3DNode newclone = pc.clonestack(true);

            //            addstacktostack(newclone);
            //            blockconnupdates = true;
            //            newclone.myposition = position;
            //            newclone.renderme();
            //            newclone.renderchildren();

            //            newclone.fitroots(stacks);
            //            toUpdate.Add(newclone);
            //            List<ModViz3DNode> allc = new List<ModViz3DNode>();
            //            newclone.getalllevelschildren(allc);
            //            toUpdate.AddRange(allc);

            //        }
            //    }
            //    foreach (ModViz3DNode m in toUpdate)
            //    {
            //        m.update_caption();
            //        m.update_inouts();
            //    }

            //    blockconnupdates = false;
            //    regenerate_connections(false);
            //    //update_all_connectors(); 
            //    update_grid();
            //    removemanipulator();
            //}


            //to be able to undo this
            Dictionary<string, ModViz3DNode> la = new Dictionary<string, ModViz3DNode>();
            try
            {


                readxml(clipboardXMLRepresentation, out la, false, ModViz3DNode.GUIDcount + 1);
                canvasabouttochange();

                updatemyPCStatus("Please wait, pasting " + la.Count + " nodes...");

            }
            catch (Exception exy)
            {
                la = new Dictionary<string, ModViz3DNode>();
            }
            if (la.Count > 0)
                addmorestacks(la, true, position.X, position.Y);
            updatemyPCStatus(oss);
        }
        //selects all the stacks(all nodes in 2d ) on the canvas
        internal void selectallnodes()
        {
            deselectallnodes();
            foreach (ModViz3DNode m in stacks.Values)
            {
                selstacks.Add(m.nodeGUID.ToString());
            }
            selectcolornodes();
        }

        internal void selectCanvasNodesBySuppliedIDs(List<int> nGs)
        {
            deselectallnodes();
            foreach (ModViz3DNode m in stacks.Values)
            {
                if (nGs.Contains(m.nodeGUID))
                    selstacks.Add(m.nodeGUID.ToString());
            }
            selectcolornodes();
        }

        //selects all the stacks(all nodes in 2d ) on the canvas
        internal void rearrangenice(int cs)
        {

            if (cs == 0) return;
            List<ModViz3DNode> bs = new List<ModViz3DNode>();
            //based on inputs and outputs of nodes
            List<int> vs = new List<int>();
            int ns = 0;
            int miv = int.MaxValue;
            int mav = int.MinValue;
            if (stacks.Values.Count == 0) return;

            string os = my_old_pc_status;
            canvasabouttochange();
            if (PUPPIDebugger.debugenabled)
            {
                PUPPIDebugger.log("Started " + utils.StringConstants.reano);
            }
            updatemyPCStatus("Please wait,rearranging nodes...");
            foreach (ModViz3DNode m in stacks.Values)
            {

                if (m.parent == null)
                {
                    int v = 0;
                    int o = 0;
                    int i = 0;
                    o = m.logical_representation.getDownstreamTree().GetNodeCount(true);
                    i = m.logical_representation.getUpstreamTree().GetNodeCount(true);
                    v -= o;
                    v += i;
                    ns += m.vizinputs.Count;
                    ns += m.vizoutputs.Count;
                    foreach (ModViz3DNode c in m.childs)
                    {
                        o = c.logical_representation.getDownstreamTree().GetNodeCount(true);
                        i = c.logical_representation.getUpstreamTree().GetNodeCount(true);
                        v -= o;
                        v += i;
                        ns += m.vizinputs.Count;
                        ns += m.vizoutputs.Count;
                    }
                    if (v < miv) miv = v;
                    if (v > mav) mav = v;
                    vs.Add(v);
                    bs.Add(m);

                }
            }

            blockconnupdates = true;





            //int basediv =Convert.ToInt32 ( Math.Ceiling((double)((mav - miv) / cs)));
            double basediv = (mav - miv) / (double)cs;
            double nsp = Math.Ceiling((double)ns / (double)(bs.Count));
            if (nsp == 0) nsp = 1;


            //figure out how much to displace down
            List<int> bdcs = new List<int>();
            ArrayList[] pss = new ArrayList[cs];
            for (int i = 0; i < cs; i++)
            {
                pss[i] = new ArrayList();
            }
            int tss = 0;
            for (int bd = 0; bd < cs; bd++)
            {
                //arrange them going left and down
                int bcc = 0;
                for (int bdd = 0; bdd < bs.Count; bdd++)
                {
                    if (vs[bdd] >= miv + bd * basediv && vs[bdd] <= miv + (bd + 1) * basediv)
                    {
                        bcc++;

                    }
                }
                tss += bcc;
                //  bdcs.Add(bcc); 
            }
            //see how many should be on column
            int css = Convert.ToInt16(Math.Ceiling((double)tss / (double)cs));
            //order them
            List<int> ddd = new List<int>();
            for (int bd = 0; bd < cs; bd++)
            {
                //arrange them going left and down
                int bcc = 0;
                for (int bdd = 0; bdd < bs.Count; bdd++)
                {
                    if (vs[bdd] >= miv + bd * basediv && vs[bdd] <= miv + (bd + 1) * basediv)
                    {
                        if (!ddd.Contains(bdd))
                        {
                            ddd.Add(bdd);
                        }
                    }
                }

            }
            int cl = 0;
            int rl = 0;
            for (int bz = 0; bz < ddd.Count; bz++)
            {

                pss[cl].Add(ddd[bz]);
                if (rl >= css && cl < cs - 1) cl++;
                if (rl < css) rl++; else rl = 0;

            }

            //for (int bd=0;bd<cs;bd++)
            //{
            //    //arrange them going left and down
            //    int bcc = 0;
            //    for (int bdd = 0; bdd < bs.Count; bdd++)
            //    {
            //        if (vs[bdd] >= miv + bd * basediv && vs[bdd] <= miv + (bd + 1) * basediv)
            //        {
            //            bcc++;
            //            bs[bdd].movestack(bd * PUPPIGUISettings.nodeSide*nsp - bs[bdd].myposition.X, (bcc-bdcs[bd]/2) * PUPPIGUISettings.nodeSide - bs[bdd].myposition.Y);
            //        }
            //    }
            //}



            for (int bd = 0; bd < cs; bd++)
            {
                for (int bv = 0; bv < pss[bd].Count; bv++)
                {

                    bs[Convert.ToInt16(pss[bd][bv])].movestack(bd * (PUPPIGUISettings.nodeSide + PUPPIGUISettings.nodeSpacing) * nsp + Math.Abs(bv % 2) * (PUPPIGUISettings.nodeSide + PUPPIGUISettings.nodeSpacing) - bs[Convert.ToInt16(pss[bd][bv])].myposition.X, (bv - pss[bd].Count / 2) * (PUPPIGUISettings.nodeSide + PUPPIGUISettings.nodeSpacing) * nsp - bs[Convert.ToInt16(pss[bd][bv])].myposition.Y);
                }

            }
            // stopMouseEv(); 
            for (int bdd = 0; bdd < bs.Count; bdd++)
            {
                bs[bdd].fitroots(stacks);
            }
            // resumeMouseEv(); 
            blockconnupdates = false;
            update_all_connectors();
            if (PUPPIDebugger.debugenabled)
            {
                PUPPIDebugger.log("Finished " + utils.StringConstants.reano);
            }
            updatemyPCStatus(os);
        }



        internal void select_canvas_nodes_by_region(Rect3D reg)
        {
            deselectallnodes();
            Rect3D fr = new Rect3D(reg.X, reg.Y, 0, reg.SizeX, reg.SizeY, PUPPIGUISettings.textRaise);
            foreach (ModViz3DNode m in stacks.Values)
            {
                Rect3D rr = new Rect3D(m.boundingBox.X, m.boundingBox.Y, 0, m.boundingBox.SizeX, m.boundingBox.SizeY, PUPPIGUISettings.textRaise);
                if (fr.IntersectsWith(rr))
                    selstacks.Add(m.nodeGUID.ToString());
            }
            selectcolornodes();
        }

        //changes the selection to color
        internal void selectcolornodes()
        {
            foreach (string g in selstacks)
            {
                ModViz3DNode gg = null;
                if (stacks.TryGetValue(g, out gg))
                {
                    if (gg.myself != null)
                    {
                        GeometryModel3D cc = gg.myself.Content as GeometryModel3D;
                        if (cc != null)
                        {
                            Material m = cc.Material;
                            cc.Material = node_selected_default_mat;
                        }
                        else
                        {
                            // MessageBox.Show("null node content");  
                        }
                    }
                    else
                    {
                        //  MessageBox.Show("null node visual");  
                    }

                }
            }


        }
        //delesects all nodes
        internal void deselectallnodes()
        {
            deselectcolornodes();
            selstacks.Clear();

        }
        //changes back the color of all selected nodes
        internal void deselectcolornodes()
        {
            foreach (string g in selstacks)
            {
                ModViz3DNode gg = null;
                if (stacks.TryGetValue(g, out gg))
                {
                    if (gg.nodeCustomRenderer == null)
                    {
                        GeometryModel3D cc = gg.myself.Content as GeometryModel3D;
                        Material m = cc.Material;
                        if (gg.nodeUpdatedMaterial == null)
                        {
                            cc.Material = node_default_mat;
                        }
                        else
                        {
                            cc.Material = gg.nodeUpdatedMaterial;
                        }

                    }
                }
            }

        }
        //copies the selection to clipboard
        internal void copyselectiontoclipboard()
        {
            ////get all the bottoms of selected stacks
            //List<ModViz3DNode> bs = new List<ModViz3DNode>();
            //foreach (string ng in selstacks)
            //{
            //    ModViz3DNode m;
            //    //if a node not in stack then its parents not either
            //    if (stacks.TryGetValue(ng, out m))
            //    {
            //        ModViz3DNode n = m.getlowestinlistids(selstacks);
            //        if (n != null && bs.Contains(n) == false) bs.Add(n);
            //    }

            //}
            //deselectallnodes();
            ////finally update clipboard
            //clipstacks.Clear();
            //foreach (ModViz3DNode b in bs)
            //{
            //    update_clipboard_singlestack(b.clonestack(false), false);
            //}
            List<ModViz3DNode> e = new List<ModViz3DNode>();
            if (selstacks.Count > 0)
            {
                foreach (string s in selstacks)
                {
                    ModViz3DNode g = null;
                    stacks.TryGetValue(s, out g);
                    if (g != null) e.Add(g);

                }
                if (e.Count > 0)
                {

                    savexml("", e, false, out clipboardXMLRepresentation);
                }
            }


        }

        Dictionary<string, connectorpath> saveCPaths()
        {
            Dictionary<string, connectorpath> saveCPathss = new Dictionary<string, connectorpath>();
            foreach (ModViz3DConn mc in connpaths.Values)
            {
                saveCPathss.Add(mc.visualGUID, mc.mypath);
            }
            return saveCPathss;
        }

        //reverts to the previous state 
        //this means that the current state gets pushed into the redo state
        internal void undome()
        {
            //Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
            if (undostack.Count > 0)
            {

                //stopMouseEv();
                if (PUPPIDebugger.debugenabled)
                {
                    PUPPIDebugger.log("started undo");
                }
                string os = my_old_pc_status;
                updatemyPCStatus("Please wait, undoing last user action...");
                Dictionary<string, ModViz3DNode> newstacks = new Dictionary<string, ModViz3DNode>();
                //try
                //{
                string newstate = undostack.Pop();
                Dictionary<string, connectorpath> newcps = undoconns.Pop();
                //save current state to xml
                string thistate = "";
                savexml("", stacks.Values.ToList<ModViz3DNode>(), false, out thistate);
                redostack.Push(thistate);
                redoconns.Push(saveCPaths());

                clearobjects(false);

                readxml(newstate, out newstacks, false);



                //}
                //catch { return; }
                pushnewstacks(newstacks, true, newcps);
                updatemyPCStatus(os);
                if (PUPPIDebugger.debugenabled)
                {
                    PUPPIDebugger.log("finished undo");
                }
                //resumeMouseEv();
            }


        }
        internal void redome()
        {
            //Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
            if (redostack.Count > 0)
            {
                //stopMouseEv();
                Dictionary<string, ModViz3DNode> newstacks = new Dictionary<string, ModViz3DNode>();
                //try
                //{
                if (PUPPIDebugger.debugenabled)
                {
                    PUPPIDebugger.log("started redo");
                }
                string os = my_old_pc_status;
                updatemyPCStatus("Please wait,redoing last user action...");
                string newstate = redostack.Pop();
                Dictionary<string, connectorpath> newcps = redoconns.Pop();
                //save current state to xml
                string thistate = "";
                savexml("", stacks.Values.ToList<ModViz3DNode>(), false, out thistate);
                undostack.Push(thistate);
                undoconns.Push(saveCPaths());

                clearobjects(false);

                readxml(newstate, out newstacks, false);



                //}
                //catch { return; }
                pushnewstacks(newstacks, true, newcps);
                updatemyPCStatus(os);
                if (PUPPIDebugger.debugenabled)
                {
                    PUPPIDebugger.log("finished redo");
                }
                //resumeMouseEv(); 
            }

        }
        //whenever a change is effected - before canvas changes
        internal void canvasabouttochange()
        {
            //save current state to xml
            string thistate = "";
            savexml("", stacks.Values.ToList<ModViz3DNode>(), false, out thistate);
            if (undostack.Count == 0 || thistate != undostack.Peek())
            {
                undostack.Push(thistate);
                undoconns.Push(saveCPaths());
                redostack.Clear();
                redoconns.Clear();
            }



        }

        internal delegate void NodeChangedHandler(object sender, EventArgs e);

        //output visual representation etc
        internal class ModViz3DOutput
        {
            internal ModelVisual3D myself;
            internal bool isCustom = false;
            internal HelixViewport3D myview;
            internal PUPPICanvas mycanvas;

            //for XML
            internal string visualOutputValueString = "";
            internal string visualOutputNameString = "";
            //outbound connections
            internal ArrayList outboundconns;
            internal Point3D myPosition;
            internal Rect3D myBB;
            internal ModViz3DOutput(ModelVisual3D meself, PUPPICanvas mecanvas)
            {
                isCustom = false;
                myBB = new Rect3D();
                myPosition = new Point3D();
                myself = meself;
                mycanvas = mecanvas;
                myview = mecanvas.hv;
                outboundconns = new ArrayList();

            }
            public override string ToString()
            {
                string bobox = "";
                if (myBB == null) bobox = "null"; else bobox = myBB.ToString();
                return "[Bounding Box:]" + bobox + "_|_[Name:]" + visualOutputNameString + "_|_[Value:]" + visualOutputValueString;

            }
        }
        //input visual representation etc
        internal class ModViz3DInput
        {
            internal bool isCustom = false;
            internal ModelVisual3D myself;
            internal ModViz3DConn myconnector;
            internal PUPPIInParameter myinput;
            internal string inputVisualGUID { get; set; }
            internal string visualInputValueString = "";
            internal string visualInputNameString = "";
            internal HelixViewport3D myview;
            internal PUPPICanvas mycanvas;
            internal Point3D myPosition;
            internal Rect3D myBB;
            internal ModViz3DInput(ModelVisual3D meself, PUPPICanvas mecanvas, string newGUID, PUPPIInParameter logicalinput)
            {
                isCustom = false;
                myBB = new Rect3D();
                myPosition = new Point3D();
                myself = meself;
                mycanvas = mecanvas;
                myview = mecanvas.hv;
                myconnector = null;
                myinput = logicalinput;
                inputVisualGUID = newGUID;
            }
            public override string ToString()
            {
                string bobox = "";
                if (myBB == null) bobox = "null"; else bobox = myBB.ToString();
                return "[Bounding Box:]" + bobox + "_|_[Name:]" + visualInputNameString + "_|_[Value:]" + visualInputValueString;

            }
        }
        //hold data on connector area occupancy
        internal struct connoccup
        {
            internal Point3D poscenter;
            internal bool isflat;
            internal bool ishorizontal;
            internal Rect3D connbounds;
            //store the actual pt offset
            // internal double centeroffset;
            internal Point3D actualpt;
        }

        //visual representation of connectors between modules
        internal class ModViz3DConn
        {
            //the visual rep
            internal ModelVisual3D myself;
            //the array of overall connector line fillings
            // internal List<connoccup> allconnlines;
            //from the maze, storing as points to see if it has changed
            internal List<Point3D> basePoints;
            //for clicking
            internal string visualGUID { get; set; }
            //source viz node
            internal ModViz3DNode sourcenode;
            //and output index on source
            internal int sourceoutindex;
            //now destination
            internal ModViz3DNode destnode;
            internal int destinindex;
            //for automatic events
            internal HelixViewport3D myview;
            //color index to generate an unique color
            internal double cindex = -1;
            internal double colsaturation = -1;
            internal double colvallue = -1;
            internal PUPPICanvas mycanvas;
            //source and destination boxes so we can check if they changed
            Rect3D sourcebox;
            Rect3D destbox;
            internal List<Point3D> actualCPoints;
            internal connectorpath mypath;
            //for common base
            Rect3D basebox;
            internal bool forceConnRedraw = false;
            internal ModViz3DConn(ModViz3DNode src, int sindex, ModViz3DNode dst, int dindex, string vguid)
            {
                actualCPoints = new List<Point3D>();
                mypath = null;
                myself = null;
                sourcenode = src;
                sourceoutindex = sindex;
                destnode = dst;
                destinindex = dindex;
                visualGUID = vguid;
                //if source changes
                mycanvas = src.mycanvas;
                myview = mycanvas.hv;
                sourcenode.NodeChanged += nodechanged;
                destnode.NodeChanged += nodechanged;

                // allconnlines = new List<connoccup>();
                // sourcebox = sourcenode.boundingBox;
                //destbox = destnode.boundingBox;

                sourcebox = sourcenode.vizoutputs[sourceoutindex].myBB;
                destbox = destnode.vizinputs[destinindex].myBB;

                basebox = sourcenode.getroot().boundingBox;
                basePoints = new List<Point3D>();
                forceConnRedraw = false;

            }



            //gnerates the rectangle map of a connection path
            //internal d2collisionmodel getfootprints(bool horizontal)
            //{

            //    ModViz3DConn mvcc = this;
            //    d2collisionmodel connectmap = new d2collisionmodel();
            //    int pcnt = 0;
            //    for (pcnt = 0; pcnt < mvcc.allconnlines.Count; pcnt++)
            //    {
            //        connoccup ccon = mvcc.allconnlines[pcnt];

            //        if (ccon.connbounds.IntersectsWith(d2collisionmodel.canvaslevelmap.region_perimeter))
            //        {
            //            if (ccon.ishorizontal == true && horizontal)
            //            {
            //                connectmap.footprints.Add(ccon.connbounds);
            //            }
            //            else if (ccon.ishorizontal == false && !horizontal)
            //            {
            //                connectmap.footprints.Add(ccon.connbounds);
            //            }
            //        }




            //    }
            //    connectmap.region_perimeter = d2collisionmodel.canvaslevelmap.region_perimeter;

            //    return connectmap;
            //}


            internal void deletevisual()
            {
                if (!mycanvas.thiscanvasdefinitelylocked)
                    myview.Children.Remove(myself);
                myself = null;

                //unsubscribe so that it doesn't get redrawn
                //gotta figure out a way to terminate object
                sourcenode.NodeChanged -= nodechanged;
                destnode.NodeChanged -= nodechanged;

            }
            internal void nodechanged(object sender, EventArgs e)
            {


                //try to redraw
                PUPPICanvas trycanvas = null;
                try
                {
                    trycanvas = sender as PUPPICanvas;
                    if (trycanvas.blockconnupdates == true) return;
                }
                catch
                {
                    trycanvas = null;
                }
                if (trycanvas != null)
                {
                    mycanvas = trycanvas;
                    if (PUPPIGUISettings.useMultiThreading)
                        drawmethread();
                    else drawme();


                }
                return;
            }
            //draws in separate thread
            internal void drawmethread()
            {
                System.Threading.ThreadPool.QueueUserWorkItem(
     new System.Threading.WaitCallback(drawconn));
                //drawme();
            }
            private void drawconn(Object stateInfo)
            {
                mycanvas.Dispatcher.Invoke(DispatcherPriority.Send,
                                      (ThreadStart)delegate () { drawme(); });
            }



            //draws/redraws the arrow strip
            internal void drawme(connectorpath cp = null)
            {



                if (mycanvas == null) return;
                try
                {
                    if (mycanvas.thiscanvasdefinitelylocked) return;
                    myview = mycanvas.hv;
                    //check
                    if (myself != null)
                    {

                        if (myview.Children.IndexOf(myself) >= 0)
                        {

                        }
                        else
                        {
                            //wait
                            //Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
                            //myview = mycanvas.hv;
                            //return;
                        }
                    }
                }
                catch
                {
                    return;
                }



                try
                {



                    if (PUPPIDebugger.debugenabled == true)
                    {
                        PUPPIDebugger.log(utils.StringConstants.begindrawingconn + sourcenode.nodeGUID.ToString() + " output " + sourceoutindex.ToString() + " to node " + destnode.nodeGUID.ToString() + " input " + destinindex.ToString());
                    }




                    // d2collisionmodel hconns = new d2collisionmodel();
                    //d2collisionmodel vconns = new d2collisionmodel();
                    //checks if connection needs to be redrawn
                    bool haschanged = false;
                    //test
                    //bool haschanged = true;
                    if (forceConnRedraw)
                    {
                        haschanged = true;
                        forceConnRedraw = false;
                    }
                    if (cp != null) haschanged = true;
                    if (!haschanged)
                    {
                        if (myself != null && myview.Children.IndexOf(myself) >= 0)
                        {

                            //    //on ground
                            //    if (allconnlines.Count > 0)
                            //    //{
                            //       // hconns = getfootprints(true);
                            //      //  vconns = getfootprints(false);
                            //        if (d2collisionmodel.connsintersectmatrix(d2collisionmodel.canvaslevelmaporigin, hconns, connectorpath.hconnmaze, PUPPIGUISettings.nodeSpacing) || d2collisionmodel.connsintersectmatrix(d2collisionmodel.canvaslevelmaporigin, vconns, connectorpath.vconnmaze, PUPPIGUISettings.nodeSpacing) || sourcenode.boundingBox.Equals(sourcebox) == false || destnode.boundingBox.Equals(destbox) == false)
                            //        {
                            //            haschanged = true;
                            //        }
                            //    }//over bases, only if destination or source have changed
                            //    else
                            //    {
                            //        if (sourcenode.boundingBox.Equals(sourcebox) == false || destnode.boundingBox.Equals(destbox) == false || sourcenode.getroot().boundingBox.Equals(basebox) == false)
                            //        {
                            //            haschanged = true;
                            //        }
                            //    }

                            if (sourcebox.getDiagonal() == 0 || destbox.getDiagonal() == 0)
                            {
                                haschanged = true;
                            }
                            else
                            {
                                if (basePoints.Count > 0)
                                {
                                    //the faster method to check whether the connection needs to be redrawn
                                    if (sourcenode.vizoutputs[sourceoutindex].myBB.isEqualToler(sourcebox) == false || destnode.vizinputs[destinindex].myBB.isEqualToler(destbox) == false || d2collisionmodel.connsPointsintersectmatrix(d2collisionmodel.canvaslevelmaporigin, basePoints, connectorpath.hconnmaze, connectorpath.vconnmaze, connectorpath.HconnsWereDrawnHere, connectorpath.VconnsWereDrawnHere, PUPPIGUISettings.nodeSpacing))
                                    {
                                        haschanged = true;
                                    }
                                }
                                else
                                {
                                    if (sourcenode.vizoutputs[sourceoutindex].myBB.isEqualToler(sourcebox) == false || destnode.vizinputs[destinindex].myBB.isEqualToler(destbox) == false || sourcenode.getroot().boundingBox.isEqualToler(basebox) == false)
                                    {
                                        haschanged = true;
                                    }
                                }
                            }
                        }
                        else
                        {
                            haschanged = true;
                        }
                    }
                    if (connectorpath.noConnDrawnYet)
                    {
                        //haschanged = true;
                        connectorpath.noConnDrawnYet = false;
                    }

                    if (haschanged == false)
                    {

                    }

                    if (haschanged == true)
                    {
                        // hconns = new d2collisionmodel();
                        //vconns = new d2collisionmodel();
                        PUPPIDebugger.conns_Redrawn++;
                        //need to redraw
                        if (myself != null)
                        {

                            if (myview.Children.IndexOf(myself) >= 0)
                            {
                                myview.Children.Remove(myself);
                            }
                            else
                            {

                            }
                        }
                        else
                        {
                            //test
                            // Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
                        }
                        var meshBuilder = new MeshBuilder(false, false);
                        LinesVisual3D lv = new LinesVisual3D();


                        if (cp == null)
                            mypath = new connectorpath(this, mycanvas.stacks, mycanvas.connpaths);
                        else
                            mypath = cp;
                        mypath.testview = mycanvas.hv;

                        bool bf = false;
                        if (cp == null)
                            bf = mypath.findpath(out basePoints);
                        else
                        {
                            bf = true;
                            basePoints = new List<Point3D>();
                            foreach (Point3D ppp in cp.mybpts)
                            {
                                basePoints.Add(ppp);
                            }
                        }

                        if (!bf) forceConnRedraw = true;
                        //build arrows
                        Point3D spoint = mypath.startpoint;
                        //get previous direction so that we know how to orient vertical ribbons
                        Vector3D prevdir = new Vector3D();
                        //allconnlines.Clear();

                        int addcounter = 0;
                        // foreach (Vector3D v3d in mypath.lineparts)
                        Vector3D v3d = new Vector3D();
                        Point3D epoint;
                        //draw either one or another above
                        int rup = 0;
                        //for edge space multiplying
                        //sourcenode.number_outbound_connections++;  

                        List<Vector3D> cLs = new List<Vector3D>();
                        //List<Vector3D> cLs = mypath.lineparts.ConvertAll(vc => new Vector3D(vc.X, vc.Y, vc.Z));
                        //slightly displace short connections to ensure all visible
                        List<Vector3D> pLs = new List<Vector3D>();
                        List<Vector3D> jLs = new List<Vector3D>();
                        List<Vector3D> fLs = new List<Vector3D>();

                        //extra displacement
                        int r = 0;
                        int iindex = sourcenode.nodeGUID + sourceoutindex + destnode.nodeGUID + destinindex;//Convert.ToInt16 (cindex);
                        int dd = Math.DivRem(iindex, 2 * PUPPIGUISettings.maxConnPerSpace, out r);

                        double ddd = (double)(r - 2 * PUPPIGUISettings.maxConnPerSpace) / (double)(5 * PUPPIGUISettings.maxConnPerSpace) * PUPPIGUISettings.solidConnectionSize;
                        spoint.Offset(ddd, ddd, 0);

                        //2d cleanup of verticals,now needs to be done before everything else
                        if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                        {
                            for (int i = 0; i < mypath.lineparts.Count; i++)
                            {
                                Vector3D vaaa = new Vector3D(mypath.lineparts[i].X, mypath.lineparts[i].Y, mypath.lineparts[i].Z);
                                if (vaaa.X != 0 || vaaa.Y != 0) pLs.Add(vaaa);
                            }
                        }
                        else
                        {
                            for (int i = 0; i < mypath.lineparts.Count; i++)
                            {
                                Vector3D vaaa = new Vector3D(mypath.lineparts[i].X, mypath.lineparts[i].Y, mypath.lineparts[i].Z);
                                pLs.Add(vaaa);
                            }
                            // pLs = mypath.lineparts.ConvertAll(vc => new Vector3D(vc.X, vc.Y, vc.Z));
                        }




                        if (PUPPIGUISettings.removeOverlaps)
                        {
                            //get rid of overlapping that go backwards
                            for (int i = 0; i < pLs.Count; i++)
                            {
                                //won't try this if it's going up on same base

                                Vector3D vaaa = pLs[i];
                                if (i < pLs.Count - 2 && (i > 1 || mypath.combase == null))
                                {

                                    Vector3D laaa = pLs[i + 1];

                                    laaa.Negate();
                                    if (Math.Abs(laaa.anglewithrad(vaaa)) < PUPPIGUISettings.collinearToler || Math.Abs(laaa.anglewithrad(vaaa)) > Math.PI * 2 - PUPPIGUISettings.collinearToler)
                                    {
                                        if (vaaa != laaa) fLs.Add(vaaa - laaa);
                                        i++;
                                    }
                                    else
                                    {
                                        fLs.Add(vaaa);

                                    }
                                }
                                else
                                {
                                    fLs.Add(vaaa);
                                }


                            }

                        }
                        else
                        {
                            fLs = pLs.ConvertAll(vc => new Vector3D(vc.X, vc.Y, vc.Z));
                        }

                        //get rid of wiggles
                        if (PUPPIGUISettings.smoothConnections)
                        {
                            List<Vector3D> gLs = new List<Vector3D>();

                            for (int iii = 0; iii < fLs.Count; iii++)
                            {

                                if (iii < fLs.Count - 2 && fLs[iii + 1].Length < PUPPIGUISettings.nodeSpacing * 0.5 && fLs[iii + 1].Length > 0 && Math.Abs(fLs[iii + 1].Z) < PUPPIGUISettings.collinearToler && Math.Abs(fLs[iii].Z) < PUPPIGUISettings.collinearToler && Math.Abs(fLs[iii + 2].Z) < PUPPIGUISettings.collinearToler && fLs[iii + 2].Length > PUPPIGUISettings.nodeSpacing * 0.5 && fLs[iii].Length > PUPPIGUISettings.nodeSpacing * 0.5)
                                {
                                    Vector3D v1 = fLs[iii] * fLs[iii + 1].Length / fLs[iii].Length;
                                    Vector3D v0 = fLs[iii] - v1;

                                    Vector3D v3 = fLs[iii + 2] * fLs[iii + 1].Length / fLs[iii + 2].Length;
                                    Vector3D v2 = v1 + fLs[iii + 1] + v3;
                                    Vector3D v4 = fLs[iii + 2] - v3;
                                    gLs.Add(v0);
                                    gLs.Add(v2);
                                    // gLs.Add(v3);
                                    fLs[iii + 2] = v4;
                                    iii++;
                                }
                                else

                                    //won't try this if it's going up on same base

                                    if (iii < fLs.Count - 2 && (iii > 1 || mypath.combase == null))
                                {
                                    Vector3D vaaa = fLs[iii];
                                    Vector3D laaa = fLs[iii + 2];
                                    Vector3D faaa = fLs[iii + 1];
                                    laaa.Negate();
                                    if ((Math.Abs(laaa.anglewithrad(vaaa)) < PUPPIGUISettings.collinearToler || Math.Abs(laaa.anglewithrad(vaaa)) > Math.PI * 2 - PUPPIGUISettings.collinearToler) && laaa.Length < PUPPIGUISettings.nodeSpacing && vaaa.Length < PUPPIGUISettings.nodeSpacing && faaa.Length < PUPPIGUISettings.nodeSide)
                                    //skip ahead slight curve
                                    {
                                        Vector3D adad = fLs[iii] + fLs[iii + 1] + fLs[iii + 2];
                                        if (adad.Length < PUPPIGUISettings.nodeSpacing)
                                        {
                                            if (adad.Length != 0)
                                            {
                                                //gLs.Add(fLs[iii] / 2 + fLs[iii + 1] / 4);
                                                //gLs.Add(fLs[iii] / 2 + fLs[iii + 1] / 8);
                                                //gLs.Add(fLs[iii + 1] / 4);
                                                //gLs.Add(fLs[iii+2] / 2 + fLs[iii + 1] / 8);
                                                //gLs.Add(fLs[iii+2] / 2 + fLs[iii + 1] / 4);

                                                gLs.Add(adad);
                                            }
                                            iii += 2;
                                        }
                                        else
                                        {
                                            gLs.Add(fLs[iii]);
                                        }
                                    }
                                    else if ((Math.Abs(laaa.anglewithrad(vaaa)) < PUPPIGUISettings.collinearToler || Math.Abs(laaa.anglewithrad(vaaa)) > Math.PI * 2 - PUPPIGUISettings.collinearToler) && vaaa.Length < PUPPIGUISettings.nodeSpacing && faaa.Length < PUPPIGUISettings.ioLength / 2 + PUPPIGUISettings.ioMinSpacing / 2)
                                    //skip last
                                    {
                                        gLs.Add(vaaa);
                                        Vector3D adad = fLs[iii + 1] + fLs[iii + 2];
                                        if (adad.Length != 0)
                                            gLs.Add(adad);
                                        iii += 2;
                                    }
                                    else if ((Math.Abs(laaa.anglewithrad(vaaa)) < PUPPIGUISettings.collinearToler || Math.Abs(laaa.anglewithrad(vaaa)) > Math.PI * 2 - PUPPIGUISettings.collinearToler) && laaa.Length < PUPPIGUISettings.nodeSpacing && faaa.Length < PUPPIGUISettings.ioLength / 2 + PUPPIGUISettings.ioMinSpacing / 2)
                                    //skip last
                                    {

                                        Vector3D adad = fLs[iii] + fLs[iii + 1];
                                        if (adad.Length != 0)
                                            gLs.Add(adad);
                                        gLs.Add(fLs[iii + 2]);
                                        iii += 2;
                                    }

                                    else
                                    {
                                        gLs.Add(fLs[iii]);
                                    }
                                }
                                else
                                {
                                    gLs.Add(fLs[iii]);
                                }
                            }



                            //a specific cleanup
                            List<Vector3D> iLs = new List<Vector3D>();
                            for (int i = 0; i < gLs.Count; i++)
                            {
                                Vector3D vaaa = gLs[i];
                                if (i < gLs.Count - 2 && mypath.combase == null)
                                {

                                    Vector3D laaa = gLs[i + 1];
                                    Vector3D caaa = gLs[i + 2];
                                    laaa.Negate();
                                    //specific situation, beginning of connection from base - in 2d
                                    if ((Math.Abs(laaa.anglewithrad(vaaa)) < Math.PI * 0.49 || Math.Abs(laaa.anglewithrad(vaaa)) > Math.PI * 2 - Math.PI * 0.49) && (Math.Abs(caaa.anglewithrad(laaa)) < Math.PI * 0.49 || Math.Abs(caaa.anglewithrad(laaa)) > Math.PI * 2 - Math.PI * 0.49))
                                    {
                                        Vector3D oaaa = vaaa - laaa + caaa;
                                        //if this is too long it can mess up 
                                        //if (oaaa.Length < PUPPIGUISettings.nodeSpacing * 0.5)
                                        //{
                                        iLs.Add(oaaa);
                                        i += 2;
                                        //}
                                        //else
                                        //{
                                        //iLs.Add(vaaa);
                                        //}
                                    }
                                    else   //in 3d - going down and then making a sharp turn
                                        if ((vaaa.X == 0 && vaaa.Y == 0) && (Math.Abs(caaa.anglewithrad(laaa)) < Math.PI * 0.49 || Math.Abs(caaa.anglewithrad(laaa)) > Math.PI * 2 - Math.PI * 0.49))
                                    {
                                        Vector3D oaaa = -laaa + caaa;
                                        iLs.Add(vaaa);
                                        iLs.Add(oaaa);
                                        i += 2;
                                    }
                                    else
                                    {
                                        iLs.Add(vaaa);

                                    }
                                }
                                else
                                {
                                    iLs.Add(vaaa);
                                }

                            }
                            for (int i = 0; i < iLs.Count; i++)
                            {
                                Vector3D vaaa = iLs[i];
                                if (i < iLs.Count - 1 && mypath.combase == null)
                                {

                                    Vector3D laaa = iLs[i + 1];

                                    laaa.Negate();
                                    //less than 45 degrees
                                    if ((Math.Abs(laaa.anglewithrad(vaaa)) < Math.PI * 0.25 || Math.Abs(laaa.anglewithrad(vaaa)) > Math.PI * 2 - Math.PI * 0.25))
                                    {
                                        Vector3D oaaa = vaaa - laaa;
                                        jLs.Add(oaaa);
                                        i++;

                                    }
                                    else
                                    {
                                        jLs.Add(vaaa);

                                    }
                                }
                                else
                                {
                                    jLs.Add(vaaa);
                                }
                            }

                            //last one,prevent sharp reverse before input in 2d
                            if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                            {
                                if (jLs.Count > 1)
                                {
                                    Vector3D laaa = jLs[jLs.Count - 1];
                                    Vector3D vaaa = jLs[jLs.Count - 2];
                                    laaa.Negate();
                                    if ((Math.Abs(laaa.anglewithrad(vaaa)) < Math.PI * 0.49 || Math.Abs(laaa.anglewithrad(vaaa)) > Math.PI * 2 - Math.PI * 0.49))
                                    {
                                        jLs.RemoveAt(jLs.Count - 1);
                                        jLs.RemoveAt(jLs.Count - 1);
                                        jLs.Add(vaaa - laaa);
                                    }
                                }
                            }

                        }
                        else
                        {
                            jLs = fLs.ConvertAll(vc => new Vector3D(vc.X, vc.Y, vc.Z));
                        }

                        if (PUPPIGUISettings.offsetSmallConnections)
                        {
                            List<Vector3D> oLs = jLs.ConvertAll(vc => new Vector3D(vc.X, vc.Y, vc.Z));
                            Random rnd1 = new Random();
                            cLs.Add(oLs[0]);
                            double cee = PUPPIGUISettings.nodeSpacing / (double)PUPPIGUISettings.maxConnPerSpace;
                            for (int i = 1; i < oLs.Count - 1; i++)
                            {
                                Vector3D eh = oLs[i];
                                if (oLs[i].X == 0 || oLs[i].Y == 0)
                                {
                                    if (Math.Abs(oLs[i - 1].anglewithrad(oLs[i])) > PUPPIGUISettings.collinearToler && Math.Abs(oLs[i - 1].anglewithrad(oLs[i])) < Math.PI * 2 - PUPPIGUISettings.collinearToler && Math.Abs(oLs[i].anglewithrad(oLs[i + 1])) > PUPPIGUISettings.collinearToler && Math.Abs(oLs[i].anglewithrad(oLs[i + 1])) < Math.PI * 2 - PUPPIGUISettings.collinearToler)
                                    {
                                        if (oLs[i].X == 0)
                                        {
                                            //double d = (rnd1.Next(2) - 1) * PUPPIGUISettings.errF;
                                            double d = rnd1.NextDouble() * cee * 0.3 - cee * 0.15;// *PUPPIGUISettings.errF;
                                            double h = oLs[i].Y;
                                            h += d;
                                            eh.Y = h;

                                        }
                                        else if (oLs[i].Y == 0)
                                        {
                                            double d = rnd1.NextDouble() * cee * 0.3 - cee * 0.15;
                                            //double d = (rnd1.Next(2) - 1) * PUPPIGUISettings.errF;
                                            double h = oLs[i].X;
                                            h += d;
                                            eh.X = h;

                                        }
                                    }
                                }
                                cLs.Add(eh);
                            }
                            cLs.Add(oLs[oLs.Count - 1]);
                        }
                        else
                        {
                            cLs = jLs.ConvertAll(vc => new Vector3D(vc.X, vc.Y, vc.Z));
                        }


                        List<Vector3D> bbLs = cLs.ConvertAll(vc => new Vector3D(vc.X, vc.Y, vc.Z));
                        cLs.Clear();
                        pLs.Clear();
                        //concat collinear
                        while (bbLs.Count > 0)
                        {




                            if ((bbLs[0].X == 0 && bbLs[0].Y == 0) || bbLs.Count <= 2)
                            {


                                pLs.Add(bbLs[0]);
                                bbLs.RemoveAt(0);
                                continue;
                            }
                            else
                            {
                                Vector3D tc = new Vector3D(bbLs[1].X, bbLs[1].Y, bbLs[1].Z);

                                tc.Negate();
                                //gotta check one ahead too
                                bool oneup = false;
                                Vector3D lc = new Vector3D(bbLs[2].X, bbLs[2].Y, bbLs[2].Z);
                                lc.Negate();
                                if (lc.anglewithrad(bbLs[0]) <= PUPPIGUISettings.collinearToler || lc.anglewithrad(bbLs[0]) > Math.PI * 2 - PUPPIGUISettings.collinearToler || bbLs[2].anglewithrad(bbLs[0]) <= PUPPIGUISettings.collinearToler || bbLs[2].anglewithrad(bbLs[0]) > Math.PI * 2 - PUPPIGUISettings.collinearToler)
                                {
                                    oneup = true;
                                }
                                if ((tc.anglewithrad(bbLs[0]) <= PUPPIGUISettings.collinearToler || tc.anglewithrad(bbLs[0]) > Math.PI * 2 - PUPPIGUISettings.collinearToler || bbLs[1].anglewithrad(bbLs[0]) <= PUPPIGUISettings.collinearToler || bbLs[1].anglewithrad(bbLs[0]) > Math.PI * 2 - PUPPIGUISettings.collinearToler) && oneup)
                                {
                                    Vector3D va = bbLs[0] + bbLs[1];
                                    bbLs.RemoveAt(0);
                                    bbLs.RemoveAt(0);
                                    bbLs.Insert(0, va);

                                }
                                else
                                {
                                    pLs.Add(bbLs[0]);
                                    bbLs.RemoveAt(0);
                                    continue;
                                }


                            }
                        }

                        cLs = pLs.ConvertAll(vc => new Vector3D(vc.X, vc.Y, vc.Z));



                        //if (PUPPIGUISettings.splineConnections)
                        //{
                        //    List<Vector3D> bLs = cLs.ConvertAll(vc => new Vector3D(vc.X, vc.Y, vc.Z));
                        //    cLs.Clear();
                        //    //split splines
                        //    int cvc = 0;
                        //    //original point 0 to getrelative spline
                        //    Point3D thisP = new Point3D(0, 0, 0);
                        //    List<List<Point3D>> allSplines = new List<List<Point3D>>();
                        //    while (cvc < bLs.Count)
                        //    {
                        //        List<Point3D> currentSpline = new List<Point3D>();
                        //        currentSpline.Add(thisP);
                        //        while (cvc < bLs.Count && bLs[cvc].Length < PUPPIGUISettings.nodeSpacing*3 )
                        //        {
                        //            thisP = thisP + bLs[cvc];
                        //            currentSpline.Add(thisP);
                        //            cvc++;
                        //        }
                        //        //split and add
                        //        if (cvc < bLs.Count)
                        //        {
                        //            Vector3D partvec = bLs[cvc];
                        //            partvec.Normalize();
                        //            partvec =partvec*PUPPIGUISettings.nodeSpacing;
                        //            thisP = thisP + partvec;
                        //            currentSpline.Add(thisP);
                        //            allSplines.Add(currentSpline);
                        //            currentSpline = new List<Point3D>();
                        //            currentSpline.Add(thisP);
                        //            Vector3D partvec2 = bLs[cvc];
                        //            partvec2.Normalize();
                        //            partvec2 = partvec2 * (bLs[cvc].Length -2*PUPPIGUISettings.nodeSpacing);
                        //            thisP = thisP + partvec2;
                        //            currentSpline.Add(thisP);
                        //            allSplines.Add(currentSpline);
                        //            bLs[cvc] = partvec;
                        //        }
                        //        else
                        //        {
                        //            allSplines.Add(currentSpline);  
                        //        }


                        //    }



                        //    foreach (List<Point3D> thisSplineCt in allSplines)
                        //    {

                        //        if (thisSplineCt.Count > 2)
                        //        {
                        //            PUPPICAD.HelperClasses.PUPPISpline3D ps = new PUPPICAD.HelperClasses.PUPPISpline3D(thisSplineCt);
                        //            //figure out spline point count
                        //            double distance = thisSplineCt[0].DistanceTo(thisSplineCt[thisSplineCt.Count - 1]);
                        //            int spaces = Convert.ToInt16(distance / PUPPIGUISettings.nodeSpacing);
                        //            if (spaces < 1) spaces = 1;
                        //            List<Point3D> np = ps.convertToPoints(spaces * PUPPIGUISettings.numberSplineSegments + 1);


                        //            for (int spct = 0; spct < np.Count - 1; spct++)
                        //            {
                        //                cLs.Add(np[spct + 1] - np[spct]);
                        //            }
                        //        }
                        //        //just a  line   
                        //        else if (thisSplineCt.Count == 2)
                        //        {
                        //            cLs.Add(thisSplineCt[1] - thisSplineCt[0]);
                        //        }
                        //    }
                        //    //List<Point3D> splinePts = new List<Point3D>();
                        //    ////origina point 0 to getrelative spline
                        //    //Point3D thisP = new Point3D(0, 0, 0); 
                        //    //for (int ptc=0;ptc<bLs.Count;ptc++)
                        //    //{
                        //    //    splinePts.Add(thisP);
                        //    //    thisP = Point3D.Add(thisP, bLs[ptc]);  
                        //    //}
                        //    //splinePts.Add(thisP);


                        //}
                        //else
                        //for later
                        bool aSp = false;
                        //now if radius
                        if (PUPPIGUISettings.roundedConnRadius > 0)
                        {
                            List<Vector3D> bLs = cLs.ConvertAll(vc => new Vector3D(vc.X, vc.Y, vc.Z));
                            cLs.Clear();
                            //over nodes we can be more lax about this
                            if (bLs.Count <= 5 && spoint.Z < PUPPIGUISettings.nodeHeight && destbox.Z < PUPPIGUISettings.nodeHeight && PUPPIGUISettings.splineConnections)
                            {
                                try
                                {
                                    //spline
                                    PUPPICAD.HelperClasses.PUPPISpline3D ps = new PUPPICAD.HelperClasses.PUPPISpline3D(spoint, bLs);
                                    List<Point3D> newpoints = ps.convertToPoints(10);
                                    Point3D cpoint = spoint;
                                    for (int spc = 1; spc < newpoints.Count; spc++)
                                    {
                                        cLs.Add(newpoints[spc] - newpoints[spc - 1]);
                                    }
                                    aSp = true;
                                }
                                catch
                                {
                                    cLs = new List<Vector3D>(bLs);
                                }
                            }
                            else
                            {
                                // //spline beginning and end if on base
                                // int lastLeg = 0;
                                //if (destbox.Z < PUPPIGUISettings.nodeHeight)
                                //{
                                //    lastLeg = 3; 
                                //}

                                //if (spoint.Z < PUPPIGUISettings.nodeHeight)
                                //{
                                //    try
                                //    {
                                //        //spline
                                //        PUPPICAD.HelperClasses.PUPPISpline3D ps = new PUPPICAD.HelperClasses.PUPPISpline3D(spoint, bLs);
                                //        List<Point3D> newpoints = ps.convertToPoints(10);
                                //        Point3D cpoint = spoint;
                                //        for (int spc = 1; spc < newpoints.Count; spc++)
                                //        {
                                //            cLs.Add(newpoints[spc] - newpoints[spc - 1]);
                                //        }
                                //    }
                                //    catch
                                //    {
                                //        cLs = new List<Vector3D>(bLs);
                                //    }
                                //}

                                //update 
                                while (bLs.Count > 0)
                                {
                                    //if (bLs[0].Z != 0 || bLs.Count==1 )
                                    if ((bLs[0].X == 0 && bLs[0].Y == 0) || bLs.Count == 1)
                                    {

                                        cLs.Add(bLs[0]);
                                        bLs.RemoveAt(0);
                                        continue;
                                    }
                                    else
                                    {
                                        //if (bLs[1].Z != 0)
                                        if (bLs[1].X == 0 && bLs[1].Y == 0)
                                        {
                                            if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                                            {
                                                //take out the one going up
                                                bLs.RemoveAt(1);
                                                continue;
                                            }
                                            else
                                            {
                                                //add both
                                                cLs.Add(bLs[0]);
                                                bLs.RemoveAt(0);
                                                cLs.Add(bLs[0]);
                                                bLs.RemoveAt(0);
                                                continue;
                                            }
                                        }
                                        else
                                        {

                                            // if they are not colliniar
                                            Vector3D tc = new Vector3D(bLs[1].X, bLs[1].Y, bLs[1].Z);
                                            tc.Negate();
                                            if (tc.anglewithrad(bLs[0]) <= PUPPIGUISettings.collinearToler || tc.anglewithrad(bLs[0]) > Math.PI * 2 - PUPPIGUISettings.collinearToler || bLs[1].anglewithrad(bLs[0]) <= PUPPIGUISettings.collinearToler || bLs[1].anglewithrad(bLs[0]) > Math.PI * 2 - PUPPIGUISettings.collinearToler)
                                            {
                                                cLs.Add(bLs[0]);
                                                bLs.RemoveAt(0);
                                                continue;
                                            }
                                            else
                                            {
                                                //first on long, split and continue
                                                if (bLs[0].Length > PUPPIGUISettings.nodeSpacing + PUPPIGUISettings.geomWeldToler)
                                                {
                                                    Vector3D vao = bLs[0];
                                                    vao.Normalize();
                                                    Vector3D lao = vao * (bLs[0].Length - PUPPIGUISettings.nodeSpacing);
                                                    Vector3D cacao = vao * PUPPIGUISettings.nodeSpacing;
                                                    bLs.RemoveAt(0);
                                                    cLs.Add(lao);
                                                    bLs.Insert(0, cacao);
                                                    continue;

                                                }
                                                //second one long, split but still do the curve
                                                if (bLs[1].Length > PUPPIGUISettings.nodeSpacing + PUPPIGUISettings.geomWeldToler)
                                                {
                                                    Vector3D vao = bLs[1];
                                                    vao.Normalize();
                                                    Vector3D cacao = vao * PUPPIGUISettings.nodeSpacing;
                                                    Vector3D lao = vao * (bLs[1].Length - PUPPIGUISettings.nodeSpacing);

                                                    bLs.RemoveAt(1);
                                                    bLs.Insert(1, cacao);
                                                    bLs.Insert(2, lao);


                                                }


                                                //now we can try to make the curved connection
                                                Point3D p1 = new Point3D(0, 0, 0);
                                                Point3D p2 = (bLs[0] * PUPPIGUISettings.roundedConnRadius).ToPoint3D();
                                                Point3D p3 = Vector3D.Add(bLs[0] * PUPPIGUISettings.roundedConnRadius, bLs[1] * PUPPIGUISettings.roundedConnRadius).ToPoint3D();
                                                List<Point3D> l = Visual3DExtensions.roundmyconn(p1, p2, p3);
                                                cLs.Add(bLs[0] * (1 - PUPPIGUISettings.roundedConnRadius));
                                                for (int il = 1; il < l.Count; il++)
                                                {
                                                    //if (il==0)
                                                    //{
                                                    //    cLs.Add(l[il].ToVector3D());

                                                    //}
                                                    //else
                                                    //{
                                                    cLs.Add(Point3D.Subtract(l[il], l[il - 1]));
                                                    //}

                                                }
                                                //cLs.Add(bLs[1] * (1 - PUPPIGUISettings.roundedConnRadius));
                                                Vector3D z = bLs[1] * (1 - PUPPIGUISettings.roundedConnRadius);
                                                bLs.RemoveAt(0);
                                                bLs.RemoveAt(0);
                                                bLs.Insert(0, z);


                                            }


                                        }
                                    }
                                }
                            }

                        }
                        //specific cleanup at end of long connection in 3d going from base to base
                        if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.ThreeDimensional && PUPPIGUISettings.removeOverlaps == true)
                        {
                            if (destbox.Z < PUPPIGUISettings.nodeHeight && cLs.Count > 5 && Math.Abs(cLs[cLs.Count - 1].Y) > PUPPIGUISettings.collinearToler && aSp == false)
                            {
                                Vector3D lls = cLs[cLs.Count - 2] + cLs[cLs.Count - 1];
                                cLs.RemoveAt(cLs.Count - 1);
                                cLs.RemoveAt(cLs.Count - 1);
                                cLs.Add(lls);
                            }
                        }

                        if (PUPPIGUISettings.splineConnections == true && aSp == false)
                        {
                            if (cLs.Count > 5)
                            {
                                if (basePoints.Count > 0)
                                {

                                    if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                                    {

                                        if (spoint.Z < PUPPIGUISettings.nodeHeight)
                                        {
                                            List<Vector3D> svectors = new List<Vector3D>();

                                            Vector3D v1 = cLs[0];
                                            Vector3D v2 = cLs[1];
                                            Vector3D v3 = cLs[2];
                                            Vector3D v4 = cLs[3] * 0.5;
                                            svectors.Add(v1);
                                            svectors.Add(v2);
                                            svectors.Add(v3);
                                            svectors.Add(v4);
                                            cLs.RemoveAt(0);
                                            cLs.RemoveAt(0);
                                            cLs.RemoveAt(0);
                                            cLs.RemoveAt(0);
                                            cLs.Insert(0, v4);
                                            //spline
                                            PUPPICAD.HelperClasses.PUPPISpline3D ps = new PUPPICAD.HelperClasses.PUPPISpline3D(spoint, svectors);
                                            List<Point3D> newpoints = ps.convertToPoints(6);
                                            svectors.Clear();
                                            for (int spc = 1; spc < newpoints.Count; spc++)
                                            {
                                                svectors.Add(newpoints[spc] - newpoints[spc - 1]);
                                            }
                                            for (int svc = svectors.Count - 1; svc >= 0; svc--)
                                            {
                                                cLs.Insert(0, svectors[svc]);
                                            }

                                        }
                                        if (destbox.Z < PUPPIGUISettings.nodeHeight)
                                        {
                                            List<Vector3D> svectors = new List<Vector3D>();

                                            Vector3D v1 = cLs[cLs.Count - 3] * 0.5;
                                            Vector3D v2 = cLs[cLs.Count - 2];
                                            Vector3D v3 = cLs[cLs.Count - 1];
                                            svectors.Add(v1);
                                            svectors.Add(v2);
                                            svectors.Add(v3);
                                            cLs.RemoveAt(cLs.Count - 1);
                                            cLs.RemoveAt(cLs.Count - 1);
                                            cLs.RemoveAt(cLs.Count - 1);
                                            cLs.Add(v1);
                                            //spline
                                            PUPPICAD.HelperClasses.PUPPISpline3D ps = new PUPPICAD.HelperClasses.PUPPISpline3D(spoint, svectors);
                                            List<Point3D> newpoints = ps.convertToPoints(6);
                                            svectors.Clear();
                                            for (int spc = 1; spc < newpoints.Count; spc++)
                                            {
                                                svectors.Add(newpoints[spc] - newpoints[spc - 1]);
                                            }
                                            for (int svc = 0; svc < svectors.Count; svc++)
                                            {
                                                cLs.Add(svectors[svc]);
                                            }
                                        }
                                    }
                                    else
                                    {


                                        //List<Vector3D> svectors = new List<Vector3D>();

                                        //Vector3D v1 = cLs[0];
                                        //Vector3D v2 = cLs[1];
                                        //Vector3D v3 = cLs[2];
                                        //Vector3D v4 = cLs[3] * 0.5;
                                        //svectors.Add(v1);
                                        //svectors.Add(v2);
                                        //svectors.Add(v3);
                                        //svectors.Add(v4);
                                        //cLs.RemoveAt(0);
                                        //cLs.RemoveAt(0);
                                        //cLs.RemoveAt(0);
                                        //cLs.RemoveAt(0);
                                        //cLs.Insert(0, v4);
                                        ////spline
                                        //PUPPICAD.HelperClasses.PUPPISpline3D ps = new PUPPICAD.HelperClasses.PUPPISpline3D(spoint, svectors);
                                        //List<Point3D> newpoints = ps.convertToPoints(6);
                                        //svectors.Clear();
                                        //for (int spc = 1; spc < newpoints.Count; spc++)
                                        //{
                                        //    svectors.Add(newpoints[spc] - newpoints[spc - 1]);
                                        //}
                                        //for (int svc = svectors.Count - 1; svc >= 0; svc--)
                                        //{
                                        //    cLs.Insert(0, svectors[svc]);
                                        //}



                                        //svectors = new List<Vector3D>();

                                        //v1 = cLs[cLs.Count - 3] * 0.5;
                                        //v2 = cLs[cLs.Count - 2];
                                        //v3 = cLs[cLs.Count - 1];
                                        //svectors.Add(v1);
                                        //svectors.Add(v2);
                                        //svectors.Add(v3);
                                        //cLs.RemoveAt(cLs.Count - 1);
                                        //cLs.RemoveAt(cLs.Count - 1);
                                        //cLs.RemoveAt(cLs.Count - 1);
                                        //cLs.Add(v1);
                                        ////spline
                                        // ps = new PUPPICAD.HelperClasses.PUPPISpline3D(spoint, svectors);
                                        //newpoints = ps.convertToPoints(6);
                                        //svectors.Clear();
                                        //for (int spc = 1; spc < newpoints.Count; spc++)
                                        //{
                                        //    svectors.Add(newpoints[spc] - newpoints[spc - 1]);
                                        //}
                                        //for (int svc = 0; svc < svectors.Count; svc++)
                                        //{
                                        //    cLs.Add(svectors[svc]);
                                        //}
                                    }

                                    //else
                                    //{

                                    //    List<Vector3D> svectors = new List<Vector3D>();

                                    //    Vector3D v1 = cLs[0];
                                    //    Vector3D v2 = cLs[1];
                                    //    Vector3D v3 = cLs[2];
                                    //    Vector3D v4 = cLs[3] * 0.5;
                                    //    svectors.Add(v1);
                                    //    svectors.Add(v2);
                                    //    svectors.Add(v3);
                                    //    svectors.Add(v4);
                                    //    cLs.RemoveAt(0);
                                    //    cLs.RemoveAt(0);
                                    //    cLs.RemoveAt(0);
                                    //    cLs.RemoveAt(0);
                                    //    cLs.Insert(0, v4);
                                    //    //spline
                                    //    PUPPICAD.HelperClasses.PUPPISpline3D ps = new PUPPICAD.HelperClasses.PUPPISpline3D(spoint, svectors);
                                    //    List<Point3D> newpoints = ps.convertToPoints(6);
                                    //    svectors.Clear();
                                    //    for (int spc = 1; spc < newpoints.Count; spc++)
                                    //    {
                                    //        svectors.Add(newpoints[spc] - newpoints[spc - 1]);
                                    //    }
                                    //    for (int svc = svectors.Count - 1; svc >= 0; svc--)
                                    //    {
                                    //        cLs.Insert(0, svectors[svc]);
                                    //    }



                                    //    svectors = new List<Vector3D>();

                                    //     v1 = cLs[cLs.Count - 3] * 0.5;
                                    //   v2 = cLs[cLs.Count - 2];
                                    //     v3 = cLs[cLs.Count - 1];
                                    //    svectors.Add(v1);
                                    //    svectors.Add(v2);
                                    //    svectors.Add(v3);
                                    //    cLs.RemoveAt(cLs.Count - 1);
                                    //    cLs.RemoveAt(cLs.Count - 1);
                                    //    cLs.RemoveAt(cLs.Count - 1);
                                    //    cLs.Add(v1);
                                    //    //spline
                                    //     ps = new PUPPICAD.HelperClasses.PUPPISpline3D(spoint, svectors);
                                    //     newpoints = ps.convertToPoints(6);
                                    //    svectors.Clear();
                                    //    for (int spc = 1; spc < newpoints.Count; spc++)
                                    //    {
                                    //        svectors.Add(newpoints[spc] - newpoints[spc - 1]);
                                    //    }
                                    //    for (int svc = 0; svc < svectors.Count; svc++)
                                    //    {
                                    //        cLs.Add(svectors[svc]);
                                    //    }

                                    //}
                                }
                            }
                        }

                        //if (PUPPIGUISettings.connectionRenderMode==PUPPIGUISettings.ConnModeEnum.Wire   )
                        //{
                        //    lv.Points.Add(spoint);
                        //}
                        actualCPoints = new List<Point3D>();
                        #region conndrawloop
                        actualCPoints.Add(spoint);
                        for (int kk = 0; kk < cLs.Count; kk++)
                        {
                            v3d = Vector3D.Add(v3d, cLs[kk]);

                            //so we can make a nice ransition when source node on grid we skip this one

                            if (spoint.Z < PUPPIGUISettings.nodeHeight + PUPPIGUISettings.connRaise)
                            {
                                //if (kk == 2) { addcounter++; continue; }

                                //skip ones that overlap and go backwards
                                //if (kk < cLs.Count - 2)
                                //{
                                //    Vector3D nextstep = new Vector3D(cLs[kk + 1].X, cLs[kk + 1].Y, cLs[kk + 1].Z);
                                //    nextstep.Negate();


                                //    Vector3D thisstep = new Vector3D(cLs[kk].X, cLs[kk].Y, cLs[kk].Z);


                                //    if (Math.Abs(thisstep.anglewithrad(nextstep)) < PUPPIGUISettings.collinearToler)
                                //    {
                                //        continue;
                                //    }
                                //}



                            }

                            epoint = Point3D.Add(spoint, v3d);
                            actualCPoints.Add(epoint);
                            if (PUPPIGUISettings.connectionRenderMode == PUPPIGUISettings.ConnModeEnum.Solid)
                            {
                                //in 3d we make pipes
                                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                                {

                                    meshBuilder.AddPipe(spoint, epoint, 0, PUPPIGUISettings.solidConnectionSize, PUPPIGUISettings.pipeSides);

                                }
                                else
                                {

                                    //make ribbon
                                    // if (kk > 0 && spoint.Z == epoint.Z)
                                    if (spoint.X != epoint.X || spoint.Y != epoint.Y)
                                    {
                                        Point3D pe = new Point3D(spoint.X, spoint.Y, spoint.Z);



                                        pe.Offset(0, 0, PUPPIGUISettings.errF * rup);


                                        if (rup < 2) rup++; else rup = -2;

                                        Vector3D strline = new Vector3D();
                                        if (kk > 0)
                                        {
                                            meshBuilder.AddTriangleFan(PUPPIGUI.Visual3DExtensions.makeribbon(pe, v3d, PUPPIGUISettings.solidConnectionSize, cLs[kk - 1], out strline));
                                        }
                                        else
                                        {
                                            meshBuilder.AddTriangleFan(PUPPIGUI.Visual3DExtensions.makeribbon(pe, v3d, PUPPIGUISettings.solidConnectionSize, new Vector3D(), out strline));
                                        }
                                    }
                                }
                            }
                            else
                            {
                                lv.Points.Add(spoint);
                                lv.Points.Add(epoint);
                            }


                            #region othertypesoflines

                            // meshBuilder.AddCylinder(spoint, epoint, PUPPIGUISettings.solidConnectionSize,5);


                            //meshBuilder.AddArrow(spoint, epoint, PUPPIGUISettings.solidConnectionSize, PUPPIGUISettings.arrowTip);
                            #endregion




                            spoint.Offset(v3d.X, v3d.Y, v3d.Z);
                            //need to reset the vector since now the points are added
                            v3d = new Vector3D();

                        }



                        #endregion

                        ////need to figure out a better way eventually
                        //if (spoint.DistanceTo(mypath.endpoint) > PUPPIGUISettings.ioWidth)
                        //{
                        //    meshBuilder.AddPipe(spoint,mypath.endpoint, 0, PUPPIGUISettings.solidConnectionSize, PUPPIGUISettings.pipeSides);

                        //}


                        //since spoint gonna change
                        Point3D lCP = new Point3D(spoint.X, spoint.Y, spoint.Z);
                        spoint = mypath.startpoint;


                        //RGB generate
                        int oconnindex = 0;
                        try
                        {
                            oconnindex = sourcenode.vizoutputs[sourceoutindex].outboundconns.IndexOf(this);
                        }
                        catch { }
                        if (cindex == -1)
                        {
                            cindex = Math.Abs(Math.Sin(Convert.ToDouble(oconnindex + sourcenode.nodeGUID + sourceoutindex + destnode.nodeGUID + destinindex) * 0.07 * Math.PI));
                            // if (cindex < 60) cindex = cindex * 6; else if (cindex > 360) { cindex = cindex / 360; if (cindex < 60) cindex = cindex * 6; }
                            //extra parameters to differenctiate colors
                            colsaturation = ((double)(sourceoutindex + 1) / 2.0 + (double)sourcenode.vizoutputs.Count / 2.0) / (double)(sourcenode.vizoutputs.Count);
                            colvallue = ((double)(destinindex + 1) / 2.0 + (double)destnode.vizinputs.Count / 2.0) / (double)(destnode.vizinputs.Count);

                        }
                        //for debugging
                        ModelVisual3D dg = new ModelVisual3D();
                        //#region generate_matrix
                        //v3d = new Vector3D();
                        //for (int kk = 0; kk < mypath.lineparts.Count; kk++)
                        //{
                        //    //v3d = Vector3D.Add(v3d, mypath.lineparts[kk]);
                        //    v3d = mypath.lineparts[kk];
                        //    //so we can make a nice ransition when source node on grid we skip this one

                        //    epoint = Point3D.Add(spoint, v3d);


                        //    //leave the beginning free of constraints cause stuff falls there

                        //    //for lines that are flat, and on the ground
                        //    //don't get the last two cause we can block connectors
                        //    if (kk < mypath.lineparts.Count - 2)// (mypath.lineparts.IndexOf(v3d) < mypath.lineparts.Count - 2)
                        //    {
                        //        connoccup cc = new connoccup();
                        //        cc.isflat = (v3d.Z == 0 && spoint.Z < PUPPIGUISettings.nodeHeight + PUPPIGUISettings.connRaise);
                        //        if (cc.isflat)
                        //        {
                        //            addcounter++;
                        //            if (addcounter > 1)
                        //            {
                        //                // Point3D osp = new Point3D(spoint.X, spoint.Y, spoint.Z);
                        //                cc.poscenter = new Point3D(spoint.X.nodespacecenterconvert(PUPPIGUISettings.nodeSpacing), spoint.Y.nodespacecenterconvert(PUPPIGUISettings.nodeSpacing), Math.Truncate(spoint.Z / PUPPIGUISettings.nodeHeight) * PUPPIGUISettings.nodeHeight);
                        //                cc.ishorizontal = (Math.Abs(v3d.Y) < PUPPIGUISettings.collinearToler);
                        //                //only vertical and horizontal lines
                        //                bool isvert = (Math.Abs(v3d.X) < PUPPIGUISettings.collinearToler);
                        //                if (cc.ishorizontal || isvert)
                        //                {
                        //                    cc.connbounds = new Rect3D(cc.poscenter.X - PUPPIGUISettings.nodeSpacing * 0.25, cc.poscenter.Y - PUPPIGUISettings.nodeSpacing * 0.25, 0, PUPPIGUISettings.nodeSpacing * 0.5, PUPPIGUISettings.nodeSpacing * 0.5, PUPPIGUISettings.nodeHeight);
                        //                    //store point for map
                        //                    cc.actualpt = new Point3D(spoint.X, spoint.Y, 0);
                        //                    //debug
                        //                    //TextVisual3D t = new TextVisual3D();
                        //                    //if (cc.ishorizontal)
                        //                    //{
                        //                    //    t.Text = "H";
                        //                    //}
                        //                    //else
                        //                    //{
                        //                    //    t.Text = "V";
                        //                    //}
                        //                    //t.Foreground = new SolidColorBrush(ColorHelper.HsvToColor(cindex, colsaturation, colvallue));
                        //                    //t.TextDirection = new Vector3D(1, 0, 0);
                        //                    //t.UpDirection = new Vector3D(0, 1, 0);
                        //                    //t.Height = PUPPIGUISettings.solidConnectionSize;
                        //                    //t.Position = cc.actualpt;
                        //                    //dg.Children.Add(t);
                        //                    //end debug
                        //                    allconnlines.Add(cc);
                        //                }

                        //            }
                        //        }
                        //    }


                        //    spoint.Offset(v3d.X, v3d.Y, v3d.Z);
                        //    //need to reset the vector since now the points are added
                        //    v3d = new Vector3D();

                        //}
                        //#endregion



                        //for custom nodes
                        ModViz3DOutput sO = sourcenode.vizoutputs[sourceoutindex];



                        if (sO.isCustom)
                        {
                            Point3D wH = sO.myBB.rectcenter();
                            if (mypath.startpoint.DistanceTo(wH) > 0)
                            {
                                if (PUPPIGUISettings.connectionRenderMode == PUPPIGUISettings.ConnModeEnum.Solid)
                                    meshBuilder.AddPipe(wH, mypath.startpoint, 0, PUPPIGUISettings.solidConnectionSize, PUPPIGUISettings.pipeSides);
                                else
                                    lv.Points.Insert(0, wH);
                                lv.Points.Insert(1, mypath.startpoint);
                                actualCPoints.Insert(0, wH);
                            }
                        }

                        ModViz3DInput dO = destnode.vizinputs[destinindex];

                        if (dO.isCustom)
                        {
                            Point3D wH = dO.myBB.rectcenter();
                            if (lCP.DistanceTo(wH) > 0)
                            {
                                if (PUPPIGUISettings.connectionRenderMode == PUPPIGUISettings.ConnModeEnum.Solid)
                                    meshBuilder.AddPipe(wH, lCP, 0, PUPPIGUISettings.solidConnectionSize, PUPPIGUISettings.pipeSides);
                                else
                                    lv.Points.Add(lCP);
                                lv.Points.Add(wH);
                                actualCPoints.Add(wH);
                            }
                        }
                        //Point3D startpos = sourcenode.vizoutputs[sourceoutindex].Content.getboxcenter();
                        //Point3D endpos = destnode.vizinputs[destinindex].Content.getboxcenter();
                        //meshBuilder.AddArrow(startpos, endpos, 0.05, 0.1); 

                        var mesh = meshBuilder.ToMesh(true);
                        GeometryModel3D newModel = new GeometryModel3D();
                        newModel.Geometry = mesh;
                        //gets its output number connections index


                        if (PUPPIGUISettings.connectionRenderMode == PUPPIGUISettings.ConnModeEnum.Solid)
                        {
                            newModel.Material = MaterialHelper.CreateMaterial(ColorHelper.HsvToColor(cindex, colsaturation, colvallue));
                            //new DiffuseMaterial(Brushes.DarkViolet);
                            myself = new ModelVisual3D();
                            myself.Content = newModel;
                        }
                        else
                        {
                            lv.Color = ColorHelper.HsvToColor(cindex, colsaturation, colvallue);
                            //lv.DepthOffset = 1;
                            lv.Thickness = PUPPIGUISettings.wireConnectionSize;
                            myself = lv;
                        }

                        myself.SetName("Conn_" + oconnindex.ToString() + "_" + sourcenode.nodeGUID.ToString() + "_" + sourceoutindex.ToString() + "_" + destnode.nodeGUID.ToString() + "_" + destinindex.ToString());
                        //for debugging
                        //  myself.Children.Add(dg);

                        myview.Children.Add(myself);
                        if (destnode.vizinputs[destinindex].myconnector == null)
                        {
                            destnode.vizinputs[destinindex].myconnector = this;
                        }
                        //add to output connection list

                        if (sourcenode.vizoutputs[sourceoutindex].outboundconns.Contains(this) == false)
                        {

                            sourcenode.vizoutputs[sourceoutindex].outboundconns.Add(this);
                        }
                        //update connection location matrices
                        //first get the horizontal and vertical components
                        //  hconns = getfootprints(true);
                        // vconns = getfootprints(false);
                    }
                    else
                    {
                        //still need to update matrix and connections
                        d2collisionmodel.updateconnPointsmatrixcount(d2collisionmodel.canvaslevelmaporigin, basePoints, connectorpath.hconncount, connectorpath.vconncount, connectorpath.hconnmaze, connectorpath.vconnmaze, PUPPIGUISettings.nodeSpacing);
                    }

                    //update matrices with number of connections for vertical and horizontal
                    //d2collisionmodel.updateconnmatrixcount(d2collisionmodel.canvaslevelmaporigin, hconns, connectorpath.hconncount, connectorpath.hconnmaze, PUPPIGUISettings.nodeSpacing);
                    //d2collisionmodel.updateconnmatrixcount(d2collisionmodel.canvaslevelmaporigin, vconns, connectorpath.vconncount, connectorpath.vconnmaze, PUPPIGUISettings.nodeSpacing);
                    //save images
                    //Visual2DExtensions.saveHconn(Visual2DExtensions.makeBitmapFromArray(connectorpath.hconncount));
                    //Visual2DExtensions.saveVconn(Visual2DExtensions.makeBitmapFromArray(connectorpath.vconncount));
                    //Visual2DExtensions.saveHmaze(Visual2DExtensions.makeBitmapFromArray(connectorpath.hconnmaze));
                    //Visual2DExtensions.saveVmaze(Visual2DExtensions.makeBitmapFromArray(connectorpath.vconnmaze));  

                    //update node boxes
                    sourcebox = sourcenode.vizoutputs[sourceoutindex].myBB;
                    destbox = destnode.vizinputs[destinindex].myBB;

                    // destbox = destnode.boundingBox;
                    basebox = sourcenode.getroot().boundingBox;

                    if (PUPPIDebugger.debugenabled == true)
                    {
                        PUPPIDebugger.log(utils.StringConstants.finisheddrawingconn + sourcenode.nodeGUID.ToString() + " output " + sourceoutindex.ToString() + " to node " + destnode.nodeGUID.ToString() + " input " + destinindex.ToString());

                    }
                }
                catch (Exception exy)
                {
                    if (PUPPIDebugger.debugenabled == true)
                    {
                        PUPPIDebugger.log(utils.StringConstants.failedtodrawarrow + exy.ToString());

                    }
                    //throw new Exception(utils.StringConstants.failedtodrawarrow + exy.ToString());
                }
                if (mycanvas != null)
                {
                    mycanvas.lastChanged = DateTime.Now;
                    //when hidden nodes not exported connections also not exported
                    if ((PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning || PUPPIruntimesettings.PUPPICanvasHTTPServerIsRunning) && PUPPIGUISettings.serverExportHiddenNodes)
                    {
                        PUPPICanvas.currentCanvasStatusServer = mycanvas.readMyCanvasStatus();
                        mycanvas.saveReponThread();
                        // mycanvas.updateNodeInfoServer();  
                    }
                }
            }



            //gets the base, if any, both input and output nodes share
            internal ModViz3DNode getcommonbase()
            {

                ModViz3DNode b1 = sourcenode;
                ModViz3DNode b2 = destnode;
                List<ModViz3DNode> l1 = new List<ModViz3DNode>();
                List<ModViz3DNode> l2 = new List<ModViz3DNode>();
                while (b1 != null)
                {
                    l1.Add(b1);
                    b1 = b1.parent;

                }
                while (b2 != null)
                {
                    l2.Add(b2);
                    b2 = b2.parent;

                }
                for (int tl1 = 0; tl1 < l1.Count; tl1++)

                //foreach (ModViz3DNode t1 in l1)
                {
                    ModViz3DNode t1 = l1[tl1];
                    for (int tl2 = 0; tl2 < l2.Count; tl2++)
                    //  foreach (ModViz3DNode t2 in l2)
                    {
                        ModViz3DNode t2 = l2[tl2];

                        if (t1 == t2) return t1;
                    }
                }
                return null;

            }
            public override string ToString()
            {

                string myGUID = visualGUID;

                string mySnode = "";
                if (sourcenode != null)
                    mySnode = sourcenode.nodeGUID.ToString();

                string myDnode = "";
                if (destnode != null)
                    myDnode = destnode.nodeGUID.ToString();

                string mySindex = sourceoutindex.ToString();

                string myDindex = destinindex.ToString();




                string myPoints = "{";
                int i = 0;
                foreach (Point3D p in actualCPoints)
                {

                    myPoints = myPoints + p.X.ToString() + "," + p.Y.ToString() + "," + p.Z.ToString();
                    if (i < actualCPoints.Count - 1)
                        myPoints += ":|:";
                    i++;
                }
                myPoints += "}";
                return "[GUID:]" + visualGUID + "_|_[SNodeGUID:]" + mySnode + "_|_[DNodeGUID:]" + myDnode + "_|_[OutputIndex:]" + myDindex + "_|_[InputIndex:]" + myDindex + "_|_[Points:]" + myPoints;
            }

        }
        //blocks of nodes
        internal class BlockOfNodes
        {
            internal Rect3D boundingbox;

            internal Dictionary<string, ModViz3DNode> blockstacks;
            internal BlockOfNodes(Dictionary<string, ModViz3DNode> feedstacks)
            {
                blockstacks = feedstacks;
                calculatebbox();
            }
            internal BlockOfNodes()
            {
                blockstacks = new Dictionary<string, ModViz3DNode>();

            }
            internal void calculatebbox()
            {
                d2collisionmodel levelredo = new d2collisionmodel();
                foreach (ModViz3DNode mv in blockstacks.Values)
                {
                    if (mv.parent == null)
                    {
                        ////just in case
                        if (mv.myself != null)
                        {
                            levelredo.footprints.Add(mv.boundingBox);
                        }
                    }
                }
                levelredo.recalculate_perimeter();
                boundingbox = levelredo.region_perimeter;
            }
            internal void fitblockroots()
            {
                foreach (ModViz3DNode mr in blockstacks.Values)
                {
                    if (mr.parent == null) mr.fitroots(blockstacks);

                }
                calculatebbox();
            }
            internal int countroots()
            {
                int rc = 0;
                foreach (ModViz3DNode mv in blockstacks.Values)
                {
                    if (mv.parent == null)
                    {
                        ////just in case
                        if (mv.myself != null)
                        {
                            rc++;
                        }
                    }
                }
                return rc;
            }
            internal void movewholeblock(Point3D newlocation)
            {
                foreach (ModViz3DNode mv in blockstacks.Values)
                {
                    if (mv.parent == null)
                    {
                        mv.movestack(newlocation.X - mv.boundingBox.rectcenter().X, newlocation.Y - mv.boundingBox.rectcenter().Y);
                    }
                }
            }
            //splits a stack dictionary into blocks by position
            internal static List<BlockOfNodes> splitintoblocks(Dictionary<string, ModViz3DNode> allstacks)
            {
                List<BlockOfNodes> result = new List<BlockOfNodes>();
                BlockOfNodes bobo = new BlockOfNodes(allstacks);
                int totalroots = bobo.countroots();
                //split into rectangular block areas
                if (totalroots <= 0 || bobo.boundingbox.IsEmpty) return result;

                int ratio = (int)(bobo.boundingbox.SizeX / bobo.boundingbox.SizeY);
                //get roughly how many on side
                int hcount = (int)Math.Sqrt(totalroots / ratio);
                int wcount = hcount * ratio;
                //might need to make this a constant
                int splitx = wcount / 5 + 1;
                int splity = hcount / 5 + 1;
                //get the whole thing
                if (splitx == 1 && splity == 1)
                {
                    result.Add(bobo);
                    return result;
                }
                double deltax = bobo.boundingbox.SizeX / splitx;
                double deltay = bobo.boundingbox.SizeY / splity;

                //get a 2d array of lists of rectangles
                BlockOfNodes[,] blocks = new BlockOfNodes[splitx, splity];
                for (int i = 0; i < splitx; i++)
                {
                    for (int j = 0; j < splity; j++)
                    {
                        blocks[i, j] = new BlockOfNodes();
                    }
                }
                foreach (ModViz3DNode toblock in allstacks.Values)
                {
                    if (toblock.parent == null)
                    {
                        Point3D tbcenter = toblock.boundingBox.rectcenter();
                        int posx = Convert.ToInt16(Math.Floor((tbcenter.X - bobo.boundingbox.Location.X) / deltax));
                        int posy = Convert.ToInt16(Math.Floor((tbcenter.Y - bobo.boundingbox.Location.Y) / deltay));
                        blocks[posx, posy].blockstacks.Add(toblock.nodeGUID.ToString(), toblock);
                    }
                }
                //convert to list
                for (int s1 = 0; s1 < splitx; s1++)
                {
                    for (int s2 = 0; s2 < splity; s2++)
                    {
                        if (blocks[s1, s2].countroots() > 0) result.Add(blocks[s1, s2]);
                    }
                }


                return result;

            }
        }

        internal class ModViz3DNode
        {
            internal bool isSolid = true;
            internal bool hiddenOnLockedCanvas = false;
            internal int number_outbound_connections = 0;
            //to test for infinte recursion
            internal static long testiter = 0;
            //base add order
            internal int baseindex = 0;
            internal List<ModViz3DNode> childs;
            internal PUPPIModule logical_representation;
            internal TextVisual3D caption;
            //node's custom renderer
            internal PUPPINodeCustomRenderer nodeCustomRenderer;
            internal ModelVisual3D myself;
            internal List<ModViz3DInput> vizinputs;
            internal List<ModViz3DOutput> vizoutputs;
            internal ModViz3DNode parent;
            internal Material nodeUpdatedMaterial;
            internal static int GUIDcount = 0;
            internal int nodeGUID { get; set; }
            internal HelixViewport3D myview;
            internal PUPPICanvas mycanvas;
            //need to store this somewhere when initializing for xml
            internal Point3D myposition;
            //as transforms are added this stores initial position 
            // internal Point3D myoriginalposition;
            //number of inputs and outputs 
            //gotten from up going down. 
            internal int numconn;
            //if it handles outputs and inputs as lists
            internal int list_level = 0;
            //this is what shows up on screen
            internal string displayname = "";
            //need to store the actual bounding box of the node representation without captions or inputs
            internal Rect3D boundingBox;
            //start of gesture over node
            internal double xGestureStart;
            internal double yGestureStart;
            internal double zGestureStart;
            internal DateTime creationTime;
            //if the node has a script
            //internal string script = "";
            //parameterless for serialization
            internal ModViz3DNode()
            {
                childs = new List<ModViz3DNode>();
                vizinputs = new List<ModViz3DInput>();
                vizoutputs = new List<ModViz3DOutput>();
                mycanvas = null;
                myview = null;
                myself = null;
                boundingBox = new Rect3D();
                parent = null;
                //this gets rewritten upon load anyway
                //but still needs to be changed manually for others 
                nodeGUID = 0;

                myposition = new Point3D();
                //myoriginalposition = new Point3D(); 
                hiddenOnLockedCanvas = false;
                creationTime = DateTime.Now;

            }

            public override string ToString()
            {
                string logi = "";
                if (logical_representation == null) logi = "null"; else logi = logical_representation.GetType().FullName.ToString();
                string bobox = "";
                if (boundingBox == null) bobox = "null"; else bobox = boundingBox.ToString();
                string pr = "";
                if (parent == null) pr = "null"; else pr = parent.nodeGUID.ToString();
                string ncr = "";
                if (nodeCustomRenderer == null) ncr = "null"; else ncr = nodeCustomRenderer.name;
                return "[Node GUID:]" + nodeGUID.ToString() + "_|_[Caption:]" + displayname + "_|_[Module:]" + logi + "_|_[Bounding Box:]" + bobox + "_|_[Parent:]" + pr + "_|_[Number Children:]" + childs.Count.ToString() + "_|_[Hidden On Locked Canvas:]" + hiddenOnLockedCanvas.ToString() + "_|_[Node Custom Renderer:]" + ncr;

            }

            internal void exportMyNRenderer()
            {

                if (PUPPIDebugger.debugenabled)
                {
                    PUPPIDebugger.log("Started exporting node renderer information for " + nodeGUID.ToString());
                }

                string sr = "notexporting";
                string objr = "notexporting";
                string stlr = "";
                PUPPINodeCustomRenderer ncr = nodeCustomRenderer;
                if (ncr == null) return;
                string stllines = "";
                List<Model3D> lmod = new List<Model3D>();
                if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {

                    if (ncr.model2D == null)
                    {
                        return;
                    }
                    string rootName = "R" + ncr.name + "N" + nodeGUID.ToString();

                    ModelVisual3D n2d = ncr.model2D.cloneMyVisual();

                    if (PUPPIGUISettings.ServerExportImage)
                        sr = PUPPICAD.HelperClasses.utilities.renderModelVisual3D(n2d, "", rootName);


                    if (PUPPIGUISettings.ServerExportOBJ)
                    {
                        ModelVisual3D n2d1 = ncr.model2D.cloneMyVisual();
                        objr = PUPPICAD.HelperClasses.utilities.saveModelVisual3DAsOBJ(n2d1, rootName);
                    }

                    if (PUPPIGUISettings.ServerexportSTLA)
                    {
                        ArrayList linesA = new ArrayList();

                        PUPPICAD.HelperClasses.helperfunctions.writegeomSTLrecursivelyWT(n2d, linesA, "R" + ncr.name + "N" + nodeGUID.ToString(), new Transform3DGroup());

                        for (int i = 0; i < linesA.Count; i++)
                        {
                            string line = linesA[i].ToString();
                            stllines += "\n" + line;
                        }
                    }
                    if (PUPPIGUISettings.ServerSaveModel3D)
                    {
                        n2d.cloneMyVisualFreezable(lmod);
                    }
                }
                else
                {
                    if (ncr.model3D == null)
                    {
                        return;
                    }
                    string rootName = "R" + ncr.name + "N" + nodeGUID.ToString();

                    ModelVisual3D n3d = ncr.model3D.cloneMyVisual();

                    if (PUPPIGUISettings.ServerExportImage)
                        sr = PUPPICAD.HelperClasses.utilities.renderModelVisual3D(n3d, "", rootName);
                    if (PUPPIGUISettings.ServerExportOBJ)
                    {
                        ModelVisual3D n3d1 = ncr.model3D.cloneMyVisual();
                        objr = PUPPICAD.HelperClasses.utilities.saveModelVisual3DAsOBJ(n3d1, rootName);
                    }

                    if (PUPPIGUISettings.ServerexportSTLA)
                    {
                        ArrayList linesA = new ArrayList();
                        // ModelVisual3D n3d1 = ncr.model3D.cloneMyVisual();
                        PUPPICAD.HelperClasses.helperfunctions.writegeomSTLrecursivelyWT(n3d, linesA, "R" + ncr.name + "N" + nodeGUID.ToString(), new Transform3DGroup());

                        for (int i = 0; i < linesA.Count; i++)
                        {
                            string line = linesA[i].ToString();
                            stllines += "\n" + line;
                        }
                    }
                    if (PUPPIGUISettings.ServerSaveModel3D)
                    {
                        n3d.cloneMyVisualFreezable(lmod);
                    }
                }

                if ((PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning || PUPPIruntimesettings.PUPPICanvasHTTPServerIsRunning) && PUPPIruntimesettings.PUPPICanvasServerUpdatingFully && sr != "" && sr != "notexporting")
                {
                    if (PUPPICanvas.nodeRendererImageFilesServer.ContainsKey(nodeGUID.ToString()))
                    {
                        PUPPICanvas.nodeRendererImageFilesServer[nodeGUID.ToString()] = sr;
                    }
                    else
                    {
                        PUPPICanvas.nodeRendererImageFilesServer.TryAdd(nodeGUID.ToString(), sr);
                    }
                }
                if ((PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning || PUPPIruntimesettings.PUPPICanvasHTTPServerIsRunning) && PUPPIruntimesettings.PUPPICanvasServerUpdatingFully && stllines != "")
                {
                    if (PUPPICanvas.nodeRendererSTLServer.ContainsKey(nodeGUID.ToString()))
                    {
                        PUPPICanvas.nodeRendererSTLServer[nodeGUID.ToString()] = stllines;
                    }
                    else
                    {
                        PUPPICanvas.nodeRendererSTLServer.TryAdd(nodeGUID.ToString(), stllines);
                    }
                }
                if ((PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning || PUPPIruntimesettings.PUPPICanvasHTTPServerIsRunning) && PUPPIruntimesettings.PUPPICanvasServerUpdatingFully && stllines != "")
                {
                    if (PUPPICanvas.nodeRendererOBJFolderServer.ContainsKey(nodeGUID.ToString()))
                    {
                        PUPPICanvas.nodeRendererOBJFolderServer[nodeGUID.ToString()] = objr;
                    }
                    else
                    {
                        PUPPICanvas.nodeRendererOBJFolderServer.TryAdd(nodeGUID.ToString(), objr);
                    }
                }
                if ((PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning || PUPPIruntimesettings.PUPPICanvasHTTPServerIsRunning) && PUPPIruntimesettings.PUPPICanvasServerUpdatingFully && lmod.Count > 0)
                {
                    if (PUPPICanvas.nodeRendererModel3DServer.ContainsKey(nodeGUID.ToString()))
                    {
                        PUPPICanvas.nodeRendererModel3DServer[nodeGUID.ToString()] = lmod;
                    }
                    else
                    {
                        PUPPICanvas.nodeRendererModel3DServer.TryAdd(nodeGUID.ToString(), lmod);


                    }
                }


                if (PUPPIDebugger.debugenabled)
                {
                    PUPPIDebugger.log("Finished exporting node renderer information for " + nodeGUID.ToString());
                }
            }

            internal void setNodeHiddenLockedCanvasStatus(bool ss)
            {
                hiddenOnLockedCanvas = ss;
                if (ss == true)
                {

                    List<ModViz3DNode> mc = new List<ModViz3DNode>();
                    getalllevelschildren(mc);
                    foreach (ModViz3DNode m in mc)
                    {
                        m.hiddenOnLockedCanvas = ss;
                    }
                }
                else
                {
                    ModViz3DNode mao = getparentaboveroot();
                    if (mao != null)
                    {
                        mao.parent.hiddenOnLockedCanvas = ss;
                        List<ModViz3DNode> mc = new List<ModViz3DNode>();
                        mao.parent.getalllevelschildren(mc);
                        foreach (ModViz3DNode m in mc)
                        {
                            m.hiddenOnLockedCanvas = ss;
                        }
                    }
                }
            }

            internal bool explodeMyContainerNodeOnCanvas()
            {
                PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer pnc = null;
                try
                {
                    pnc = logical_representation as PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer;
                }
                catch
                {
                    pnc = null;
                }
                if (pnc != null)
                {
                    List<ModViz3DNode> la = new List<ModViz3DNode>();
                    return mycanvas.explodeAContainerNode(nodeGUID, out la);
                }
                return false;
            }

            internal bool updateMyInboundConnIDs(int oldInput, int newInput)
            {

                return true;
            }


            //figures out if input is autolist
            internal bool getAutoLStatus(int inpindex)
            {
                if (logical_representation != null && logical_representation.inputs.Count > inpindex && inpindex >= 0)
                {
                    PUPPIInParameter p = logical_representation.inputs[inpindex];
                    if (p != null)
                    {
                        return p.inputAutomaticListMode;
                    }
                }
                return false;
            }
            internal void settAutoLStatus(int inpindex, bool value)
            {
                if (logical_representation != null && logical_representation.inputs.Count > inpindex && inpindex >= 0)
                {
                    PUPPIInParameter p = logical_representation.inputs[inpindex];
                    if (p != null)
                    {
                        logical_representation.inputs[inpindex].inputAutomaticListMode = value;
                    }
                }

            }
            //gets the parentmost node with guid in list
            internal ModViz3DNode getlowestinlistids(List<string> gs)
            {
                if (this.parent != null)
                {
                    if (gs.Contains(this.parent.nodeGUID.ToString()))
                    {
                        return this.parent.getlowestinlistids(gs);
                    }
                }
                if (gs.Contains(this.nodeGUID.ToString())) return this;
                return null;
            }

            //focuses the camera on the node
            internal void focuscameraon()
            {
                HelixViewport3D myhv = null;
                if (myview != null)
                {
                    myhv = myview;
                }
                else if (mycanvas != null)
                {
                    myhv = mycanvas.hv;
                }
                else
                {
                    return;
                }
                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    ProjectionCamera mytestcamera = myhv.Camera;
                    mytestcamera.Position = new Point3D(myposition.X, myposition.Y - 5 * PUPPIGUISettings.nodeSide, myposition.Z);
                    Vector3D lookme = Point3D.Subtract(myposition, mytestcamera.Position);
                    mytestcamera.LookDirection = lookme;
                    Vector3D flatme = new Vector3D(lookme.X, lookme.Y, 0);
                    Vector3D rightdir = Vector3D.CrossProduct(flatme, new Vector3D(0, 0, 1));
                    mytestcamera.UpDirection = Vector3D.CrossProduct(rightdir, lookme);

                    mytestcamera.FarPlaneDistance = PUPPIGUISettings.cameraFarPlaneDistance;
                    myhv.Camera = mytestcamera;
                }
                else
                {
                    myhv.Camera.UpDirection = new Vector3D(0, 1, 0);
                    myhv.Camera.Position = new Point3D(myposition.X, myposition.Y, 10);
                    myhv.Camera.LookDirection = new Vector3D(0, 0, -1);
                }

            }

            //with just logic so we can check if more exist
            //internal bool ModViz3DNode(PUPPICanvas pc,PUPPIModule pm) 
            //{
            //    bool created = true;
            //    if (pm!=null)
            //    {
            //        //check if we can add it, if it doesn't already exist
            //        if (pm.unique==true)
            //        {
            //            if (pc.contains_unique_node(pm))
            //            {
            //                return false;
            //            }
            //            else
            //            {
            //                pc.unique_nodes.Add(pm);  
            //            }
            //        }
            //    }
            //    logical_representation = pm; 
            //    childs = new List<ModViz3DNode>();
            //    vizinputs = new List<ModViz3DInput>();
            //    vizoutputs = new List<ModViz3DOutput>();
            //    mycanvas = pc;
            //    myview = pc.hv ;
            //    myself = null;

            //    parent = null;
            //    //this gets rewritten upon load anyway
            //    //but still needs to be changed manually for others 
            //    nodeGUID = 0;

            //    myposition = new Point3D();
            //    return created;

            //}

            //without logic
            internal ModViz3DNode(Rect3D newbounds, PUPPICanvas origincanvas)//HelixViewport3D d3view)
            {

                childs = new List<ModViz3DNode>();
                vizinputs = new List<ModViz3DInput>();
                vizoutputs = new List<ModViz3DOutput>();
                mycanvas = origincanvas;
                myview = origincanvas.hv;
                myself = addbox(newbounds, mycanvas.node_default_mat);
                boundingBox = newbounds;
                myposition = boundingBox.rectcenter();
                parent = null;
                nodeGUID = GUIDcount;
                myself.SetName(nodeGUID.ToString());
                GUIDcount++;
                hiddenOnLockedCanvas = false;
                creationTime = DateTime.Now;
                //if (PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning && origincanvas!=null  )
            }
            //write an XML physical representation
            internal XmlNode writeXMLNodeRep()
            {

                XmlDocument d = new XmlDocument();

                XmlNode nem = d.CreateNode(XmlNodeType.Element, "node", "");
                XmlNode gem = d.CreateNode(XmlNodeType.Element, "guid", "");
                gem.InnerText = nodeGUID.ToString();
                nem.AppendChild(gem);
                XmlNode del = d.CreateNode(XmlNodeType.Element, "displayname", "");
                del.InnerText = displayname;
                nem.AppendChild(del);
                XmlNode bab = d.CreateNode(XmlNodeType.Element, "box", "");
                //has a BB
                if (boundingBox != null && boundingBox.SizeX > 0 && boundingBox.SizeY > 0)
                {
                    bab.InnerText = boundingBox.X.ToString() + "_" + boundingBox.Y.ToString() + "_" + boundingBox.Z.ToString() + "_" + boundingBox.SizeX.ToString() + "_" + boundingBox.SizeY.ToString() + "_" + boundingBox.SizeZ.ToString();
                }
                else
                {
                    bab.InnerText = myposition.X.ToString() + "_" + myposition.Y.ToString() + "_" + myposition.Z.ToString() + "_0_0_0";
                }



                XmlNode pem = d.CreateNode(XmlNodeType.Element, "PUPPImodule", "");
                if (logical_representation != null)
                {
                    pem.InnerText = logical_representation.GetType().ToString();
                }
                nem.AppendChild(pem);

                //array level - written after module
                XmlNode ll = d.CreateNode(XmlNodeType.Element, "listlevel", "");
                ll.InnerText = list_level.ToString();
                nem.AppendChild(ll);


                XmlNode par = d.CreateNode(XmlNodeType.Element, "parentguid", "");
                if (parent != null)
                {
                    par.InnerText = parent.nodeGUID.ToString();
                }
                else
                {
                    par.InnerText = "";
                }
                nem.AppendChild(par);

                XmlNode holc = d.CreateNode(XmlNodeType.Element, "hidden", "");
                holc.InnerText = this.hiddenOnLockedCanvas.ToString();
                nem.AppendChild(ll);


                ////script 
                //XmlNode scxml = d.CreateNode(XmlNodeType.Element, "nodeScript", "");
                //scxml.InnerText = script;
                //nem.AppendChild(scxml);

                //XmlNode lol = d.CreateNode(XmlNodeType.Element, "listlevel", "");
                //lol.InnerText = list_level.ToString();
                //nem.AppendChild(lol);

                for (int inc = 0; inc < logical_representation.inputs.Count; inc++)
                {
                    //write inputs
                    PUPPIInParameter ppi = logical_representation.inputs[inc];
                    if (ppi == null) continue;
                    if (ppi.module == null) continue;
                    XmlNode col = d.CreateNode(XmlNodeType.Element, "input", "");



                    XmlNode iel = d.CreateNode(XmlNodeType.Element, "inputindex", "");
                    iel.InnerText = inc.ToString();
                    col.AppendChild(iel);

                    ModViz3DInput miv = vizinputs[inc];
                    XmlNode ibab = d.CreateNode(XmlNodeType.Element, "inputbox", "");
                    //has a BB
                    if (miv != null && miv.myBB != null && miv.myBB.SizeX > 0 && miv.myBB.SizeY > 0)
                    {
                        ibab.InnerText = miv.myBB.X.ToString() + "_" + miv.myBB.Y.ToString() + "_" + miv.myBB.Z.ToString() + "_" + miv.myBB.SizeX.ToString() + "_" + miv.myBB.SizeY.ToString() + "_" + miv.myBB.SizeZ.ToString();
                    }
                    else
                    {
                        ibab.InnerText = miv.myPosition.X.ToString() + "_" + miv.myPosition.Y.ToString() + "_" + miv.myPosition.Z.ToString() + "_0_0_0";
                    }
                    col.AppendChild(ibab);
                    //name and value to be able to display these
                    XmlNode iin = d.CreateNode(XmlNodeType.Element, "inputname", "");
                    iin.InnerText = miv.visualInputNameString;
                    col.AppendChild(iin);

                    XmlNode iiv = d.CreateNode(XmlNodeType.Element, "inputvalue", "");
                    iiv.InnerText = miv.visualInputValueString;
                    col.AppendChild(iiv);

                    XmlNode inineme = d.CreateNode(XmlNodeType.Element, "inputnodeguid", "");
                    if (ppi.module != null) { inineme.InnerText = ppi.module.GUID.ToString(); }
                    else
                    {
                        inineme.InnerText = "";
                    }
                    col.AppendChild(inineme);

                    XmlNode opa = d.CreateNode(XmlNodeType.Element, "inputoutputindex", "");
                    opa.InnerText = ppi.outParIndex.ToString();
                    col.AppendChild(opa);

                    XmlNode ove = d.CreateNode(XmlNodeType.Element, "inputautolistmode", "");
                    ove.InnerText = logical_representation.inputs[inc].inputAutomaticListMode.ToString();
                    col.AppendChild(ove);

                    nem.AppendChild(col);
                }

                for (int outs = 0; outs < logical_representation.outputs.Count; outs++)
                {
                    ModViz3DOutput mov = vizoutputs[outs];
                    if (mov == null) continue;
                    if (logical_representation.outputs[outs] == null) continue;
                    XmlNode ote = d.CreateNode(XmlNodeType.Element, "output", "");
                    //index
                    XmlNode ole = d.CreateNode(XmlNodeType.Element, "outputindex", "");
                    ole.InnerText = outs.ToString();
                    ote.AppendChild(ole);
                    //name and value to be able to display these
                    XmlNode iin = d.CreateNode(XmlNodeType.Element, "outputname", "");
                    iin.InnerText = mov.visualOutputNameString;
                    ote.AppendChild(iin);

                    XmlNode iiv = d.CreateNode(XmlNodeType.Element, "outputvalue", "");
                    iiv.InnerText = mov.visualOutputValueString;
                    ote.AppendChild(iiv);

                    nem.AppendChild(ote);
                }


                return nem;
            }

            internal void setMyPUPPINodeUpdatedMaterialColor(double redColorFraction, double greenColorFraction, double blueColorFraction, double alphaColorFraction)
            {
                SolidColorBrush iobro = new SolidColorBrush();
                iobro.Color = Color.FromArgb(Convert.ToByte(255 * alphaColorFraction), Convert.ToByte(255 * redColorFraction), Convert.ToByte(255 * greenColorFraction), Convert.ToByte(255 * blueColorFraction));
                nodeUpdatedMaterial = new DiffuseMaterial(iobro);

            }

            //with logic
            internal ModViz3DNode(Rect3D newbounds, PUPPIModule logic, PUPPICanvas origincanvas)// HelixViewport3D d3view)
            {
                childs = new List<ModViz3DNode>();
                mycanvas = origincanvas;
                myview = origincanvas.hv;
                myself = addbox(newbounds, mycanvas.node_default_mat);
                boundingBox = newbounds;
                myposition = boundingBox.rectcenter();
                parent = null;
                nodeGUID = GUIDcount;

                myself.SetName(nodeGUID.ToString());
                GUIDcount++;

                vizinputs = new List<ModViz3DInput>();
                vizoutputs = new List<ModViz3DOutput>();
                if (logic.cleancap != "")
                {
                    displayname = logic.cleancap;
                }
                else
                {
                    displayname = logic.name;
                }
                hiddenOnLockedCanvas = false;
                setlogic(logic);
                creationTime = DateTime.Now;
            }

            internal void addstacktoselection()
            {
                if (mycanvas.selstacks.Contains(nodeGUID.ToString()) == false)
                {
                    mycanvas.selstacks.Add(nodeGUID.ToString());
                    (myself.Content as GeometryModel3D).Material = mycanvas.node_selected_default_mat;
                }
                List<ModViz3DNode> c = new List<ModViz3DNode>();
                getalllevelschildren(c);
                foreach (ModViz3DNode m in c)
                {
                    if (mycanvas.selstacks.Contains(m.nodeGUID.ToString()) == false)
                    {
                        mycanvas.selstacks.Add(m.nodeGUID.ToString());
                        (m.myself.Content as GeometryModel3D).Material = mycanvas.node_selected_default_mat;
                    }
                }
            }

            internal void removestackfromselection()
            {
                //will get the entire stack unselected
                ModViz3DNode b = getroot();

                if (mycanvas.selstacks.Contains(b.nodeGUID.ToString()))
                {
                    mycanvas.selstacks.Remove(b.nodeGUID.ToString());
                    if (b.nodeCustomRenderer == null)
                    {
                        if (b.nodeUpdatedMaterial == null)
                        {
                            (b.myself.Content as GeometryModel3D).Material = mycanvas.node_default_mat;
                        }
                        else
                        {
                            (b.myself.Content as GeometryModel3D).Material = b.nodeUpdatedMaterial;
                        }
                    }
                }

                List<ModViz3DNode> c = new List<ModViz3DNode>();
                b.getalllevelschildren(c);
                foreach (ModViz3DNode m in c)
                {

                    if (mycanvas.selstacks.Contains(m.nodeGUID.ToString()))
                    {
                        mycanvas.selstacks.Remove(m.nodeGUID.ToString());
                        if (m.nodeCustomRenderer == null)
                        {
                            if (m.nodeUpdatedMaterial == null)
                            {
                                (m.myself.Content as GeometryModel3D).Material = mycanvas.node_default_mat;
                            }
                            else
                            {
                                (m.myself.Content as GeometryModel3D).Material = m.nodeUpdatedMaterial;
                            }
                        }
                    }
                }
            }
            //copies node to clipboard
            internal void copytoclip()
            {

                if (!uniquenodeduplicates())
                {
                    mycanvas.update_clipboard_singlestack(clonestack(false), true);
                    mycanvas.deselectallnodes();
                }
                else
                {
                    MessageBox.Show("One or more nodes attempting to copy to clipboard have unique modules which already exist on the canvas.");
                }
            }
            //checks if the stack already has an unique node
            bool uniquenodeduplicates()
            {
                List<ModViz3DNode> gh = new List<ModViz3DNode>();
                getalllevelschildren(gh);
                gh.Add(this);
                for (int i = 0; i < gh.Count; i++)
                {
                    if (gh[i].mycanvas.contains_unique_node(gh[i].logical_representation)) return true;
                }
                return false;
            }
            //compares if 
            //creates a new node stack from an existing node and its children
            //stack is vertical so it can be added anywhere
            //if paste mode we also activate conenctions
            internal ModViz3DNode clonestack(bool pastemode)
            {
                ModViz3DNode soma = cloneme();
                //keep ref to original
                ModViz3DNode boma = soma;
                List<ModViz3DNode> gh = new List<ModViz3DNode>();

                //list with old refs and new refs so we can check same connections
                Dictionary<string, ModViz3DNode> olds = new Dictionary<string, ModViz3DNode>();
                Dictionary<string, ModViz3DNode> news = new Dictionary<string, ModViz3DNode>();
                olds.Add(this.nodeGUID.ToString(), this);
                news.Add(this.nodeGUID.ToString(), boma);

                getalllevelschildren(gh);
                for (int ii = 0; ii < gh.Count; ii++)
                // foreach (ModViz3DNode k in gh)
                {
                    olds.Add(gh[ii].nodeGUID.ToString(), gh[ii]);
                    ModViz3DNode nc = gh[ii].cloneme();
                    news.Add(gh[ii].nodeGUID.ToString(), nc);
                    //add it as a child to appropriate parent
                    //if (boma.parent)
                    news[gh[ii].parent.nodeGUID.ToString()].addnodechild(nc);
                    // soma.addnodechild(nc);
                    // soma = nc;
                }
                //now go through new nodes, see what they are linked to in old nodes, and link to corresposnding new node
                foreach (ModViz3DNode newcon in news.Values)
                {



                    for (int pinpcount = 0; pinpcount < newcon.logical_representation.inputs.Count; pinpcount++)
                    {
                        PUPPIInParameter pinp = new PUPPIInParameter();

                        //check if we found anything in copied stack otherwise we make it null


                        if (newcon.logical_representation.inputs[pinpcount].module != null && olds.ContainsKey(newcon.logical_representation.inputs[pinpcount].module.GUID.ToString()))
                        {
                            ModViz3DNode newmod = news[newcon.logical_representation.inputs[pinpcount].module.GUID.ToString()];
                            string gguid = newcon.logical_representation.inputs[pinpcount].module.GUID.ToString();
                            pinp.module = newmod.logical_representation;
                            pinp.outParIndex = newcon.logical_representation.inputs[pinpcount].outParIndex;
                            //need to make this null to connect it
                            newcon.logical_representation.inputs[pinpcount] = pinp;
                            //   newcon.logical_representation.connect_input(pinp, pinpcount);

                            if (pastemode == true)
                            {
                                //set up so that when this changes we get a notification
                                newcon.logical_representation.inputs[pinpcount].sourcenodeevent(newmod.logical_representation);
                                //conenct the logic to appropriate events to pass it along to the destination
                                newcon.logical_representation.connectevent(newcon.logical_representation.inputs[pinpcount]);
                            }

                            //if no match in stack but still connects to something we have to disconnect it
                        }
                        else if (newcon.logical_representation.inputs[pinpcount].module != null)
                        {
                            newcon.logical_representation.disconnect_input(pinpcount);
                        }



                    }
                }

                return boma;
            }

            //makes a stack into a vertical tower
            internal void makestackverticaltower()
            {

                List<ModViz3DNode> alc = new List<ModViz3DNode>();
                getalllevelschildren(alc);
                ModViz3DNode soma = this;
                foreach (ModViz3DNode m in alc)
                {
                    m.parent.childs.Remove(m);
                    soma.addnodechild(m);
                    soma = m;

                }

            }


            //gets all children node references in an array
            internal void getalllevelschildren(List<ModViz3DNode> mlist)
            {
                for (int ii = 0; ii < childs.Count; ii++)
                //foreach (ModViz3DNode ch in childs)
                {

                    mlist.Add(childs[ii]);
                    childs[ii].getalllevelschildren(mlist);
                }
            }
            //clones a node into a new instance
            //node still needs to be rendered 
            ModViz3DNode cloneme()
            {
                ModViz3DNode myclone = new ModViz3DNode();
                myclone.caption = caption;
                //custom data
                object pm1 = System.Activator.CreateInstance(logical_representation.GetType());
                string ss = logical_representation.saveSettings();
                if (ss != null && ss != "") (pm1 as PUPPIModule).initOnLoad(ss);
                //the updated caption
                (pm1 as PUPPIModule).cleancap = logical_representation.cleancap;
                myclone.logical_representation = pm1 as PUPPIModule;
                myclone.setRenderer();

                if (this.logical_representation.completeProcessOverride == false)
                {
                    myclone.list_level = list_level;
                    myclone.logical_representation.listprocess = Convert.ToBoolean(list_level);
                    //set the number of list elements to 0 if no list
                    if (list_level == 0) myclone.logical_representation.countListMode = 0;
                    else myclone.logical_representation.countListMode = this.logical_representation.countListMode;

                }


                //get the node input hookups to clone connections too
                //we'll have to link these to new modules when they are created

                for (int i = 0; i < logical_representation.inputs.Count; i++)
                {
                    try
                    {
                        PUPPIInParameter pinp = logical_representation.inputs[i];

                        myclone.logical_representation.inputs[i].module = pinp.module;
                        myclone.logical_representation.inputs[i].outParIndex = pinp.outParIndex;
                        myclone.logical_representation.inputs[i].inputAutomaticListMode = pinp.inputAutomaticListMode;
                    }
                    catch { }
                }



                //update outputs only if no inputs
                if (logical_representation.inputs.Count == 0)
                {
                    for (int i = 0; i < logical_representation.outputs.Count; i++)
                    {
                        try
                        {
                            //get a value type
                            Type ttt = logical_representation.outputs[i].GetType();
                            object oo = logical_representation.outputs[i];
                            myclone.logical_representation.outputs[i] = Convert.ChangeType(oo, ttt);

                        }
                        catch { }
                    }
                }

                //myclone.script = script;
                myclone.displayname = displayname;
                myclone.mycanvas = mycanvas;
                myclone.nodeGUID = ModViz3DNode.GUIDcount;
                myclone.logical_representation.GUID = myclone.nodeGUID;
                myclone.hiddenOnLockedCanvas = hiddenOnLockedCanvas;
                ModViz3DNode.GUIDcount++;

                return myclone;

            }
            //if a renderer for a module is present, it is added to node
            internal void setRenderer()
            {
                if (logical_representation != null && mycanvas != null)
                {
                    if (mycanvas.moduleRenderers.ContainsKey(logical_representation.GetType()))
                    {
                        string rendererName = mycanvas.moduleRenderers[logical_representation.GetType()];
                        if (mycanvas.customRenderers.ContainsKey(rendererName))
                        {
                            nodeCustomRenderer = new PUPPINodeCustomRenderer();
                            nodeCustomRenderer = mycanvas.customRenderers[rendererName].cloneMyPUPPINodeCustomRenderer();

                        }
                    }
                }
            }

            internal void useRenderer()
            {
                //to make a little transparent box in the middle
                double smallBoxSize = PUPPIGUISettings.nodeSide * 0.01;
                if (nodeCustomRenderer != null)
                {
                    if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                    {
                        if (nodeCustomRenderer.use2D == true)
                        {
                            ModelVisual3D replacer = new ModelVisual3D();
                            nodeCustomRenderer.renderCustom();
                            if (myself != null && myself.GetName() != null)
                            {
                                nodeCustomRenderer.model2D.SetName(myself.GetName());
                            }
                            else if (nodeGUID != null)
                            {
                                nodeCustomRenderer.model2D.SetName(nodeGUID.ToString());
                            }

                            Vector3D tranv = Point3D.Subtract(myposition, new Point3D(0, 0, 0));// nodeCustomRenderer.bbox.rectcenter());
                            //try a tiny box in the middle
                            replacer = nodeCustomRenderer.model2D.moveVisualChildren(tranv, myposition.makeSizeBox(smallBoxSize, smallBoxSize, smallBoxSize), mycanvas.customRenderBox_default_mat);
                            if (myself != null)
                            {
                                if (!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas)
                                    myview.Children[myview.Children.IndexOf(myself)] = replacer;
                            }
                            else
                            {
                                if (!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas)
                                    myview.Children.Add(replacer);
                            }
                            myself = replacer;
                            nodeCustomRenderer.displacedBbox = Rect3D.Offset(nodeCustomRenderer.bbox, tranv);

                        }

                    }
                    else
                    {
                        if (nodeCustomRenderer.use3D == true)
                        {
                            ModelVisual3D replacer = new ModelVisual3D();

                            nodeCustomRenderer.renderCustom();
                            if (myself != null && myself.GetName() != null)
                            {
                                nodeCustomRenderer.model3D.SetName(myself.GetName());
                            }
                            else
                            {
                                nodeCustomRenderer.model3D.SetName(nodeGUID.ToString());
                            }

                            Vector3D tranv = Point3D.Subtract(myposition, new Point3D(0, 0, 0));//nodeCustomRenderer.bbox.rectcenter());
                            replacer = nodeCustomRenderer.model3D.moveVisualChildren(tranv, myposition.makeSizeBox(smallBoxSize, smallBoxSize, smallBoxSize), mycanvas.customRenderBox_default_mat);
                            if (myself != null)
                            {
                                if (!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas)
                                    myview.Children[myview.Children.IndexOf(myself)] = replacer;
                            }
                            else
                            {
                                if (!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas)
                                    myview.Children.Add(replacer);
                            }
                            nodeCustomRenderer.displacedBbox = Rect3D.Offset(nodeCustomRenderer.bbox, tranv);
                            myself = replacer;
                        }
                    }
                    //save node image
                    if ((PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning || PUPPIruntimesettings.PUPPICanvasHTTPServerIsRunning) && PUPPIruntimesettings.PUPPICanvasServerUpdatingFully)
                    {
                        exportMyNRenderer();
                    }

                }
            }


            //collapse a node base into a single box
            internal void collapse()
            {
                ModViz3DNode myroot = getroot();
                //remove all the children from stacks

            }
            //removes node and any connections with node from the stacks
            //this means node is still connected
            /*  internal void removefromstack()
                {
                    if (mycanvas!=null )
                    {
                        try
                        {
                            //remove from node stacks
                            mycanvas.stacks.Remove(nodeGUID.ToString()); 
                            //removes the connections from conn list
                            foreach (ModViz3DInput mvin in vizinputs )
                            {
                                if (mvin!=null)
                                {
                                    if (mvin.myconnector!=null )
                                    {
                           

                            if (disinput.myinput.module != null)
                            {
                                try
                                {
                                    disinput.myconnector.deletevisual();
                                    disinput.myconnector = null;
                                    //remove connection from output list
                                    try
                                    {
                                        mycanvas.connpaths["conn_" + disinput.inputVisualGUID].sourcenode.vizoutputs[mycanvas.connpaths["conn_" + disinput.inputVisualGUID].sourceoutindex].outboundconns.Remove(mycanvas.connpaths["conn_" + disinput.inputVisualGUID]);
                                    }
                                    catch
                                    {
                                    }
                                    //mycanvas.connpaths["conn_" + disinput.inputVisualGUID] = null;
                                    mycanvas.connpaths.Remove("conn_" + disinput.inputVisualGUID);
                                    disinput.myinput.module = null;
                                    bool disco = logical_representation.disconnect_input(inputindex);
                                }
                                catch
                                {

                                }
                            }
                        }
                        catch
                        {

                        }
                    }
                }*/

            //if we paste on top of a node
            internal void pasteontopof()
            {
                string myoss = mycanvas.my_old_pc_status;
                //mycanvas.blockconnupdates = true;
                ////make sure we can paste
                //if (acceptschilds() && mycanvas.clipstacks.Values.Count > 0)
                //{
                //    //seems like it doesn't work unless in-outs get updated before connections get updated
                //    List<ModViz3DNode> toUpdate = new List<ModViz3DNode>();
                //    if (parent == null)
                //    {
                //        foreach (ModViz3DNode m in mycanvas.clipstacks.Values)
                //        {
                //            if (m.parent == null)
                //            {
                //                ModViz3DNode newclone = m.clonestack(true);
                //                newclone.makestackverticaltower();
                //                mycanvas.addstacktostack(newclone);

                //                addnodechild(newclone);
                //                renderchildren();

                //                toUpdate.Add(newclone);
                //                List<ModViz3DNode> allc = new List<ModViz3DNode>();
                //                newclone.getalllevelschildren(allc);
                //                toUpdate.AddRange(allc);
                //            }

                //        }
                //    }
                //    //convert the clipboard to a single tower
                //    else
                //    {
                //        Dictionary<string, ModViz3DNode> ts = new Dictionary<string, ModViz3DNode>();
                //        foreach (ModViz3DNode m in mycanvas.clipstacks.Values)
                //        {
                //            if (m.parent == null)
                //            {
                //                ModViz3DNode newclone = m.clonestack(false);
                //                ts.Add(newclone.nodeGUID.ToString(), newclone);
                //                List<ModViz3DNode> nc = new List<ModViz3DNode>();
                //                newclone.getalllevelschildren(nc);
                //                foreach (ModViz3DNode mc in nc)
                //                {
                //                    ts.Add(mc.nodeGUID.ToString(), mc);
                //                }
                //            }
                //        }
                //        ModViz3DNode sb = mycanvas.makestackverticaltowers(ts);
                //        ModViz3DNode bc = sb.clonestack(true);

                //        toUpdate.Add(bc);
                //        List<ModViz3DNode> allc = new List<ModViz3DNode>();
                //        bc.getalllevelschildren(allc);
                //        toUpdate.AddRange(allc);
                //        mycanvas.addstacktostack(bc);
                //        addnodechild(bc);
                //        renderchildren();

                //        //newclone.makestackverticaltower();
                //        //mycanvas.addstacktostack(newclone);

                //        //addnodechild(newclone);




                //        //}

                //    }

                //    getroot().fitroots(mycanvas.stacks);
                //    foreach (ModViz3DNode m in toUpdate)
                //    {
                //        m.update_caption();
                //        m.update_inouts();
                //    }
                //    mycanvas.blockconnupdates = false;
                //    mycanvas.regenerate_connections(false);
                //    mycanvas.removemanipulator();

                //}
                Dictionary<string, ModViz3DNode> la = new Dictionary<string, ModViz3DNode>();
                try
                {


                    mycanvas.readxml(mycanvas.clipboardXMLRepresentation, out la, false, ModViz3DNode.GUIDcount + 1);
                    mycanvas.canvasabouttochange();
                    mycanvas.updatemyPCStatus("Please wait, pasting " + la.Count + " nodes...");

                }
                catch (Exception exy)
                {
                    la = new Dictionary<string, ModViz3DNode>();
                }

                //make sure we can paste
                if (acceptschilds() && la.Values.Count > 0)
                {
                    mycanvas.blockconnupdates = true;
                    mycanvas.blockfitroots = true;
                    //seems like it doesn't work unless in-outs get updated before connections get updated
                    List<ModViz3DNode> toUpdate = new List<ModViz3DNode>();
                    if (parent == null)
                    {
                        foreach (ModViz3DNode m in la.Values)
                        {
                            if (m.parent == null)
                            {

                                m.makestackverticaltower();
                                mycanvas.addstacktostack(m);

                                addnodechild(m);
                                renderchildren();

                                toUpdate.Add(m);
                                List<ModViz3DNode> allc = new List<ModViz3DNode>();
                                m.getalllevelschildren(allc);
                                toUpdate.AddRange(allc);
                            }

                        }
                    }
                    //convert the clipboard to a single tower
                    else
                    {
                        Dictionary<string, ModViz3DNode> ts = new Dictionary<string, ModViz3DNode>();
                        foreach (ModViz3DNode m in la.Values)
                        {
                            if (m.parent == null)
                            {

                                ts.Add(m.nodeGUID.ToString(), m);
                                List<ModViz3DNode> nc = new List<ModViz3DNode>();
                                m.getalllevelschildren(nc);
                                foreach (ModViz3DNode mc in nc)
                                {
                                    ts.Add(mc.nodeGUID.ToString(), mc);
                                }
                            }
                        }
                        ModViz3DNode sb = mycanvas.makestackverticaltowers(ts);


                        toUpdate.Add(sb);
                        List<ModViz3DNode> allc = new List<ModViz3DNode>();
                        sb.getalllevelschildren(allc);
                        toUpdate.AddRange(allc);
                        mycanvas.addstacktostack(sb);
                        addnodechild(sb);
                        renderchildren();

                        //newclone.makestackverticaltower();
                        //mycanvas.addstacktostack(newclone);

                        //addnodechild(newclone);




                        //}

                    }
                    mycanvas.blockfitroots = false;
                    getroot().fitroots(mycanvas.stacks);
                    foreach (ModViz3DNode m in toUpdate)
                    {
                        m.update_caption();
                        m.update_inouts();
                    }
                    mycanvas.blockconnupdates = false;
                    mycanvas.regenerate_connections(false);
                    mycanvas.removemanipulator();

                }
                mycanvas.updatemyPCStatus(myoss);

            }

            //if we paste on top of a node
            internal void moveontopof(List<ModViz3DNode> myNodes)
            {
                if (myNodes.Count == 0) return;

                //make sure we can paste
                if (acceptschilds())
                {
                    string myoss = mycanvas.my_old_pc_status;





                    mycanvas.canvasabouttochange();
                    mycanvas.updatemyPCStatus("Please wait, moving " + myNodes.Count + " nodes...");


                    mycanvas.blockconnupdates = true;
                    mycanvas.blockfitroots = true;
                    //seems like it doesn't work unless in-outs get updated before connections get updated
                    List<ModViz3DNode> toUpdate = new List<ModViz3DNode>();
                    if (parent == null)
                    {
                        foreach (ModViz3DNode m in myNodes)
                        {
                            if (m.parent == null)
                            {

                                m.makestackverticaltower();
                                //   mycanvas.addstacktostack(m);

                                addnodechild(m);
                                renderchildren();

                                toUpdate.Add(m);
                                List<ModViz3DNode> allc = new List<ModViz3DNode>();
                                m.getalllevelschildren(allc);
                                toUpdate.AddRange(allc);
                            }

                        }
                    }
                    //convert the clipboard to a single tower
                    else
                    {
                        Dictionary<string, ModViz3DNode> ts = new Dictionary<string, ModViz3DNode>();
                        foreach (ModViz3DNode m in myNodes)
                        {
                            if (m.parent == null)
                            {

                                ts.Add(m.nodeGUID.ToString(), m);
                                List<ModViz3DNode> nc = new List<ModViz3DNode>();
                                m.getalllevelschildren(nc);
                                foreach (ModViz3DNode mc in nc)
                                {
                                    ts.Add(mc.nodeGUID.ToString(), mc);
                                }
                            }
                        }
                        ModViz3DNode sb = mycanvas.makestackverticaltowers(ts);


                        toUpdate.Add(sb);
                        List<ModViz3DNode> allc = new List<ModViz3DNode>();
                        sb.getalllevelschildren(allc);
                        toUpdate.AddRange(allc);
                        //mycanvas.addstacktostack(sb);
                        addnodechild(sb);
                        renderchildren();


                    }
                    mycanvas.blockfitroots = false;
                    getroot().fitroots(mycanvas.stacks);
                    foreach (ModViz3DNode m in toUpdate)
                    {
                        m.update_caption();
                        m.update_inouts();
                    }
                    mycanvas.blockconnupdates = false;
                    mycanvas.update_all_connectors();
                    mycanvas.removemanipulator();
                    mycanvas.updatemyPCStatus(myoss);
                }


            }


            //displays textual info
            internal string ninfoXML()
            {

                XmlDocument doc = new XmlDocument();
                XmlNode nodeInfoElem;
                //write the canvas
                nodeInfoElem = doc.CreateNode(XmlNodeType.Element, "nodeXMLFullInformation", "");

                /*for (int nc = 0; nc < sv.Count; nc++)
            {

                //ModViz3DNode writenode = stacks.Values.ToArray()[nc];
                ModViz3DNode writenode = sv[nc];
                if (writenode == null) continue;
                //each node
                XmlNode nodeelem = doc.CreateNode(XmlNodeType.Element, "node", "");
                XmlNode guideleme = doc.CreateNode(XmlNodeType.Element, "guid", "");
                guideleme.InnerText = writenode.nodeGUID.ToString();
                nodeelem.AppendChild(guideleme);
                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "displayname", "");
                dispeleme.InnerText = writenode.displayname;
                nodeelem.AppendChild(dispeleme);
                XmlNode hdl = doc.CreateNode(XmlNodeType.Element, "hidden", "");
                hdl.InnerText = writenode.hiddenOnLockedCanvas.ToString();
                nodeelem.AppendChild(hdl);
                */

                XmlNode generalInfoElem = doc.CreateNode(XmlNodeType.Element, "generalInformation", "");
                string ninfom = "[Node ID:]" + nodeGUID.ToString() + "_|_";
                try
                {
                    ninfom = ninfom + "[Hidden on Locked Canvas:]" + hiddenOnLockedCanvas.ToString() + "_|_";
                    ninfom = ninfom + "[Module name:]" + logical_representation.name + "_|_";
                    ninfom = ninfom + "[Module Description:]" + logical_representation.description + "_|_";
                    ninfom = ninfom + "[Processing Issues:]" + logical_representation.anymessage + "_|_";
                    if (logical_representation.doubleClickDescription != "")
                    {
                        ninfom += "[Double Click Action:]" + logical_representation.doubleClickDescription + "_|_";
                    }
                    if (logical_representation.gestureDescription != "")
                    {
                        ninfom += "[Gesture Action:]" + logical_representation.gestureDescription + "_|_";
                    }
                }
                catch
                {

                }
                if (myself != null)
                {
                    try
                    {
                        ninfom += "[Caption:]" + caption.Text + "_|_";
                        ninfom += "[Position:](" + boundingBox.rectcenter().X.ToString() + "," + boundingBox.rectcenter().Y.ToString() + "," + boundingBox.rectcenter().Z.ToString() + ")_|_";
                        ninfom += "[Size:](" + boundingBox.SizeX.ToString() + "," + boundingBox.SizeY.ToString() + "," + boundingBox.SizeZ.ToString() + ")_|_";
                    }
                    catch
                    {

                    }
                }
                generalInfoElem.InnerText = ninfom;
                nodeInfoElem.AppendChild(generalInfoElem);


                string[] inputrdata;
                string[] inputNames;
                ArrayList allinputrows = new ArrayList();
                if (logical_representation.inputs.Count > 0)
                {

                    inputNames = new string[logical_representation.inputs.Count];

                    for (int ii = 0; ii < logical_representation.inputs.Count; ii++)
                    {
                        inputNames[ii] = logical_representation.inputnames[ii];
                    }
                    //row data
                    inputrdata = new string[logical_representation.inputs.Count];
                    if (logical_representation.listprocess == false)
                    {

                        for (int ii = 0; ii < logical_representation.inputs.Count; ii++)
                        {
                            try
                            {
                                //array lists print one under another
                                if (logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex] is IEnumerable && !(logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex] is string))
                                {
                                    //2d array
                                    if (logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex] is Array && (logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex] as Array).Rank == 2)
                                    {
                                        Array barray = logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex] as Array;


                                        string[] hhh = null;
                                        try
                                        {
                                            hhh = barray as string[];
                                        }
                                        catch
                                        {
                                            hhh = null;
                                        }
                                        if (hhh == null)
                                        {

                                            for (int ai = 0; ai < barray.GetLength(0); ai++)
                                            {


                                                string myarraycont = "[";
                                                for (int aaai = 0; aaai < barray.GetLength(1); aaai++)
                                                {
                                                    myarraycont += barray.GetValue(ai, aaai).ToString();
                                                    if (aaai < barray.GetLength(1) - 1)
                                                    {
                                                        myarraycont += ",";
                                                    }
                                                }
                                                myarraycont += "]";
                                                inputrdata[ii] += myarraycont;
                                                if (ai < barray.GetLength(0) - 1)
                                                {
                                                    inputrdata[ii] += ",";
                                                }


                                            }
                                        }
                                        //array of strings
                                        else
                                        {
                                            for (int bi = 0; bi < hhh.GetLength(0); bi++)
                                            {
                                                inputrdata[ii] += hhh[bi].ToString();
                                                if (bi < hhh.GetLength(0) - 1)
                                                {
                                                    inputrdata[ii] += ",";
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        ArrayList aaa = PUPPIModel.PUPPIModule.makeCollOrEnumIntoArrayList(logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex]) as ArrayList;
                                        for (int ai = 0; ai < aaa.Count; ai++)
                                        {
                                            //2d arrays
                                            if (aaa[ai] is IEnumerable && !(aaa[ai] is string))
                                            {
                                                ArrayList baaa = PUPPIModel.PUPPIModule.makeCollOrEnumIntoArrayList(aaa[ai]) as ArrayList;
                                                string myarraycont = "{";
                                                for (int aaai = 0; aaai < baaa.Count; aaai++)
                                                {
                                                    myarraycont += baaa[aaai].ToString();
                                                    if (aaai < baaa.Count - 1)
                                                    {
                                                        myarraycont += ",";
                                                    }
                                                }
                                                myarraycont += "}";
                                                inputrdata[ii] += myarraycont;
                                                if (ai < aaa.Count - 1)
                                                {
                                                    inputrdata[ii] += ",";
                                                }

                                            }
                                            else
                                            {
                                                inputrdata[ii] += aaa[ai].ToString();
                                                if (ai < aaa.Count - 1)
                                                {
                                                    inputrdata[ii] += ",";
                                                }
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    inputrdata[ii] = logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex].ToString();
                                }
                            }
                            catch (Exception exy)
                            {
                                inputrdata[ii] = "error or null: " + exy.ToString().Split(new string[] { " at " }, StringSplitOptions.None)[0];
                            }
                        }

                        allinputrows.Add(inputrdata);
                    }
                    else
                    {
                        //generate data on rows
                        for (int jj = 0; jj < logical_representation.countListMode; jj++)
                        {
                            try
                            {
                                inputrdata = new string[logical_representation.inputs.Count];
                                for (int ii = 0; ii < logical_representation.inputs.Count; ii++)
                                {
                                    try
                                    {
                                        if (!logical_representation.inputs[ii].inputAutomaticListMode)
                                        {
                                            ArrayList mycol = PUPPIModel.PUPPIModule.makeCollOrEnumIntoArrayList(logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex]) as ArrayList;
                                            //2d arrays
                                            if (mycol[jj] is IEnumerable && !(mycol[jj] is string))
                                            {
                                                ArrayList baaa = PUPPIModel.PUPPIModule.makeCollOrEnumIntoArrayList(mycol[jj]) as ArrayList;
                                                string myarraycont = "{";
                                                for (int aaai = 0; aaai < baaa.Count; aaai++)
                                                {
                                                    myarraycont += baaa[aaai].ToString();
                                                    if (aaai < baaa.Count - 1)
                                                    {
                                                        myarraycont += ",";
                                                    }
                                                }
                                                myarraycont += "}";
                                                inputrdata[ii] = myarraycont;

                                            }
                                            else
                                            {
                                                inputrdata[ii] = mycol[jj].ToString();
                                            }
                                        }
                                        else
                                        {
                                            inputrdata[ii] = logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex].ToString();
                                        }
                                    }
                                    catch (Exception exy)
                                    {
                                        inputrdata[ii] = "error or null: " + exy.ToString().Split(new string[] { " at " }, StringSplitOptions.None)[0];
                                    }
                                }
                                allinputrows.Add(inputrdata);
                            }
                            catch
                            {

                            }

                        }
                    }
                    for (int ii = 0; ii < logical_representation.inputs.Count; ii++)
                    {
                        XmlNode iNode = doc.CreateNode(XmlNodeType.Element, "input", "");

                        XmlNode iName = doc.CreateNode(XmlNodeType.Element, "name", "");
                        {
                            iName.InnerText = inputNames[ii];
                        }
                        iNode.AppendChild(iName);
                        string ival = "";
                        for (int jj = 0; jj < allinputrows.Count; jj++)
                        {
                            try
                            {
                                string[] rd = allinputrows[jj] as string[];
                                ival += rd[ii];
                            }
                            catch
                            {
                                ival += "error";
                            }
                            if (jj < allinputrows.Count - 1)
                            {
                                ival += "_|_";
                            }
                        }
                        XmlNode iVal = doc.CreateNode(XmlNodeType.Element, "value", "");
                        {
                            iVal.InnerText = ival;
                        }
                        iName.AppendChild(iVal);
                        iNode.AppendChild(iVal);
                        generalInfoElem.AppendChild(iNode);
                    }
                }
                string[] outputrdata;
                string[] outputNames;
                ArrayList alloutputrows = new ArrayList();


                if (logical_representation.outputs.Count > 0)
                {


                    outputNames = new string[logical_representation.outputs.Count];
                    for (int ii = 0; ii < logical_representation.outputs.Count; ii++)
                    {
                        outputNames[ii] = logical_representation.outputnames[ii];
                    }
                    //row data
                    outputrdata = new string[logical_representation.outputs.Count];
                    if (logical_representation.listprocess == false)
                    {

                        for (int ii = 0; ii < logical_representation.outputs.Count; ii++)
                        {
                            try
                            {
                                if (logical_representation.outputs[ii] is IEnumerable && !(logical_representation.outputs[ii] is string))
                                {

                                    //2d array
                                    if (logical_representation.outputs[ii] is Array && (logical_representation.outputs[ii] as Array).Rank == 2)
                                    {
                                        Array barray = logical_representation.outputs[ii] as Array;
                                        string[] hhh = null;
                                        try
                                        {
                                            hhh = barray as string[];
                                        }
                                        catch
                                        {
                                            hhh = null;
                                        }
                                        if (hhh == null)
                                        {
                                            for (int ai = 0; ai < barray.GetLength(0); ai++)
                                            {


                                                string myarraycont = "[";
                                                for (int aaai = 0; aaai < barray.GetLength(1); aaai++)
                                                {
                                                    myarraycont += barray.GetValue(ai, aaai).ToString();
                                                    if (aaai < barray.GetLength(1) - 1)
                                                    {
                                                        myarraycont += ",";
                                                    }
                                                }
                                                myarraycont += "]";
                                                outputrdata[ii] += myarraycont;
                                                if (ai < barray.GetLength(0) - 1)
                                                {
                                                    outputrdata[ii] += ",";
                                                }




                                            }
                                        }
                                        //array of strings
                                        else
                                        {
                                            for (int bi = 0; bi < hhh.GetLength(0); bi++)
                                            {
                                                outputrdata[ii] += hhh[bi].ToString();
                                                if (bi < hhh.GetLength(0) - 1)
                                                {
                                                    outputrdata[ii] += ",";
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {

                                        ArrayList aaa = PUPPIModel.PUPPIModule.makeCollOrEnumIntoArrayList(logical_representation.outputs[ii]) as ArrayList;
                                        for (int ai = 0; ai < aaa.Count; ai++)
                                        {
                                            //2d arrays
                                            if (aaa[ai] is IEnumerable && !(aaa[ai] is string))
                                            {
                                                ArrayList baaa = PUPPIModel.PUPPIModule.makeCollOrEnumIntoArrayList(aaa[ai]) as ArrayList;
                                                string myarraycont = "{";
                                                for (int aaai = 0; aaai < baaa.Count; aaai++)
                                                {
                                                    myarraycont += baaa[aaai].ToString();
                                                    if (aaai < baaa.Count - 1)
                                                    {
                                                        myarraycont += ",";
                                                    }
                                                }
                                                myarraycont += "}";
                                                outputrdata[ii] += myarraycont;
                                                if (ai < aaa.Count - 1)
                                                {
                                                    outputrdata[ii] += ",";
                                                }
                                            }
                                            else
                                            {
                                                outputrdata[ii] += aaa[ai].ToString();
                                                if (ai < aaa.Count - 1)
                                                {
                                                    outputrdata[ii] += ",";
                                                }
                                            }

                                        }
                                    }
                                }
                                else

                                { outputrdata[ii] = logical_representation.outputs[ii].ToString(); }
                            }
                            catch (Exception exy)
                            {
                                outputrdata[ii] = "error or null: " + exy.ToString().Split(new string[] { " at " }, StringSplitOptions.None)[0];
                            }
                        }
                        alloutputrows.Add(outputrdata);
                    }
                    else
                    {
                        //generate data on rows
                        for (int jj = 0; jj < logical_representation.countListMode; jj++)
                        {
                            try
                            {
                                outputrdata = new string[logical_representation.outputs.Count];
                                for (int ii = 0; ii < logical_representation.outputs.Count; ii++)
                                {
                                    try
                                    {
                                        ArrayList mycol = PUPPIModel.PUPPIModule.makeCollOrEnumIntoArrayList(logical_representation.outputs[ii]) as ArrayList;
                                        //2d arrays
                                        if (mycol[jj] is IEnumerable && !(mycol[jj] is string))
                                        {
                                            ArrayList baaa = PUPPIModel.PUPPIModule.makeCollOrEnumIntoArrayList(mycol[jj]) as ArrayList;
                                            string myarraycont = "{";
                                            for (int aaai = 0; aaai < baaa.Count; aaai++)
                                            {
                                                myarraycont += baaa[aaai].ToString();
                                                if (aaai < baaa.Count - 1)
                                                {
                                                    myarraycont += ",";
                                                }
                                            }
                                            myarraycont += "}";
                                            outputrdata[ii] = myarraycont;

                                        }
                                        else
                                        {
                                            outputrdata[ii] = mycol[jj].ToString();
                                        }
                                    }
                                    catch (Exception exy)
                                    {

                                        outputrdata[ii] = "error or null: " + exy.ToString().Split(new string[] { " at " }, StringSplitOptions.None)[0];
                                    }
                                    //rdata[ii] = mycol[jj].ToString();
                                }
                                alloutputrows.Add(outputrdata);
                            }
                            catch
                            {

                            }

                        }
                    }
                    for (int ii = 0; ii < logical_representation.outputs.Count; ii++)
                    {
                        XmlNode iNode = doc.CreateNode(XmlNodeType.Element, "output", "");

                        XmlNode iName = doc.CreateNode(XmlNodeType.Element, "name", "");
                        {
                            iName.InnerText = outputNames[ii];
                        }
                        iNode.AppendChild(iName);
                        string ival = "";
                        for (int jj = 0; jj < alloutputrows.Count; jj++)
                        {
                            try
                            {
                                string[] rd = alloutputrows[jj] as string[];
                                ival += rd[ii];
                            }
                            catch
                            {
                                ival += "error";
                            }
                            if (jj < alloutputrows.Count - 1)
                            {
                                ival += "_|_";
                            }
                        }
                        XmlNode iVal = doc.CreateNode(XmlNodeType.Element, "value", "");
                        {
                            iVal.InnerText = ival;
                        }
                        iName.AppendChild(iVal);
                        iNode.AppendChild(iVal);
                        generalInfoElem.AppendChild(iNode);
                    }

                }

                //container data 
                if (logical_representation.GetType() == typeof(PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer))
                {
                    XmlNode iCotainer = doc.CreateNode(XmlNodeType.Element, "container", "");

                    PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer pa = logical_representation as PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer;
                    string icon = "";
                    int ic = 0;
                    foreach (PUPPIModule p in pa.PMsubModules)
                    {
                        icon += p.name;
                        if (ic < pa.PMsubModules.Count - 1) icon += "_|_";
                        ic++;
                    }
                    iCotainer.InnerText = icon;
                    generalInfoElem.AppendChild(iCotainer);
                }
                return generalInfoElem.OuterXml;

            }

            //displays textual info
            internal void showinfo()
            {
                //show form with node info for debug
                PUPPInodeinfo pni = new PUPPInodeinfo();

                string ninfom = "Node " + nodeGUID.ToString() + "\n";
                try
                {
                    ninfom = ninfom + "Hidden on Locked Canvas: " + hiddenOnLockedCanvas.ToString() + "\n";
                    ninfom = ninfom + "Module name:" + logical_representation.name + "\n";
                    ninfom = ninfom + "Module Description:" + logical_representation.description + "\n";
                    ninfom = ninfom + "Processing Issues:" + logical_representation.anymessage + "\n";
                    if (logical_representation.doubleClickDescription != "")
                    {
                        ninfom += "Double Click Action: " + logical_representation.doubleClickDescription + "\n";
                    }
                    if (logical_representation.gestureDescription != "")
                    {
                        ninfom += "Gesture Action: " + logical_representation.gestureDescription + "\n";
                    }
                }
                catch
                {

                }
                if (myself != null)
                {
                    try
                    {
                        ninfom += "Caption: " + caption.Text + "\n";
                        ninfom += "Position: (" + boundingBox.rectcenter().X.ToString() + "," + boundingBox.rectcenter().Y.ToString() + "," + boundingBox.rectcenter().Z.ToString() + ")\n";
                        ninfom += "Size: (" + boundingBox.SizeX.ToString() + "," + boundingBox.SizeY.ToString() + "," + boundingBox.SizeZ.ToString() + ")\n";
                    }
                    catch
                    {

                    }
                }

                pni.ninfo.Text = ninfom;
                string[] rdata;
                if (logical_representation.inputs.Count > 0)
                {
                    //input names and values in a table
                    pni.inputvalues.ColumnCount = logical_representation.inputs.Count;
                    for (int ii = 0; ii < logical_representation.inputs.Count; ii++)
                    {
                        pni.inputvalues.Columns[ii].Name = logical_representation.inputnames[ii];
                    }
                    //row data
                    rdata = new string[logical_representation.inputs.Count];
                    if (logical_representation.listprocess == false)
                    {

                        //if (logical_representation.inputs[0].module.outputs[logical_representation.inputs[0].outParIndex] is ArrayList==false  && logical_representation.inputs[0].module.outputs[logical_representation.inputs[0].outParIndex] is List==false  )
                        //{ 
                        for (int ii = 0; ii < logical_representation.inputs.Count; ii++)
                        {
                            try
                            {
                                //array lists print one under another
                                if (logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex] is IEnumerable && !(logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex] is string))
                                {
                                    //2d array
                                    if (logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex] is Array && (logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex] as Array).Rank == 2)
                                    {
                                        Array barray = logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex] as Array;


                                        string[] hhh = null;
                                        try
                                        {
                                            hhh = barray as string[];
                                        }
                                        catch
                                        {
                                            hhh = null;
                                        }
                                        if (hhh == null)
                                        {

                                            for (int ai = 0; ai < barray.GetLength(0); ai++)
                                            {


                                                string myarraycont = "[";
                                                for (int aaai = 0; aaai < barray.GetLength(1); aaai++)
                                                {
                                                    myarraycont += barray.GetValue(ai, aaai).ToString();
                                                    if (aaai < barray.GetLength(1) - 1)
                                                    {
                                                        myarraycont += ",";
                                                    }
                                                }
                                                myarraycont += "]";
                                                rdata[ii] += myarraycont;
                                                if (ai < barray.GetLength(0) - 1)
                                                {
                                                    rdata[ii] += ",";
                                                }


                                            }
                                        }
                                        //array of strings
                                        else
                                        {
                                            for (int bi = 0; bi < hhh.GetLength(0); bi++)
                                            {
                                                rdata[ii] += hhh[bi].ToString();
                                                if (bi < hhh.GetLength(0) - 1)
                                                {
                                                    rdata[ii] += ",";
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        ArrayList aaa = PUPPIModel.PUPPIModule.makeCollOrEnumIntoArrayList(logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex]) as ArrayList;
                                        for (int ai = 0; ai < aaa.Count; ai++)
                                        {
                                            //2d arrays
                                            if (aaa[ai] is IEnumerable && !(aaa[ai] is string))
                                            {
                                                ArrayList baaa = PUPPIModel.PUPPIModule.makeCollOrEnumIntoArrayList(aaa[ai]) as ArrayList;
                                                string myarraycont = "{";
                                                for (int aaai = 0; aaai < baaa.Count; aaai++)
                                                {
                                                    myarraycont += baaa[aaai].ToString();
                                                    if (aaai < baaa.Count - 1)
                                                    {
                                                        myarraycont += ",";
                                                    }
                                                }
                                                myarraycont += "}";
                                                rdata[ii] += myarraycont;
                                                if (ai < aaa.Count - 1)
                                                {
                                                    rdata[ii] += ",";
                                                }

                                            }
                                            else
                                            {
                                                rdata[ii] += aaa[ai].ToString();
                                                if (ai < aaa.Count - 1)
                                                {
                                                    rdata[ii] += ",";
                                                }
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    rdata[ii] = logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex].ToString();
                                }
                            }
                            catch (Exception exy)
                            {
                                rdata[ii] = "error or null: " + exy.ToString().Split(new string[] { " at " }, StringSplitOptions.None)[0];
                            }
                        }
                        pni.inputvalues.Rows.Add(rdata);
                    }
                    else
                    {
                        //generate data on rows
                        for (int jj = 0; jj < logical_representation.countListMode; jj++)
                        {
                            try
                            {
                                rdata = new string[logical_representation.inputs.Count];
                                for (int ii = 0; ii < logical_representation.inputs.Count; ii++)
                                {
                                    try
                                    {
                                        if (!logical_representation.inputs[ii].inputAutomaticListMode)
                                        {
                                            ArrayList mycol = PUPPIModel.PUPPIModule.makeCollOrEnumIntoArrayList(logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex]) as ArrayList;
                                            //2d arrays
                                            if (mycol[jj] is IEnumerable && !(mycol[jj] is string))
                                            {
                                                ArrayList baaa = PUPPIModel.PUPPIModule.makeCollOrEnumIntoArrayList(mycol[jj]) as ArrayList;
                                                string myarraycont = "{";
                                                for (int aaai = 0; aaai < baaa.Count; aaai++)
                                                {
                                                    myarraycont += baaa[aaai].ToString();
                                                    if (aaai < baaa.Count - 1)
                                                    {
                                                        myarraycont += ",";
                                                    }
                                                }
                                                myarraycont += "}";
                                                rdata[ii] = myarraycont;

                                            }
                                            else
                                            {
                                                rdata[ii] = mycol[jj].ToString();
                                            }
                                        }
                                        else
                                        {
                                            rdata[ii] = logical_representation.inputs[ii].module.outputs[logical_representation.inputs[ii].outParIndex].ToString();
                                        }
                                    }
                                    catch (Exception exy)
                                    {
                                        rdata[ii] = "error or null: " + exy.ToString().Split(new string[] { " at " }, StringSplitOptions.None)[0];
                                    }
                                }
                                pni.inputvalues.Rows.Add(rdata);
                            }
                            catch
                            {

                            }

                        }
                    }
                }
                if (logical_representation.outputs.Count > 0)
                {
                    //output data in table
                    pni.outputvalues.ColumnCount = logical_representation.outputs.Count;
                    for (int ii = 0; ii < logical_representation.outputs.Count; ii++)
                    {
                        pni.outputvalues.Columns[ii].Name = logical_representation.outputnames[ii];
                    }
                    //row data
                    rdata = new string[logical_representation.outputs.Count];
                    if (logical_representation.listprocess == false)
                    {

                        for (int ii = 0; ii < logical_representation.outputs.Count; ii++)
                        {
                            try
                            {
                                if (logical_representation.outputs[ii] is IEnumerable && !(logical_representation.outputs[ii] is string))
                                {

                                    //2d array
                                    if (logical_representation.outputs[ii] is Array && (logical_representation.outputs[ii] as Array).Rank == 2)
                                    {
                                        Array barray = logical_representation.outputs[ii] as Array;
                                        string[] hhh = null;
                                        try
                                        {
                                            hhh = barray as string[];
                                        }
                                        catch
                                        {
                                            hhh = null;
                                        }
                                        if (hhh == null)
                                        {
                                            for (int ai = 0; ai < barray.GetLength(0); ai++)
                                            {


                                                string myarraycont = "[";
                                                for (int aaai = 0; aaai < barray.GetLength(1); aaai++)
                                                {
                                                    myarraycont += barray.GetValue(ai, aaai).ToString();
                                                    if (aaai < barray.GetLength(1) - 1)
                                                    {
                                                        myarraycont += ",";
                                                    }
                                                }
                                                myarraycont += "]";
                                                rdata[ii] += myarraycont;
                                                if (ai < barray.GetLength(0) - 1)
                                                {
                                                    rdata[ii] += ",";
                                                }




                                            }
                                        }
                                        //array of strings
                                        else
                                        {
                                            for (int bi = 0; bi < hhh.GetLength(0); bi++)
                                            {
                                                rdata[ii] += hhh[bi].ToString();
                                                if (bi < hhh.GetLength(0) - 1)
                                                {
                                                    rdata[ii] += ",";
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {

                                        ArrayList aaa = PUPPIModel.PUPPIModule.makeCollOrEnumIntoArrayList(logical_representation.outputs[ii]) as ArrayList;
                                        for (int ai = 0; ai < aaa.Count; ai++)
                                        {
                                            //2d arrays
                                            if (aaa[ai] is IEnumerable && !(aaa[ai] is string))
                                            {
                                                ArrayList baaa = PUPPIModel.PUPPIModule.makeCollOrEnumIntoArrayList(aaa[ai]) as ArrayList;
                                                string myarraycont = "{";
                                                for (int aaai = 0; aaai < baaa.Count; aaai++)
                                                {
                                                    myarraycont += baaa[aaai].ToString();
                                                    if (aaai < baaa.Count - 1)
                                                    {
                                                        myarraycont += ",";
                                                    }
                                                }
                                                myarraycont += "}";
                                                rdata[ii] += myarraycont;
                                                if (ai < aaa.Count - 1)
                                                {
                                                    rdata[ii] += ",";
                                                }
                                            }
                                            else
                                            {
                                                rdata[ii] += aaa[ai].ToString();
                                                if (ai < aaa.Count - 1)
                                                {
                                                    rdata[ii] += ",";
                                                }
                                            }

                                        }
                                    }
                                }
                                else

                                { rdata[ii] = logical_representation.outputs[ii].ToString(); }
                            }
                            catch (Exception exy)
                            {
                                rdata[ii] = "error or null: " + exy.ToString().Split(new string[] { " at " }, StringSplitOptions.None)[0];
                            }
                        }
                        pni.outputvalues.Rows.Add(rdata);
                    }
                    else
                    {
                        //generate data on rows
                        for (int jj = 0; jj < logical_representation.countListMode; jj++)
                        {
                            try
                            {
                                rdata = new string[logical_representation.outputs.Count];
                                for (int ii = 0; ii < logical_representation.outputs.Count; ii++)
                                {
                                    try
                                    {
                                        ArrayList mycol = PUPPIModel.PUPPIModule.makeCollOrEnumIntoArrayList(logical_representation.outputs[ii]) as ArrayList;
                                        //2d arrays
                                        if (mycol[jj] is IEnumerable && !(mycol[jj] is string))
                                        {
                                            ArrayList baaa = PUPPIModel.PUPPIModule.makeCollOrEnumIntoArrayList(mycol[jj]) as ArrayList;
                                            string myarraycont = "{";
                                            for (int aaai = 0; aaai < baaa.Count; aaai++)
                                            {
                                                myarraycont += baaa[aaai].ToString();
                                                if (aaai < baaa.Count - 1)
                                                {
                                                    myarraycont += ",";
                                                }
                                            }
                                            myarraycont += "}";
                                            rdata[ii] = myarraycont;

                                        }
                                        else
                                        {
                                            rdata[ii] = mycol[jj].ToString();
                                        }
                                    }
                                    catch (Exception exy)
                                    {

                                        rdata[ii] = "error or null: " + exy.ToString().Split(new string[] { " at " }, StringSplitOptions.None)[0];
                                    }
                                    //rdata[ii] = mycol[jj].ToString();
                                }
                                pni.outputvalues.Rows.Add(rdata);
                            }
                            catch
                            {

                            }

                        }
                    }
                }
                //container data button
                if (logical_representation.GetType() == typeof(PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer))
                {
                    PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer pa = logical_representation as PUPPIModel.PUPPIPremadeModules.PUPPINodeContainer;
                    pni.showContainer.Visible = true;
                    pni.showContainer.Enabled = true;
                    pni.lf = new ListForm();
                    //show submodules

                    pni.lf.setTitle("Modules in Container");

                    foreach (PUPPIModule p in pa.PMsubModules)
                    {
                        pni.lf.addListItem(p.ToString());
                    }
                }
                else
                {
                    pni.showContainer.Visible = false;
                    pni.showContainer.Enabled = false;
                }

                pni.ShowDialog();
            }
            internal int myNodeMaximumChildren = -1;

            //gets maximum number of children allowed
            internal int maxchilds()
            {
                if (myNodeMaximumChildren < 0)
                {
                    if (this.parent == null)
                    {
                        return PUPPIGUISettings.maxBaseChilds;
                    }
                    else
                    {
                        return PUPPIGUISettings.maxFloorChilds;
                    }
                }
                else
                {
                    if (this.parent == null)
                    {
                        return Math.Min(PUPPIGUISettings.maxBaseChilds, myNodeMaximumChildren);
                    }
                    else
                    {
                        return Math.Min(PUPPIGUISettings.maxFloorChilds, myNodeMaximumChildren);
                    }
                }
            }
            //checks if it can accept children
            internal bool acceptschilds()
            {
                if (nodeCustomRenderer != null)
                {
                    if (nodeCustomRenderer.acceptsNodesAbove == false) return false;
                }
                int mc = maxchilds();
                if (mc > childs.Count)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }

            //rendering (so logic, etc already set up). but it only renders the node , does not update ins and outs
            //assumes it has a canvas and view already
            internal void renderme()
            {
                if (mycanvas == null) return;
                if (myself != null)
                {
                    //make sure it's not already rendered
                    if (mycanvas.hv.Children.Contains(myself)) return;

                }
                if (logical_representation == null)
                {
                    return;
                }
                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log("started rendering noode " + nodeGUID.ToString());
                }
                if (parent == null)
                {

                    Rect3D defaultbox = myposition.makedefaultbox();
                    ModelVisual3D newb = addbox(defaultbox, mycanvas.node_default_mat);
                    myself = newb;
                    boundingBox = defaultbox;
                    myposition = boundingBox.rectcenter();

                }
                else
                {

                    ModViz3DNode nn = addontopof(this.parent, this);


                }
                //try
                //{
                myself.SetName(nodeGUID.ToString());
                setlogic(logical_representation);
                useRenderer();
                //}
                //catch
                //{
                //    throw new Exception("failed to set logic on rendering node");
                //}
                //try
                //{
                //    update_caption();
                //}
                //catch
                //{
                //    throw new Exception("failed to update caption on render"); 
                //}
                //testiter++;
                //if (testiter > 1000)
                //{
                //  throw new Exception("stuck in render recursive");
                // testiter = 0;

                //}
                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log("finished rendering noode " + nodeGUID.ToString());
                }
            }
            //we know the bounding box
            internal void rendermebox()
            {
                if (mycanvas == null) return;
                if (myself != null)
                {
                    //make sure it's not already rendered
                    if (mycanvas.hv.Children.Contains(myself)) return;

                }
                if (logical_representation == null)
                {
                    return;
                }
                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log("started rendering noode " + nodeGUID.ToString());
                }



                ModelVisual3D newb = addbox(boundingBox, mycanvas.node_default_mat);
                myself = newb;

                myposition = boundingBox.rectcenter();


                myself.SetName(nodeGUID.ToString());
                setlogic(logical_representation, true);
                useRenderer();

                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log("finished rendering noode " + nodeGUID.ToString());
                }
            }

            //render all child nodes recursively
            internal void renderchildren()
            {
                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log("started rendering children for node " + nodeGUID.ToString());
                }


                foreach (ModViz3DNode cula in getallnodesnextlevel())
                {
                    cula.renderme();
                    cula.renderchildren();

                }
                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log("finished rendering children for node " + nodeGUID.ToString());
                }

            }
            //deletes node. all the children and their children move down and their parents become the node's parent
            internal void delete(bool fullupdate)
            {
                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log(utils.StringConstants.startedtodeletenode + nodeGUID.ToString());
                }
                //clears selection
                if (mycanvas.selstacks.Contains(nodeGUID.ToString())) mycanvas.selstacks.Remove(nodeGUID.ToString());
                //first disconnects all inputs
                for (int icount = 0; icount < vizinputs.Count; icount++)
                {
                    disconnectinput(icount);
                }
                //disconnect outputs
                for (int ocount = 0; ocount < logical_representation.outputs.Count; ocount++)
                {
                    //go through all the modules in canvas and disconenct inputs

                    foreach (ModViz3DNode testdisco in mycanvas.stacks.Values)
                    {
                        for (int tdi = 0; tdi < testdisco.vizinputs.Count; tdi++)
                        {
                            ModViz3DInput testimp = testdisco.vizinputs[tdi];
                            if (testimp != null && testimp.myinput != null)
                            {
                                if (testimp.myinput.module == logical_representation)
                                {
                                    testdisco.disconnectinput(testdisco.vizinputs.IndexOf(testimp));
                                }
                            }
                        }
                    }
                }

                //disconnect all the children and connect them to the parent
                List<ModViz3DNode> toupdatepyr = new List<ModViz3DNode>();

                for (int scc = 0; scc < childs.Count; scc++)
                {
                    //ModViz3DNode stepchild=childs[scc];
                    //maybe faster without boxing
                    childs[scc].parent = parent;

                    toupdatepyr.Add(childs[scc]);
                    if (parent != null)
                    {
                        parent.childs.Add(childs[scc]);

                    }
                    //preserve base index for whenw e draw connections
                    if (baseindex != 0) childs[scc].baseindex = baseindex;


                }

                if (parent != null)
                {
                    parent.childs.Remove(this);
                }
                mycanvas.stacks.Remove(this.nodeGUID.ToString());

                deletevisuals();

                for (int scu = 0; scu < toupdatepyr.Count; scu++)
                {
                    // ModViz3DNode sc = toupdatepyr[scu]; 
                    toupdatepyr[scu].descend_stack(1);
                    //get the very top of the stack
                    ModViz3DNode stop = toupdatepyr[scu].getrectopchild();
                    //use default size to resize smaller if needed box
                    // stop.replacebox(new Rect3D(stop.myself.Content.Bounds.Location.X ,stop.myself.Content.Bounds.Location.Y,stop.myself.Content.Bounds.Location.Z, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeHeight)); 
                    if (fullupdate == true)
                        stop.bottompyramid(stop);
                }

                //need to bottom pyramid also if we deleted one above base with no children
                if (this.parent != null)
                {
                    //reset parent size to regular box


                    // this.parent.replacebox(new Rect3D(this.parent.myself.Content.Bounds.Location.X, this.parent.myself.Content.Bounds.Location.Y, this.parent.myself.Content.Bounds.Location.Z, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeHeight));


                    if (this.parent.parent == null && toupdatepyr.Count == 0)
                    {
                        if (this.parent.childs.Count > 0)
                        {
                            //try
                            //{
                            if (fullupdate == true)
                            {
                                this.parent.bottompyramid(this.parent.childs[0]);
                            }
                            //}
                            //catch
                            //{

                            //}
                        }
                        //in this case we need to make this default size
                        else
                        {

                            this.parent.replacebox(new Rect3D(this.parent.boundingBox.Location, new Size3D(PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeHeight)));
                            this.parent.update_inouts();
                        }


                        this.parent.fitroots(this.parent.mycanvas.stacks);
                    }
                }

                //refit roots if the parent is null
                if (this.parent == null)
                    for (int uu = 0; uu < toupdatepyr.Count; uu++)
                    {
                        toupdatepyr[uu].fitroots(toupdatepyr[uu].mycanvas.stacks);
                    }

                //tries to delete the manipulator
                mycanvas.removemanipulator();
                //removes the unique node
                if (logical_representation.unique) mycanvas.remove_unique_node(logical_representation);
                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log(utils.StringConstants.finisheddeletingnode + nodeGUID.ToString());
                }
                if (mycanvas != null)
                {
                    mycanvas.lastChanged = DateTime.Now;

                    if ((PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning || PUPPIruntimesettings.PUPPICanvasHTTPServerIsRunning) && PUPPIruntimesettings.PUPPICanvasServerUpdatingFully)
                    {
                        PUPPICanvas.currentCanvasStatusServer = mycanvas.readMyCanvasStatus();
                        mycanvas.saveReponThread();
                        mycanvas.updateNodeInfoServer(this.nodeGUID.ToString());
                    }
                }

            }
            //deletes node and all children
            internal void deletestack()
            {
                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log(utils.StringConstants.starteddeletingnodestack + nodeGUID.ToString());
                }
                ModViz3DNode[] ncarray = new ModViz3DNode[childs.Count];
                for (int i = 0; i < childs.Count; i++)
                {
                    ncarray[i] = childs[i];

                }
                int lc = childs.Count - 1;

                for (int di = 0; di <= lc; di++)
                {
                    ncarray[di].deletestack();
                    //only do bottom pyramid on some
                    if (di == lc)
                    {

                        ncarray[di].delete(true);
                    }
                    else
                    {
                        ncarray[di].delete(false);
                    }

                }
                delete(true);
                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log(utils.StringConstants.finisheddeletingnodestack + nodeGUID.ToString());
                }
            }
            //   deletes the node box, input and output boxes text etc
            //called by delete method above
            internal void deletevisuals()
            {
                //delete inputs and outputs
                foreach (ModViz3DInput vinput in vizinputs)
                {
                    try
                    {
                        mycanvas.hv.Children.Remove(vinput.myself);
                        vinput.myself = null;
                    }
                    catch
                    {
                    }
                }
                foreach (ModViz3DOutput voutput in vizoutputs)
                {
                    try
                    {
                        mycanvas.hv.Children.Remove(voutput.myself);
                        voutput.myself = null;
                    }
                    catch
                    {

                    }

                }
                //now set them to null
                for (int oc = 0; oc < vizoutputs.Count; oc++)
                {
                    try
                    {
                        vizoutputs[oc] = null;
                    }
                    catch
                    {

                    }
                }

                try
                {
                    mycanvas.hv.Children.Remove(myself);
                    mycanvas.hv.Children.Remove(caption);
                    myself = null;
                    caption = null;
                }
                catch
                {

                }

            }
            //gets the top child or children in case of a base
            internal List<ModViz3DNode> gettopchildren()
            {
                List<ModViz3DNode> tc = new List<ModViz3DNode>();
                //base
                if (parent == null)
                {

                    tc.AddRange(childs.ToList());
                    //foreach (ModViz3DNode mvc in childs)
                    //{
                    //    tc.Add(mvc.getrectopchild());
                    //}
                }
                //above base
                else
                {
                    tc.Add(getrectopchild());
                }
                return tc;

            }
            //recursively gets the top child (assumes each has only one)
            internal ModViz3DNode getrectopchild()
            {
                if (childs.Count == 0)
                {
                    return this;
                }
                else
                {
                    return (childs[0]).getrectopchild();
                }
            }


            //sets the PUPPI module
            //this is to set logic responding to GUI events, not directly

            internal void setlogic(PUPPIModule logic, bool fixedbox = false)
            {
                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log("started setting logic for node " + nodeGUID.ToString() + " to " + logic.name);
                }
                logical_representation = logic;
                if (logical_representation.moduleNodeColorOverride == true)
                {
                    setMyPUPPINodeUpdatedMaterialColor(logical_representation.moduleNodeColorRed, logical_representation.moduleNodeColorGreen, logical_representation.moduleNodeColorBlue, 1);
                }

                if (nodeCustomRenderer == null)
                    setRenderer();
                logical_representation.GUID = nodeGUID;
                myview = mycanvas.hv;
                // System.Threading.ThreadPool.QueueUserWorkItem(new System.Threading.WaitCallback(threadcapupdate));
                // System.Threading.ThreadPool.QueueUserWorkItem(new System.Threading.WaitCallback(threadioupdate));
                myNodeMaximumChildren = logical_representation.maxChildren;
                update_caption();
                update_inouts(fixedbox);
                //update visuals in another thread
                //Thread capThread = new Thread(threadcapupdate   );
                //capThread.SetApartmentState(ApartmentState.STA);
                //capThread.Start();
                //Thread ioThread = new Thread(threadioupdate);
                //ioThread.SetApartmentState(ApartmentState.STA);
                //ioThread.Start();
                //event when module changed
                logic.prochan += new PUPPIModule.processhandler(logicchanged);

                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log("finished setting logic for node " + nodeGUID.ToString() + " to " + logic.name);
                }

            }
            //we call this from a new thread to do the UI update in the background while we continue to process
            private void threadioupdate(Object stateInfo)
            {
                //System.Threading.ThreadPool.QueueUserWorkItem(
                //new System.Threading.WaitCallback(threadioupdate));
                mycanvas.Dispatcher.Invoke(DispatcherPriority.Send,
                                         (ThreadStart)delegate () { update_inouts(); });
            }

            private void threadioupdatev(Object stateInfo)
            {
                //System.Threading.ThreadPool.QueueUserWorkItem(
                //new System.Threading.WaitCallback(threadioupdate));
                mycanvas.Dispatcher.Invoke(DispatcherPriority.Send,
                                         (ThreadStart)delegate () { update_inouts_v(); });
            }

            //we call this from a new thread to do the UI update in the background while we continue to process
            private void threadcapupdate(Object stateInfo)
            {

                mycanvas.Dispatcher.Invoke(DispatcherPriority.Send,
                                         (ThreadStart)delegate () { update_caption(); });
            }
            //called wshen module changed
            internal void logicchanged()
            {
                //if (mycanvas!=null )
                //{
                //    mycanvas.runStringCanvasCommands();  
                //}
                if (myview != null)
                {

                    //Thread ioThread = new Thread(threadioupdate);
                    //ioThread.SetApartmentState(ApartmentState.STA);
                    //ioThread.Start();
                    System.Threading.ThreadPool.QueueUserWorkItem(
        new System.Threading.WaitCallback(threadioupdatev));
                    // update_inouts(); 
                }

            }
            //updates the caption (name of the PUPPI module)

            internal void reset_my_node_caption()
            {
                try
                {

                    string[] stringSeparators = new string[] { "__" };
                    string[] typeSeparators = new string[] { "." };
                    string[] result = logical_representation.name.Split(stringSeparators, StringSplitOptions.None);
                    if (result[0] != null && result[0] != "")
                    {
                        string[] tS = result[0].Split(typeSeparators, StringSplitOptions.None);
                        string ltS = tS[tS.GetLength(0) - 1];

                        logical_representation.cleancap = ltS;
                        displayname = logical_representation.cleancap;
                    }
                    else
                    {
                        logical_representation.cleancap = "";
                        displayname = "";
                    }
                }
                catch
                {

                    logical_representation.cleancap = "";
                    displayname = "";
                }

                update_caption();
            }


            internal void update_caption(int capIndex = 0)
            {
                if (mycanvas.thiscanvasdefinitelylocked && hiddenOnLockedCanvas) return;
                //try
                //{
                if (myself != null)
                {
                    myview = mycanvas.hv;
                    if (logical_representation != null)
                    {
                        if (PUPPIDebugger.debugenabled && caption != null)
                        {
                            PUPPIDebugger.log(utils.StringConstants.startedupdatingcaption + caption.Text + ".Node GUID " + this.nodeGUID.ToString());
                        }
                        //if we don't want to show the caption cause we defined our own
                        if (nodeCustomRenderer != null && nodeCustomRenderer.useDefaultCaption == false)
                        {



                        }

                        else
                        {

                            int cindex = -1;
                            if (caption != null)
                            {

                                cindex = myself.Children.IndexOf(caption);
                                //  myself.Children.Remove(caption);  

                            }


                            caption = new TextVisual3D();
                            caption.FontFamily = PUPPIGUISettings.cacaFoFa;


                            if (displayname == "")
                            {
                                if (logical_representation.cleancap != "")
                                {
                                    caption.Text = logical_representation.cleancap;

                                }
                                else
                                {
                                    caption.Text = logical_representation.name;
                                }
                            }
                            else
                            {
                                caption.Text = displayname;
                            }
                            displayname = caption.Text;


                            //for base, draw looking up
                            if (parent == null)
                            {
                                caption.UpDirection = new Vector3D(0, 1, 0);
                                //if (logical_representation.name != "")
                                //{

                                //so it fits
                                caption.Height = PUPPIGUISettings.nodeSpacing;// (myself.Content.Bounds.SizeY / (double)logical_representation.name.Length);

                                if (caption.Content.Bounds.SizeX > boundingBox.SizeX - PUPPIGUISettings.ioWidth && boundingBox.SizeX - PUPPIGUISettings.ioWidth > 0)
                                {
                                    caption.Height /= caption.Content.Bounds.SizeX / (boundingBox.SizeX - PUPPIGUISettings.ioWidth);
                                }
                                //}
                                if (caption.Height > PUPPIGUISettings.nodeSpacing)
                                {
                                    caption.Height = PUPPIGUISettings.nodeSpacing;
                                }
                                caption.Position = new Point3D(boundingBox.Location.X + boundingBox.SizeX * 0.5, boundingBox.Location.Y + caption.Height * 0.5, boundingBox.Location.Z + boundingBox.SizeZ + PUPPIGUISettings.textRaise);
                            }
                            else
                            {
                                caption.UpDirection = new Vector3D(0, 0, 1);
                                //if (logical_representation.name != "")
                                //{
                                //caption.Text = logical_representation.name;
                                caption.Height = PUPPIGUISettings.nodeHeight;
                                if (caption.Content.Bounds.SizeX > boundingBox.SizeX - PUPPIGUISettings.ioWidth && boundingBox.SizeX - PUPPIGUISettings.ioWidth > 0)
                                {
                                    caption.Height /= caption.Content.Bounds.SizeX / (boundingBox.SizeX - PUPPIGUISettings.ioWidth);
                                }

                                //}

                                if (caption.Height > PUPPIGUISettings.nodeHeight)
                                {
                                    caption.Height = PUPPIGUISettings.nodeHeight;
                                }
                                caption.Position = new Point3D(boundingBox.Location.X + boundingBox.SizeX * 0.5, boundingBox.Location.Y - PUPPIGUISettings.textRaise, boundingBox.Location.Z + boundingBox.SizeZ - caption.Height / 2 - PUPPIGUISettings.textRaise);
                            }
                            caption.SetName(nodeGUID.ToString() + "_Caption");



                            if (cindex != -1)
                            {
                                myself.Children[cindex] = caption;
                            }
                            else
                            {
                                myself.Children.Add(caption);
                            }
                        }

                        if (mycanvas != null)
                        {
                            mycanvas.lastChanged = DateTime.Now;

                            if ((PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning || PUPPIruntimesettings.PUPPICanvasHTTPServerIsRunning) && PUPPIruntimesettings.PUPPICanvasServerUpdatingFully)
                            {
                                PUPPICanvas.currentCanvasStatusServer = mycanvas.readMyCanvasStatus();
                                mycanvas.saveReponThread();
                                mycanvas.updateNodeInfoServer(this.nodeGUID.ToString());
                            }
                        }
                        if (PUPPIDebugger.debugenabled && caption != null)
                        {

                            PUPPIDebugger.log(utils.StringConstants.finishedupdatingcaption + caption.Text + ".Node GUID " + this.nodeGUID.ToString());
                        }
                    }
                }
                //}
                //catch
                //{
                //    throw new Exception("Failed to update node caption");
                //}
            }
            //descends a stack by one- for when stuff gets deleted or split base
            internal void descend_stack(int floors)
            {
                myview = mycanvas.hv;
                Rect3D thisbox = boundingBox;
                Rect3D newbox = new Rect3D(thisbox.Location.X, thisbox.Location.Y, thisbox.Location.Z - PUPPIGUISettings.nodeHeight * floors, thisbox.SizeX, thisbox.SizeY, thisbox.SizeZ);
                ModelVisual3D newme = replacebox(newbox);

                for (int i = 0; i < childs.Count; i++)
                {
                    childs[i].descend_stack(floors);
                }
            }

            internal void deleteall_inouts()
            {
                if (vizinputs != null)
                {
                    if (vizinputs.Count > 0)
                    {
                        for (int ieie = 0; ieie < vizinputs.Count; ieie++)
                        {
                            if (vizinputs[ieie] != null && vizinputs[ieie].myself != null)
                            {
                                //  if (!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas)
                                if (!mycanvas.thiscanvasdefinitelylocked)
                                    myview.Children.Remove(vizinputs[ieie].myself);
                                vizinputs[ieie] = null;
                            }
                        }
                    }
                }


                if (vizoutputs != null)
                {
                    if (vizoutputs.Count > 0)
                    {
                        for (int ieie = 0; ieie < vizoutputs.Count; ieie++)
                        {
                            if (vizoutputs[ieie] != null && vizoutputs[ieie].myself != null)
                            {
                                //if (!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas)
                                if (!mycanvas.thiscanvasdefinitelylocked)
                                    myview.Children.Remove(vizoutputs[ieie].myself);
                                vizoutputs[ieie] = null;
                            }
                        }
                    }
                }

            }

            //generates or updates the visual representation of the inputs and outputs of the PUPPI module contained

            internal void update_inouts(bool fixedbox = false)
            {

                //try
                //{
                myview = mycanvas.hv;
                //first the inputs, on the xminside
                double iheight = 0;
                double ispacing = 0;
                double ipos = 0;
                double hpos = 0;
                double jpos = 0;
                double smallBoxSize = Math.Min(PUPPIGUISettings.ioHeight, PUPPIGUISettings.ioWidth) * 0.01;
                string sIOn = "";
                string sIOv = "";
                //need to force more updates if number of inputs or outputs changed
                bool iochanged = false;
                if (logical_representation != null && myself != null)
                {
                    if (PUPPIDebugger.debugenabled)
                    {
                        PUPPIDebugger.log(utils.StringConstants.startedupdatinginouts + this.nodeGUID.ToString());
                    }
                    //if (nodeCustomRenderer!=null )
                    //{
                    //    if (nodeCustomRenderer.numberInputPositions!=logical_representation.inputs.Count    )
                    //    {
                    //        throw new Exception("Custom Node renderer input number does not match PUPPI module input number");
                    //    }
                    //    if (PUPPIGUISettings.canvasMode==PUPPIGUISettings.CanvasModeEnum.TwoDimensional && nodeCustomRenderer.use2D)
                    //    {
                    //        for (int i = 0; i < nodeCustomRenderer.numberInputPositions; i++)
                    //        {
                    //            PUPPICustomRenderer pcr = nodeCustomRenderer.inputPositions[i];

                    //            if (pcr.needsRender) pcr.renderCustom();
                    //            ModelVisual3D replacer = new ModelVisual3D();
                    //            pcr.model2D.SetName("I_" + i.ToString() + "_" + nodeGUID.ToString());
                    //            Vector3D tranv = Point3D.Subtract(myposition, Point3D.Subtract (pcr.bbox.rectcenter() , nodeCustomRenderer.bbox.rectcenter()).ToPoint3D());
                    //            replacer = nodeCustomRenderer.model2D.moveVisualChildren(tranv, Point3D.Add(pcr.bbox.rectcenter(),tranv).makeSizeBox(smallBoxSize, smallBoxSize, smallBoxSize), mycanvas.customRenderBox_default_mat);


                    //            myview.Children[myview.Children.IndexOf(myself)] = replacer;
                    //            myself = replacer;
                    //        }
                    //    }

                    //}
                    //else
                    bool needToRegenConn = false;
                    #region updatingInputs
                    if (vizinputs != null)
                    {
                        if (vizinputs.Count > 0 && vizinputs.Count == logical_representation.inputs.Count)
                        {
                            for (int ieie = 0; ieie < vizinputs.Count; ieie++)
                            {
                                if (vizinputs[ieie] != null && vizinputs[ieie].myself != null)
                                {
                                    //if (!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas)
                                    if (!mycanvas.thiscanvasdefinitelylocked)
                                        myview.Children.Remove(vizinputs[ieie].myself);
                                }
                            }

                        }
                        //in case module changed
                        else if ((vizinputs.Count > 0 || logical_representation.inputs.Count > 0) && vizinputs.Count != logical_representation.inputs.Count)
                        {

                            iochanged = true;
                            for (int ieie = 0; ieie < vizinputs.Count; ieie++)
                            {
                                if (vizinputs[ieie] != null && vizinputs[ieie].myself != null)
                                {
                                    // if (!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas)
                                    if (!mycanvas.thiscanvasdefinitelylocked)
                                        myview.Children.Remove(vizinputs[ieie].myself);
                                    //to force redraw connection
                                    //if (vizinputs[ieie].myconnector!=null)
                                    //vizinputs[ieie].myconnector.forceConnRedraw = true;   

                                }
                            }

                            //add or remove of inputs gets done at the end and assuming they are not connected
                            if (vizinputs.Count > logical_representation.inputs.Count)
                            {
                                while (vizinputs.Count > logical_representation.inputs.Count)
                                {
                                    vizinputs.RemoveAt(vizinputs.Count - 1);
                                }
                            }
                            else
                            {
                                while (vizinputs.Count < logical_representation.inputs.Count)
                                {
                                    vizinputs.Add(null);
                                }
                            }
                        }
                        else
                        //first time
                        {
                            for (int nic = 0; nic < logical_representation.inputs.Count; nic++)
                            {
                                vizinputs.Add(null);
                            }
                        }
                        //vizinputs.Clear();  
                        if (logical_representation.inputs.Count > 0)
                        {
                            hpos = boundingBox.Location.Z + PUPPIGUISettings.nodeHeight - PUPPIGUISettings.ioHeight;
                            jpos = boundingBox.Location.X - PUPPIGUISettings.ioWidth / 2;
                            //calculate spacing for inputs
                            ispacing = (boundingBox.SizeY - logical_representation.inputs.Count * PUPPIGUISettings.ioLength) / (logical_representation.inputs.Count + 1);

                            //iheight = boundingBox.SizeY / (logical_representation.inputs.Count + 0.5 * (logical_representation.inputs.Count + 1));
                            if (ispacing < PUPPIGUISettings.ioMinSpacing - PUPPIGUISettings.errF)
                            {
                                //throw new Exception("Node too small for number of inputs");
                                //resize box in y direction
                                double newy = logical_representation.inputs.Count * (PUPPIGUISettings.ioLength + PUPPIGUISettings.ioMinSpacing) + PUPPIGUISettings.ioMinSpacing + PUPPIGUISettings.errF;
                                double divvy = newy.nodespaceconvert();
                                if (divvy < newy) newy = divvy + PUPPIGUISettings.nodeSpacing;
                                //newy = divvy;
                                //make even numbered for nicer symmetry
                                if (Convert.ToInt16(newy / PUPPIGUISettings.nodeSpacing) % 2 != 0)
                                {
                                    newy += PUPPIGUISettings.nodeSpacing;
                                }
                                Rect3D newbsize;
                                newbsize = new Rect3D(boundingBox.X, boundingBox.Y + boundingBox.SizeY / 2 - newy / 2, boundingBox.Location.Z, boundingBox.SizeX, newy, boundingBox.SizeZ).locationnodeSpacing();

                                if (fixedbox == false)
                                {
                                    ModelVisual3D newme = replacebox(newbsize, 1);
                                    bottompyramid(this);
                                }
                            }

                            else
                            {

                                ipos = boundingBox.Location.Y + ispacing;
                                for (int icnt = 0; icnt < logical_representation.inputs.Count; icnt++)
                                {
                                    bool isCustom = false;
                                    Rect3D mB = new Rect3D();

                                    ModelVisual3D ic = null;

                                    if (nodeCustomRenderer == null || nodeCustomRenderer.numberInputPositions != logical_representation.inputs.Count || (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional && nodeCustomRenderer.use2D == false) || (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional && nodeCustomRenderer.use3D == false))
                                    {


                                        //no input material if no input
                                        if (logical_representation.inputs[icnt].module == null)
                                        {
                                            if (logical_representation.inputs[icnt].isoptional == true)
                                            {
                                                ic = addbox(new Rect3D(jpos, ipos, hpos, PUPPIGUISettings.ioWidth, PUPPIGUISettings.ioLength, PUPPIGUISettings.ioHeight + PUPPIGUISettings.textRaise), mycanvas.emptyoptionalinput_default_mat, !mycanvas.thiscanvasdefinitelylocked);
                                            }
                                            else
                                            {
                                                ic = addbox(new Rect3D(jpos, ipos, hpos, PUPPIGUISettings.ioWidth, PUPPIGUISettings.ioLength, PUPPIGUISettings.ioHeight + PUPPIGUISettings.textRaise), mycanvas.emptyInput_default_mat, !mycanvas.thiscanvasdefinitelylocked);
                                            }
                                        }
                                        else
                                        {
                                            ic = addbox(new Rect3D(jpos, ipos, hpos, PUPPIGUISettings.ioWidth, PUPPIGUISettings.ioLength, PUPPIGUISettings.ioHeight + PUPPIGUISettings.textRaise), mycanvas.input_default_mat, !mycanvas.thiscanvasdefinitelylocked);
                                        }
                                        mB = new Rect3D(jpos, ipos, hpos, PUPPIGUISettings.ioWidth, PUPPIGUISettings.ioLength, PUPPIGUISettings.ioHeight + PUPPIGUISettings.textRaise);

                                    }
                                    else
                                    {
                                        PUPPICustomRenderer pcr = nodeCustomRenderer.inputPositions[icnt];
                                        Vector3D tranv = new Vector3D();
                                        if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional && nodeCustomRenderer.use2D)
                                        {



                                            if (pcr.needsRender) pcr.renderCustom();

                                            isCustom = true;
                                            //Vector3D tranv = Point3D.Subtract(myposition, Point3D.Subtract(pcr.bbox.rectcenter(), nodeCustomRenderer.bbox.rectcenter()).ToPoint3D());
                                            tranv = Point3D.Subtract(myposition, new Point3D(0, 0, 0));// nodeCustomRenderer.bbox.rectcenter());    
                                            ic = pcr.model2D.moveVisualChildren(tranv, Point3D.Add(pcr.bbox.rectcenter(), tranv).makeSizeBox(smallBoxSize, smallBoxSize, smallBoxSize), mycanvas.customRenderBox_default_mat);
                                        }

                                        if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional && nodeCustomRenderer.use3D)
                                        {


                                            isCustom = true;
                                            if (pcr.needsRender) pcr.renderCustom();


                                            //Vector3D tranv = Point3D.Subtract(myposition, Point3D.Subtract(pcr.bbox.rectcenter(), nodeCustomRenderer.bbox.rectcenter()).ToPoint3D());
                                            tranv = Point3D.Subtract(myposition, new Point3D(0, 0, 0));//nodeCustomRenderer.bbox.rectcenter());
                                            ic = pcr.model3D.moveVisualChildren(tranv, Point3D.Add(pcr.bbox.rectcenter(), tranv).makeSizeBox(smallBoxSize, smallBoxSize, smallBoxSize), mycanvas.customRenderBox_default_mat);
                                        }
                                        //need toa dd it to view separately
                                        // if (!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas)
                                        if (!mycanvas.thiscanvasdefinitelylocked)
                                            myview.Children.Add(ic);

                                        //need to name children accordingly
                                        for (int icc = 0; icc < ic.Children.Count; icc++)
                                        {
                                            (ic.Children[icc] as ModelVisual3D).SetName("I_" + icnt.ToString() + "_" + nodeGUID.ToString() + "_" + icc.ToString());
                                        }

                                        mB = pcr.bbox;
                                        mB.Offset(tranv);
                                    }
                                    //store a consistent starting and ending point for the node to ensure the connection gets created
                                    Point3D iP = new Rect3D(jpos, ipos, hpos, PUPPIGUISettings.ioWidth, PUPPIGUISettings.ioLength, PUPPIGUISettings.ioHeight + PUPPIGUISettings.textRaise).rectcenter();



                                    ic.SetName("I_" + icnt.ToString() + "_" + nodeGUID.ToString());

                                    if (nodeCustomRenderer == null || nodeCustomRenderer.numberInputPositions != logical_representation.inputs.Count || (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional && nodeCustomRenderer.use2D == false) || (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional && nodeCustomRenderer.use3D == false) || nodeCustomRenderer.inputPositions[icnt].useDefaultCaption)
                                    {
                                        //update text on the parameter
                                        TextVisual3D iname = new TextVisual3D();
                                        if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                                        {
                                            iname.UpDirection = new Vector3D(1, 0, 0);
                                            iname.TextDirection = new Vector3D(0, -1, 0);
                                            iname.Height = PUPPIGUISettings.ioTextHeight;
                                            iname.FontFamily = PUPPIGUISettings.cacaFoFa;
                                            iname.Text = logical_representation.inputnames[icnt] as string;
                                            sIOn = iname.Text;
                                            //scale down
                                            if (iname.Content.Bounds.SizeY > PUPPIGUISettings.ioWidth)
                                            {
                                                iname.Height = iname.Height / (iname.Content.Bounds.SizeY / PUPPIGUISettings.ioWidth);
                                            }
                                            //special handling of custom nodes input caption position
                                            if (nodeCustomRenderer != null && nodeCustomRenderer.numberInputPositions == logical_representation.inputs.Count && nodeCustomRenderer.use3D)
                                            {
                                                PUPPICustomRenderer pcr = nodeCustomRenderer.inputPositions[icnt];
                                                iname.Position = new Point3D(ic.Content.Bounds.Location.X + ic.Content.Bounds.SizeX * 0.5 - pcr.bbox.SizeX * 0.25, ic.Content.Bounds.Location.Y + ic.Content.Bounds.SizeY * 0.5, ic.Content.Bounds.Location.Z + ic.Content.Bounds.SizeZ * 0.5 + pcr.bbox.SizeZ * 0.5 + PUPPIGUISettings.textRaise);
                                            }
                                            else
                                            {
                                                iname.Position = new Point3D(ic.Content.Bounds.Location.X + ic.Content.Bounds.SizeX * 0.25, ic.Content.Bounds.Location.Y + ic.Content.Bounds.SizeY * 0.5, ic.Content.Bounds.Location.Z + ic.Content.Bounds.SizeZ + PUPPIGUISettings.textRaise);
                                            }
                                        }
                                        else
                                        {
                                            iname.UpDirection = new Vector3D(0, 1, 0);
                                            iname.TextDirection = new Vector3D(1, 0, 0);
                                            iname.Height = PUPPIGUISettings.ioTextHeight;
                                            iname.FontFamily = PUPPIGUISettings.cacaFoFa;
                                            if (iname.Height > ic.Content.Bounds.SizeY * 0.5) iname.Height = ic.Content.Bounds.SizeY * 0.5;

                                            iname.Text = logical_representation.inputnames[icnt] as string;
                                            sIOn = iname.Text;

                                            //scale down
                                            if (iname.Content.Bounds.SizeX > PUPPIGUISettings.ioLength)
                                            {
                                                iname.Height = iname.Height / (iname.Content.Bounds.SizeX / PUPPIGUISettings.ioLength);
                                            }
                                            //special handling of custom nodes input caption position
                                            if (nodeCustomRenderer != null && nodeCustomRenderer.numberInputPositions == logical_representation.inputs.Count && nodeCustomRenderer.use2D)
                                            {
                                                PUPPICustomRenderer pcr = nodeCustomRenderer.inputPositions[icnt];
                                                iname.Position = new Point3D(ic.Content.Bounds.Location.X + ic.Content.Bounds.SizeX * 0.5 + pcr.bbox.SizeX * 0.5, ic.Content.Bounds.Location.Y + ic.Content.Bounds.SizeY * 0.5 + pcr.bbox.SizeY * 0.75, ic.Content.Bounds.Location.Z + ic.Content.Bounds.SizeZ * 0.5 + pcr.bbox.SizeZ * 0.5 + PUPPIGUISettings.textRaise);
                                            }
                                            else
                                            {
                                                iname.Position = new Point3D(ic.Content.Bounds.Location.X + ic.Content.Bounds.SizeX * 0.5, ic.Content.Bounds.Location.Y + ic.Content.Bounds.SizeY * 0.75, ic.Content.Bounds.Location.Z + ic.Content.Bounds.SizeZ + PUPPIGUISettings.textRaise);
                                            }
                                        }
                                        iname.SetName(ic.GetName() + "_Name");

                                        ic.Children.Add(iname);


                                        TextVisual3D ival = new TextVisual3D();
                                        ival.FontFamily = PUPPIGUISettings.cacaFoFa;
                                        //in 3d it goes up on the input
                                        if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                                        {
                                            ival.UpDirection = new Vector3D(1, 0, 0);
                                            ival.TextDirection = new Vector3D(0, 0, -1);

                                        }
                                        else
                                        {
                                            ival.UpDirection = new Vector3D(0, 1, 0);
                                            ival.TextDirection = new Vector3D(1, 0, 0);
                                        }
                                        ival.Height = PUPPIGUISettings.ioTextHeight;
                                        if (logical_representation.inputs[icnt].module != null)
                                        {
                                            try
                                            {
                                                if (logical_representation.inputs[icnt].module.listprocess == false)
                                                {

                                                    object vva = logical_representation.inputs[icnt].module.outputs[logical_representation.inputs[icnt].outParIndex];
                                                    if (vva != null)
                                                    {
                                                        //decimal show
                                                        if (vva.GetType() == typeof(double))
                                                        {
                                                            double d = Convert.ToDouble(vva);
                                                            if ((Math.Abs(d) < Math.Pow(10, -PUPPIGUISettings.showDigits) || Math.Abs(d) > Math.Pow(10, PUPPIGUISettings.showDigits)) && d != 0)
                                                            {
                                                                ival.Text = d.ToString("E" + PUPPIGUISettings.showDigits);
                                                            }
                                                            else
                                                            {
                                                                ival.Text = Math.Round(d, PUPPIGUISettings.showDigits).ToString();
                                                            }
                                                        }
                                                        else
                                                        {
                                                            ival.Text = vva.ToString();
                                                        }
                                                    }
                                                    else
                                                    {
                                                        ival.Text = "null";
                                                    }
                                                }
                                                else
                                                {
                                                    ival.Text = "Lst " + logical_representation.inputs[icnt].module.countListMode.ToString();
                                                }
                                            }
                                            catch
                                            {
                                                ival.Text = "";
                                            }
                                            if (ival.Text == "")
                                            {
                                                ival.Text = "null";
                                            }

                                            sIOv = ival.Text;
                                            //scale to fit going up
                                            if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                                            {
                                                if (ival.Content.Bounds.SizeZ > PUPPIGUISettings.ioHeight)
                                                {
                                                    ival.Height = ival.Height / (ival.Content.Bounds.SizeZ / PUPPIGUISettings.ioHeight);
                                                }
                                            }
                                            else
                                            {
                                                if (ival.Content.Bounds.SizeX > PUPPIGUISettings.ioLength)
                                                {
                                                    ival.Height = ival.Height / (ival.Content.Bounds.SizeX / PUPPIGUISettings.ioLength);
                                                }
                                                if (ival.Height > ic.Content.Bounds.SizeY * 0.5) ival.Height = ic.Content.Bounds.SizeY * 0.5;

                                            }
                                        }
                                        else
                                        {
                                            sIOv = "null";
                                        }
                                        if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                                        {
                                            //special handling of custom nodes input caption position
                                            if (nodeCustomRenderer != null && nodeCustomRenderer.numberInputPositions == logical_representation.inputs.Count && nodeCustomRenderer.use3D)
                                            {
                                                PUPPICustomRenderer pcr = nodeCustomRenderer.inputPositions[icnt];
                                                ival.Position = new Point3D(ic.Content.Bounds.Location.X + ic.Content.Bounds.SizeX * 0.5 + pcr.bbox.SizeX * 0.25, ic.Content.Bounds.Location.Y + ic.Content.Bounds.SizeX * 0.5 - pcr.bbox.SizeX * 0.5 - PUPPIGUISettings.textRaise, ic.Content.Bounds.Location.Z + ic.Content.Bounds.SizeZ * 0.5);
                                            }
                                            else
                                            {
                                                ival.Position = new Point3D(ic.Content.Bounds.Location.X + ic.Content.Bounds.SizeX * 0.25, ic.Content.Bounds.Location.Y - PUPPIGUISettings.textRaise, ic.Content.Bounds.Location.Z + ic.Content.Bounds.SizeZ * 0.5);
                                            }
                                        }
                                        else
                                        {
                                            //special handling of custom nodes input caption position
                                            if (nodeCustomRenderer != null && nodeCustomRenderer.numberInputPositions == logical_representation.inputs.Count && nodeCustomRenderer.use2D)
                                            {
                                                PUPPICustomRenderer pcr = nodeCustomRenderer.inputPositions[icnt];
                                                ival.Position = new Point3D(ic.Content.Bounds.Location.X + ic.Content.Bounds.SizeX * 0.5 + pcr.bbox.SizeX * 0.5, ic.Content.Bounds.Location.Y + ic.Content.Bounds.SizeY * 0.5 + pcr.bbox.SizeY * 0.25, ic.Content.Bounds.Location.Z + ic.Content.Bounds.SizeZ * 0.5 + pcr.bbox.SizeZ * 0.5 + PUPPIGUISettings.textRaise);
                                            }
                                            else
                                            {
                                                ival.Position = new Point3D(ic.Content.Bounds.Location.X + ic.Content.Bounds.SizeX * 0.5, ic.Content.Bounds.Location.Y + ic.Content.Bounds.SizeY * 0.25, ic.Content.Bounds.Location.Z + ic.Content.Bounds.SizeZ + PUPPIGUISettings.textRaise);
                                            }

                                        }

                                        ival.SetName(ic.GetName() + "_Value");
                                        ic.Children.Add(ival);
                                    }
                                    //create new input object
                                    if (vizinputs[icnt] == null)
                                    {
                                        ModViz3DInput ic3d = new ModViz3DInput(ic, mycanvas, ic.GetName(), logical_representation.inputs[icnt]);
                                        vizinputs[icnt] = ic3d;
                                    }
                                    else
                                    {
                                        vizinputs[icnt].myself = ic;
                                    }
                                    vizinputs[icnt].isCustom = isCustom;
                                    vizinputs[icnt].myPosition = iP;
                                    vizinputs[icnt].myBB = mB;
                                    vizinputs[icnt].visualInputNameString = sIOn;
                                    vizinputs[icnt].visualInputValueString = sIOv;
                                    ipos = ipos + ispacing + PUPPIGUISettings.ioLength;

                                }
                            }

                        }
                    }
                    #endregion
                    #region updatingOutputs
                    //   iochanged = false;
                    if (vizoutputs != null)
                    {
                        //so that we don't overwrite outputs if they exist and lose the link to pipes
                        bool newouts = true;
                        if (vizoutputs.Count > 0 && vizoutputs.Count == logical_representation.outputs.Count)
                        {
                            for (int ieie = 0; ieie < vizoutputs.Count; ieie++)
                            {
                                if (vizoutputs[ieie] != null && vizoutputs[ieie].myself != null)
                                {
                                    // if (!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas)
                                    if (!mycanvas.thiscanvasdefinitelylocked)
                                        myview.Children.Remove(vizoutputs[ieie].myself);
                                }
                            }
                            newouts = false;
                        }
                        //in case module changed
                        else if ((vizoutputs.Count > 0 || logical_representation.outputs.Count > 0) && vizoutputs.Count != logical_representation.outputs.Count)
                        {
                            iochanged = true;
                            newouts = false;
                            for (int ieie = 0; ieie < vizoutputs.Count; ieie++)
                            {
                                if (vizoutputs[ieie] != null && vizoutputs[ieie].myself != null)
                                {
                                    if (!mycanvas.thiscanvasdefinitelylocked)
                                        myview.Children.Remove(vizoutputs[ieie].myself);
                                }
                                // foreach (ModViz3DConn mc in vizoutputs[ieie].outboundconns)
                                //{
                                //     if (mc!=null)
                                //    mc.forceConnRedraw = true; 
                                // }
                            }
                            //add or remove of outputs gets done at the end and assuming they are not connected
                            if (vizoutputs.Count > logical_representation.outputs.Count)
                            {
                                while (vizoutputs.Count > logical_representation.outputs.Count)
                                {
                                    vizoutputs.RemoveAt(vizoutputs.Count - 1);
                                }
                            }
                            else
                            {
                                while (vizoutputs.Count < logical_representation.outputs.Count)
                                {
                                    ModViz3DOutput newout = new ModViz3DOutput(null, this.mycanvas);
                                    vizoutputs.Add(newout);
                                }
                            }
                        }
                        else
                        {
                            vizoutputs.Clear();
                        }
                        ////in case module changed
                        //else
                        //{




                        //    if (vizoutputs.Count > 0 && vizoutputs.Count != logical_representation.outputs.Count)
                        //    {
                        //        needToRegenConn = true;
                        //    }
                        //    for (int ieie = 0; ieie < vizoutputs.Count; ieie++)
                        //    {
                        //        foreach (ModViz3DConn mc in vizoutputs[ieie].outboundconns)
                        //        {
                        //            if (mc!=null && mc.myself != null && myview.Children.Contains(mc.myself))
                        //            {
                        //                myview.Children.Remove(mc.myself);
                        //                if (mycanvas.connpaths.ContainsKey(mc.visualGUID))
                        //                {
                        //                    mycanvas.connpaths.Remove(mc.visualGUID);
                        //                }

                        //            }

                        //        }

                        //        myview.Children.Remove(vizoutputs[ieie].myself);
                        //    }
                        //    vizoutputs.Clear();

                        //}

                        //vizoutputs.Clear();
                        if (logical_representation.outputs.Count > 0)
                        {
                            hpos = boundingBox.Location.Z + PUPPIGUISettings.nodeHeight - PUPPIGUISettings.ioHeight;
                            jpos = boundingBox.Location.X + boundingBox.SizeX - PUPPIGUISettings.ioWidth / 2;
                            //iheight = boundingBox.SizeY / (logical_representation.outputs.Count + 0.5 * (logical_representation.outputs.Count + 1));
                            ispacing = (boundingBox.SizeY - logical_representation.outputs.Count * PUPPIGUISettings.ioLength) / (logical_representation.outputs.Count + 1);

                            //iheight = boundingBox.SizeY / (logical_representation.inputs.Count + 0.5 * (logical_representation.inputs.Count + 1));
                            if (ispacing < PUPPIGUISettings.ioMinSpacing - PUPPIGUISettings.errF)
                            {
                                // throw new Exception("Node too small for number of outputs");
                                //throw new Exception("Node too small for number of inputs");
                                //resize box in y direction
                                double newy = logical_representation.outputs.Count * (PUPPIGUISettings.ioLength + PUPPIGUISettings.ioMinSpacing) + PUPPIGUISettings.ioMinSpacing + PUPPIGUISettings.errF;
                                double divvy = newy.nodespaceconvert();
                                if (divvy < newy) newy = divvy + PUPPIGUISettings.nodeSpacing;
                                //newy = divvy;
                                //make even numbered for nicer symmetry
                                if (Convert.ToInt16(newy / PUPPIGUISettings.nodeSpacing) % 2 != 0)
                                {
                                    newy += PUPPIGUISettings.nodeSpacing;
                                }

                                Rect3D newbsize = new Rect3D(boundingBox.Location.X, boundingBox.Location.Y + boundingBox.SizeY / 2 - newy / 2, boundingBox.Location.Z, boundingBox.SizeX, newy, boundingBox.SizeZ).locationnodeSpacing();
                                if (fixedbox == false)
                                {
                                    ModelVisual3D newme = replacebox(newbsize, 1);
                                    bottompyramid(this);
                                }

                            }
                            else
                            {
                                ipos = boundingBox.Location.Y + ispacing;
                                for (int icnt = 0; icnt < logical_representation.outputs.Count; icnt++)
                                {
                                    bool isCustom = false;
                                    Rect3D mB = new Rect3D();
                                    ModelVisual3D oc = null;
                                    if (nodeCustomRenderer == null || nodeCustomRenderer.numberOutputPositions != logical_representation.outputs.Count || (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional && nodeCustomRenderer.use2D == false) || (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional && nodeCustomRenderer.use3D == false))
                                    {
                                        oc = addbox(new Rect3D(jpos, ipos, hpos, PUPPIGUISettings.ioWidth, PUPPIGUISettings.ioLength, PUPPIGUISettings.ioHeight + PUPPIGUISettings.textRaise), mycanvas.output_default_mat, !mycanvas.thiscanvasdefinitelylocked);
                                        mB = new Rect3D(jpos, ipos, hpos, PUPPIGUISettings.ioWidth, PUPPIGUISettings.ioLength, PUPPIGUISettings.ioHeight + PUPPIGUISettings.textRaise);

                                    }
                                    else
                                    {
                                        PUPPICustomRenderer pcr = nodeCustomRenderer.outputPositions[icnt];
                                        Vector3D tranv = new Vector3D();
                                        if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional && nodeCustomRenderer.use2D)
                                        {


                                            isCustom = true;
                                            if (pcr.needsRender) pcr.renderCustom();


                                            //Vector3D tranv = Point3D.Subtract(myposition, Point3D.Subtract(pcr.bbox.rectcenter(), nodeCustomRenderer.bbox.rectcenter()).ToPoint3D());
                                            tranv = Point3D.Subtract(myposition, new Point3D(0, 0, 0));// nodeCustomRenderer.bbox.rectcenter());    
                                            oc = pcr.model2D.moveVisualChildren(tranv, Point3D.Add(pcr.bbox.rectcenter(), tranv).makeSizeBox(smallBoxSize, smallBoxSize, smallBoxSize), mycanvas.customRenderBox_default_mat);
                                        }

                                        if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional && nodeCustomRenderer.use3D)
                                        {


                                            isCustom = true;
                                            if (pcr.needsRender) pcr.renderCustom();


                                            //Vector3D tranv = Point3D.Subtract(myposition, Point3D.Subtract(pcr.bbox.rectcenter(), nodeCustomRenderer.bbox.rectcenter()).ToPoint3D());
                                            tranv = Point3D.Subtract(myposition, new Point3D(0, 0, 0));//nodeCustomRenderer.bbox.rectcenter());
                                            oc = pcr.model3D.moveVisualChildren(tranv, Point3D.Add(pcr.bbox.rectcenter(), tranv).makeSizeBox(smallBoxSize, smallBoxSize, smallBoxSize), mycanvas.customRenderBox_default_mat);
                                        }
                                        //need toa dd it to view separately
                                        //  if (!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas)
                                        if (!mycanvas.thiscanvasdefinitelylocked)
                                            myview.Children.Add(oc);

                                        //need to name children accordingly
                                        for (int icc = 0; icc < oc.Children.Count; icc++)
                                        {
                                            (oc.Children[icc] as ModelVisual3D).SetName("O_" + icnt.ToString() + "_" + nodeGUID.ToString() + "_" + icc.ToString());
                                        }

                                        mB = pcr.bbox;
                                        mB.Offset(tranv);

                                    }
                                    Point3D oP = new Rect3D(jpos, ipos, hpos, PUPPIGUISettings.ioWidth, PUPPIGUISettings.ioLength, PUPPIGUISettings.ioHeight + PUPPIGUISettings.textRaise).rectcenter();
                                    oc.SetName("O_" + icnt.ToString() + "_" + nodeGUID.ToString());
                                    if (nodeCustomRenderer == null || nodeCustomRenderer.numberOutputPositions != logical_representation.outputs.Count || (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional && nodeCustomRenderer.use2D == false) || (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional && nodeCustomRenderer.use3D == false) || nodeCustomRenderer.outputPositions[icnt].useDefaultCaption)
                                    {
                                        //update text on the parameter
                                        TextVisual3D iname = new TextVisual3D();
                                        iname.FontFamily = PUPPIGUISettings.cacaFoFa;
                                        if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                                        {
                                            iname.UpDirection = new Vector3D(1, 0, 0);
                                            iname.TextDirection = new Vector3D(0, -1, 0);
                                            iname.Height = PUPPIGUISettings.ioTextHeight;
                                            if (iname.Height > oc.Content.Bounds.SizeY * 0.5) iname.Height = oc.Content.Bounds.SizeY * 0.5;
                                            iname.Text = logical_representation.outputnames[icnt] as string;
                                            sIOn = iname.Text;
                                            //scale down
                                            if (iname.Content.Bounds.SizeY > PUPPIGUISettings.ioWidth)
                                            {
                                                iname.Height = iname.Height / (iname.Content.Bounds.SizeY / PUPPIGUISettings.ioWidth);
                                            }
                                            //special handling of custom nodes input caption position
                                            if (nodeCustomRenderer != null && nodeCustomRenderer.numberOutputPositions == logical_representation.outputs.Count && nodeCustomRenderer.use3D)
                                            {
                                                PUPPICustomRenderer pcr = nodeCustomRenderer.outputPositions[icnt];
                                                iname.Position = new Point3D(oc.Content.Bounds.Location.X + oc.Content.Bounds.SizeX * 0.5 + pcr.bbox.SizeX * 0.375, oc.Content.Bounds.Location.Y + oc.Content.Bounds.SizeY * 0.5, oc.Content.Bounds.Location.Z + oc.Content.Bounds.SizeZ * 0.5 + pcr.bbox.SizeX * 0.5 + PUPPIGUISettings.textRaise);
                                            }
                                            else
                                            {
                                                iname.Position = new Point3D(oc.Content.Bounds.Location.X + oc.Content.Bounds.SizeX * 0.75, oc.Content.Bounds.Location.Y + oc.Content.Bounds.SizeY * 0.5, oc.Content.Bounds.Location.Z + oc.Content.Bounds.SizeZ + PUPPIGUISettings.textRaise);
                                            }
                                        }
                                        else
                                        {
                                            iname.UpDirection = new Vector3D(0, 1, 0);
                                            iname.TextDirection = new Vector3D(1, 0, 0);
                                            iname.Height = PUPPIGUISettings.ioTextHeight;
                                            if (iname.Height > oc.Content.Bounds.SizeY * 0.5) iname.Height = oc.Content.Bounds.SizeY * 0.5;

                                            iname.Text = logical_representation.outputnames[icnt] as string;
                                            sIOn = iname.Text;

                                            //scale down
                                            if (iname.Content.Bounds.SizeX > PUPPIGUISettings.ioLength)
                                            {
                                                iname.Height = iname.Height / (iname.Content.Bounds.SizeX / PUPPIGUISettings.ioLength);
                                            }
                                            if (nodeCustomRenderer != null && nodeCustomRenderer.numberOutputPositions == logical_representation.outputs.Count && nodeCustomRenderer.use2D)
                                            {
                                                PUPPICustomRenderer pcr = nodeCustomRenderer.outputPositions[icnt];
                                                iname.Position = new Point3D(oc.Content.Bounds.Location.X + oc.Content.Bounds.SizeX * 0.5 + pcr.bbox.SizeX * 0.5, oc.Content.Bounds.Location.Y + oc.Content.Bounds.SizeX * 0.5 + pcr.bbox.SizeY * 0.375, oc.Content.Bounds.Location.Z + oc.Content.Bounds.SizeZ * 0.5 + pcr.bbox.SizeZ * 0.5 + PUPPIGUISettings.textRaise);
                                            }
                                            else
                                            {
                                                iname.Position = new Point3D(oc.Content.Bounds.Location.X + oc.Content.Bounds.SizeX * 0.5, oc.Content.Bounds.Location.Y + oc.Content.Bounds.SizeY * 0.75, oc.Content.Bounds.Location.Z + oc.Content.Bounds.SizeZ + PUPPIGUISettings.textRaise);
                                            }
                                        }

                                        iname.SetName(oc.GetName() + "_Name");
                                        oc.Children.Add(iname);

                                        TextVisual3D ival = new TextVisual3D();
                                        ival.FontFamily = PUPPIGUISettings.cacaFoFa;
                                        if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                                        {
                                            ival.UpDirection = new Vector3D(1, 0, 0);
                                            ival.TextDirection = new Vector3D(0, 0, -1);
                                        }
                                        else
                                        {
                                            ival.UpDirection = new Vector3D(0, 1, 0);
                                            ival.TextDirection = new Vector3D(1, 0, 0);

                                        }
                                        ival.Height = PUPPIGUISettings.ioTextHeight;
                                        try
                                        {
                                            if (logical_representation.listprocess == false)
                                            {
                                                if (logical_representation.outputs[icnt] != null)
                                                {
                                                    object vva = logical_representation.outputs[icnt];
                                                    if (vva.GetType() == typeof(double))
                                                    {
                                                        double d = Convert.ToDouble(vva);
                                                        if ((Math.Abs(d) < Math.Pow(10, -PUPPIGUISettings.showDigits) || Math.Abs(d) > Math.Pow(10, PUPPIGUISettings.showDigits)) && d != 0)
                                                        {
                                                            ival.Text = d.ToString("E" + PUPPIGUISettings.showDigits);
                                                        }
                                                        else
                                                        {
                                                            ival.Text = Math.Round(d, PUPPIGUISettings.showDigits).ToString();
                                                        }
                                                    }
                                                    else
                                                    {
                                                        ival.Text = vva.ToString();
                                                    }
                                                    // ival.Text = logical_representation.outputs[icnt].ToString();
                                                }
                                                else
                                                {
                                                    ival.Text = "null";
                                                }
                                            }
                                            else
                                            {
                                                ival.Text = "Lst " + logical_representation.countListMode.ToString();
                                            }
                                        }
                                        catch
                                        {
                                            ival.Text = "";
                                        }
                                        //scale to fit going up
                                        if (ival.Text == "")
                                        {
                                            ival.Text = "null";
                                        }
                                        sIOv = ival.Text;
                                        if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                                        {
                                            if (ival.Content.Bounds.SizeZ > PUPPIGUISettings.ioHeight)
                                            {
                                                ival.Height = ival.Height / (ival.Content.Bounds.SizeZ / PUPPIGUISettings.ioHeight);
                                            }
                                        }
                                        else
                                        {
                                            if (ival.Content.Bounds.SizeX > PUPPIGUISettings.ioLength)
                                            {
                                                ival.Height = ival.Height / (ival.Content.Bounds.SizeX / PUPPIGUISettings.ioLength);
                                            }
                                            if (ival.Height > oc.Content.Bounds.SizeY * 0.5) ival.Height = oc.Content.Bounds.SizeY * 0.5;

                                        }
                                        if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                                        {
                                            if (nodeCustomRenderer != null && nodeCustomRenderer.numberOutputPositions == logical_representation.outputs.Count && nodeCustomRenderer.use3D)
                                            {
                                                PUPPICustomRenderer pcr = nodeCustomRenderer.outputPositions[icnt];
                                                ival.Position = new Point3D(oc.Content.Bounds.Location.X + oc.Content.Bounds.SizeX * 0.5 + pcr.bbox.SizeX * 0.375, oc.Content.Bounds.Location.Y + oc.Content.Bounds.SizeY * 0.5 - pcr.bbox.SizeY * 0.5 - PUPPIGUISettings.textRaise, oc.Content.Bounds.Location.Z + oc.Content.Bounds.SizeZ * 0.5);
                                            }
                                            else
                                            {
                                                ival.Position = new Point3D(oc.Content.Bounds.Location.X + oc.Content.Bounds.SizeX * 0.75, oc.Content.Bounds.Location.Y - PUPPIGUISettings.textRaise, oc.Content.Bounds.Location.Z + oc.Content.Bounds.SizeZ * 0.5);
                                            }
                                        }
                                        else
                                        {
                                            if (nodeCustomRenderer != null && nodeCustomRenderer.numberOutputPositions == logical_representation.outputs.Count && nodeCustomRenderer.use2D)
                                            {
                                                PUPPICustomRenderer pcr = nodeCustomRenderer.outputPositions[icnt];
                                                ival.Position = new Point3D(oc.Content.Bounds.Location.X + oc.Content.Bounds.SizeX * 0.5, oc.Content.Bounds.Location.Y + oc.Content.Bounds.SizeY * 5 - pcr.bbox.SizeY * 0.25, oc.Content.Bounds.Location.Z + oc.Content.Bounds.SizeZ * 0.5 + pcr.bbox.SizeZ * 0.5 + PUPPIGUISettings.textRaise);
                                            }
                                            else
                                            {
                                                ival.Position = new Point3D(oc.Content.Bounds.Location.X + oc.Content.Bounds.SizeX * 0.5, oc.Content.Bounds.Location.Y + oc.Content.Bounds.SizeY * 0.25, oc.Content.Bounds.Location.Z + oc.Content.Bounds.SizeZ + PUPPIGUISettings.textRaise);
                                            }

                                        }


                                        ival.SetName(oc.GetName() + "_Value");
                                        oc.Children.Add(ival);
                                    }
                                    if (newouts == true)
                                    {
                                        ModViz3DOutput newout = new ModViz3DOutput(oc, this.mycanvas);
                                        vizoutputs.Add(newout);
                                    }
                                    else
                                    {

                                        vizoutputs[icnt].myself = oc;
                                    }
                                    vizoutputs[icnt].myPosition = oP;
                                    vizoutputs[icnt].isCustom = isCustom;
                                    vizoutputs[icnt].myBB = mB;
                                    vizoutputs[icnt].visualOutputNameString = sIOn;
                                    vizoutputs[icnt].visualOutputValueString = sIOv;
                                    ipos = ipos + ispacing + PUPPIGUISettings.ioLength;
                                }
                            }

                        }
                    }
                    #endregion
                    ////0 inputs and 0 outputs, should update
                    //if (logical_representation.inputs.Count == 0 && logical_representation.outputs.Count == 0 && vizinputs != null && vizoutputs != null)

                    //{ 
                    //    iochanged = true; 
                    //} 

                    //if (needToRegenConn) mycanvas.regenerate_connections(false);

                    if (iochanged)
                    {
                        if (PUPPIDebugger.debugenabled)
                        {
                            PUPPIDebugger.log("inputs or outputs count changed, refactoring node " + this.nodeGUID.ToString());
                        }
                        Rect3D rr = boundingBox;
                        if (fixedbox == false)
                        {


                            //only if top of stack or children already have visuals
                            bool dowholeshabang = false;
                            if (childs.Count == 0)
                            {
                                dowholeshabang = true;
                            }
                            else
                            {
                                for (int cc = 0; cc < childs.Count; cc++)
                                {
                                    if (childs[cc] != null && childs[cc].myself != null)
                                    {
                                        dowholeshabang = true;
                                        ModViz3DNode ct = childs[cc];
                                        if (ct.vizinputs != null && ct.logical_representation != null)
                                        {
                                            //top changed, no need to do here
                                            if ((ct.vizinputs.Count > 0 || ct.logical_representation.inputs.Count > 0) && ct.vizinputs.Count != ct.logical_representation.inputs.Count)
                                            {
                                                dowholeshabang = false;
                                            }
                                            else if ((ct.vizoutputs.Count > 0 || ct.logical_representation.outputs.Count > 0) && ct.vizoutputs.Count != ct.logical_representation.outputs.Count)
                                            {
                                                dowholeshabang = false;
                                            }
                                        }
                                    }
                                    if (dowholeshabang == true) break;
                                }
                            }



                            if (dowholeshabang)
                            {
                                replacebox(rr);
                                bottompyramid(this);
                                getroot().fitroots(mycanvas.stacks);
                                //assume fixedbox used with explicit connection update call
                                // bool bck = mycanvas.blockconnupdates;
                                //mycanvas.blockconnupdates = false;
                                mycanvas.update_all_connectors();
                                //mycanvas.blockconnupdates = bck; 
                            }
                            else
                            {
                                replacebox(rr, 3);
                            }

                        }
                        //test
                        //Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
                    }
                    if (PUPPIDebugger.debugenabled)
                    {
                        PUPPIDebugger.log(utils.StringConstants.finishedupdatinginouts + this.nodeGUID.ToString());
                    }
                    if (mycanvas != null)
                    {
                        mycanvas.lastChanged = DateTime.Now;

                        if ((PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning || PUPPIruntimesettings.PUPPICanvasHTTPServerIsRunning) && PUPPIruntimesettings.PUPPICanvasServerUpdatingFully)
                        {
                            PUPPICanvas.currentCanvasStatusServer = mycanvas.readMyCanvasStatus();
                            mycanvas.saveReponThread();
                            mycanvas.updateNodeInfoServer(this.nodeGUID.ToString());
                        }
                    }
                }
                //}
                //catch
                //{
                //    throw new Exception("Failed to update node inputs and outputs");
                //}
            }
            //only text unless number of inputs or outputs changed
            //called from a separate thread
            internal void update_inouts_v()
            {
                //test
                //Thread.Sleep(500);  


                //try
                //{
                myview = mycanvas.hv;
                //first the inputs, on the xminside

                //need to force more updates if number of inputs or outputs changed
                bool iochanged = false;
                if (logical_representation != null && myself != null)
                {
                    if (PUPPIDebugger.debugenabled)
                    {
                        PUPPIDebugger.log(utils.StringConstants.startedupdatinginouts + this.nodeGUID.ToString());
                    }

                    //test
                    //Thread.Sleep(500);  

                    if (vizinputs != null)
                    {
                        if (vizinputs.Count == logical_representation.inputs.Count)
                        {


                        }

                        else
                        //first time
                        {
                            update_inouts();
                            return;
                        }
                    }
                    else
                    {
                        update_inouts();
                        return;
                    }
                    //test
                    //Thread.Sleep(500);  
                    if (vizoutputs != null)
                    {
                        if (vizoutputs.Count == logical_representation.outputs.Count)
                        {


                        }

                        else
                        //first time
                        {
                            update_inouts();
                            return;
                        }
                    }
                    else
                    {
                        update_inouts();
                        return;
                    }
                    //test
                    //Thread.Sleep(500);  
                    //now we know we only need to change text
                    for (int icnt = 0; icnt < logical_representation.inputs.Count; icnt++)
                    {
                        ModViz3DInput iin = vizinputs[icnt];

                        if (iin != null && iin.myself != null)
                        {
                            TextVisual3D ival = null;
                            for (int ich = 0; ich < iin.myself.Children.Count; ich++)
                            {
                                if (iin.myself.Children[ich].GetName() == iin.myself.GetName() + "_Value")
                                {
                                    ival = iin.myself.Children[ich] as TextVisual3D;
                                    break;
                                }
                            }
                            if (ival != null)
                            {
                                if (logical_representation.inputs[icnt].module != null)
                                {
                                    try
                                    {
                                        //test
                                        //Thread.Sleep(500);  
                                        if (logical_representation.inputs[icnt].module.listprocess == false)
                                        {

                                            object vva = logical_representation.inputs[icnt].module.outputs[logical_representation.inputs[icnt].outParIndex];
                                            if (vva != null)
                                            {
                                                //decimal show
                                                if (vva.GetType() == typeof(double))
                                                {
                                                    double d = Convert.ToDouble(vva);
                                                    if ((Math.Abs(d) < Math.Pow(10, -PUPPIGUISettings.showDigits) || Math.Abs(d) > Math.Pow(10, PUPPIGUISettings.showDigits)) && d != 0)
                                                    {
                                                        ival.Text = d.ToString("E" + PUPPIGUISettings.showDigits);
                                                    }
                                                    else
                                                    {
                                                        ival.Text = Math.Round(d, PUPPIGUISettings.showDigits).ToString();
                                                    }
                                                }
                                                else
                                                {
                                                    ival.Text = vva.ToString();
                                                }
                                            }
                                            else
                                            {
                                                ival.Text = "null";
                                            }
                                        }
                                        else
                                        {
                                            //test
                                            //Thread.Sleep(500);  
                                            ival.Text = "Lst " + logical_representation.inputs[icnt].module.countListMode.ToString();
                                        }
                                    }
                                    catch
                                    {
                                        ival.Text = "";
                                    }
                                    if (ival.Text == "")
                                    {
                                        ival.Text = "null";
                                    }

                                }
                                else
                                {
                                    ival.Text = "null";
                                }
                                //scale to fit 
                                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                                {
                                    if (ival.Content.Bounds.SizeZ > PUPPIGUISettings.ioHeight)
                                    {
                                        ival.Height = ival.Height / (ival.Content.Bounds.SizeZ / PUPPIGUISettings.ioHeight);
                                    }
                                }
                                else
                                {
                                    if (ival.Content.Bounds.SizeX > PUPPIGUISettings.ioLength)
                                    {
                                        ival.Height = ival.Height / (ival.Content.Bounds.SizeX / PUPPIGUISettings.ioLength);
                                    }
                                    if (ival.Height > iin.myself.Content.Bounds.SizeY * 0.5) ival.Height = iin.myself.Content.Bounds.SizeY * 0.5;

                                }
                                //test
                                //Thread.Sleep(500);  
                                vizinputs[icnt].visualInputValueString = ival.Text;
                            }
                        }

                    }

                    for (int icnt = 0; icnt < logical_representation.outputs.Count; icnt++)
                    {
                        ModViz3DOutput iin = vizoutputs[icnt];

                        if (iin != null && iin.myself != null)
                        {
                            TextVisual3D ival = null;
                            for (int ich = 0; ich < iin.myself.Children.Count; ich++)
                            {
                                //test
                                //Thread.Sleep(500);  
                                if (iin.myself.Children[ich].GetName() == iin.myself.GetName() + "_Value")
                                {
                                    ival = iin.myself.Children[ich] as TextVisual3D;
                                    break;
                                }
                            }
                            if (ival != null)
                            {
                                try
                                {
                                    if (logical_representation.listprocess == false)
                                    {
                                        if (logical_representation.outputs[icnt] != null)
                                        {
                                            object vva = logical_representation.outputs[icnt];
                                            if (vva.GetType() == typeof(double))
                                            {
                                                double d = Convert.ToDouble(vva);
                                                if ((Math.Abs(d) < Math.Pow(10, -PUPPIGUISettings.showDigits) || Math.Abs(d) > Math.Pow(10, PUPPIGUISettings.showDigits)) && d != 0)
                                                {
                                                    ival.Text = d.ToString("E" + PUPPIGUISettings.showDigits);
                                                }
                                                else
                                                {
                                                    ival.Text = Math.Round(d, PUPPIGUISettings.showDigits).ToString();
                                                }
                                            }
                                            else
                                            {
                                                ival.Text = vva.ToString();
                                            }
                                            // ival.Text = logical_representation.outputs[icnt].ToString();
                                        }
                                        else
                                        {
                                            ival.Text = "null";
                                        }
                                    }
                                    else
                                    {
                                        ival.Text = "Lst " + logical_representation.countListMode.ToString();
                                    }
                                }
                                catch
                                {
                                    //test
                                    //Thread.Sleep(500);  
                                    ival.Text = "";
                                }
                                //scale to fit going up
                                if (ival.Text == "")
                                {
                                    ival.Text = "null";
                                }
                                vizoutputs[icnt].visualOutputValueString = ival.Text;
                                //scale to fit 
                                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                                {
                                    if (ival.Content.Bounds.SizeZ > PUPPIGUISettings.ioHeight)
                                    {
                                        ival.Height = ival.Height / (ival.Content.Bounds.SizeZ / PUPPIGUISettings.ioHeight);
                                    }
                                }
                                else
                                {
                                    if (ival.Content.Bounds.SizeX > PUPPIGUISettings.ioLength)
                                    {
                                        ival.Height = ival.Height / (ival.Content.Bounds.SizeX / PUPPIGUISettings.ioLength);
                                    }
                                    if (ival.Height > iin.myself.Content.Bounds.SizeY * 0.5) ival.Height = iin.myself.Content.Bounds.SizeY * 0.5;

                                }
                            }
                        }
                    }
                    //test
                    //Thread.Sleep(500);  

                    if (PUPPIDebugger.debugenabled)
                    {
                        PUPPIDebugger.log(utils.StringConstants.finishedupdatinginouts + this.nodeGUID.ToString());
                    }


                }
                else
                {
                    //test
                    //Thread.Sleep(500);  
                    update_inouts();
                }
                if (mycanvas != null)
                {
                    mycanvas.lastChanged = DateTime.Now;

                    if ((PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning || PUPPIruntimesettings.PUPPICanvasHTTPServerIsRunning) && PUPPIruntimesettings.PUPPICanvasServerUpdatingFully)
                    {
                        PUPPICanvas.currentCanvasStatusServer = mycanvas.readMyCanvasStatus();
                        mycanvas.saveReponThread();
                        mycanvas.updateNodeInfoServer(this.nodeGUID.ToString());
                    }
                }
            }


            //inputs get disconencted at right click
            internal void disconnectinput(int inputindex, bool checkOnCanvas = true)
            {
                if (inputindex >= 0 && inputindex < logical_representation.inputs.Count)
                {

                    ModViz3DInput disinput = vizinputs[inputindex];
                    //check if it's actually connected to anything

                    if (disinput.myinput.module != null)
                    {
                        //try
                        //{
                        if (disinput.myconnector != null)
                        {

                            disinput.myconnector.deletevisual();
                        }
                        disinput.myconnector = null;
                        //remove connection from output list
                        string thisconnid = "conn_" + disinput.myinput.module.GUID.ToString() + "_" + disinput.myinput.outParIndex.ToString() + "_" + nodeGUID.ToString() + "_" + inputindex.ToString();
                        //try
                        //{
                        // string cnf ="conn_"+ pinp.module.GUID.ToString() + "_" + pinp.outParIndex.ToString() + "_" + newnode.nodeGUID.ToString() + "_" + ii.ToString();
                        if (mycanvas.connpaths.ContainsKey(thisconnid))
                            mycanvas.connpaths[thisconnid].sourcenode.vizoutputs[mycanvas.connpaths[thisconnid].sourceoutindex].outboundconns.Remove(mycanvas.connpaths[thisconnid]);
                        //}
                        //catch
                        //{
                        //}
                        //mycanvas.connpaths["conn_" + disinput.inputVisualGUID] = null;
                        mycanvas.connpaths.Remove(thisconnid);

                        bool disco = logical_representation.disconnect_input(inputindex, checkOnCanvas);
                        disinput.myinput.module = null;
                        update_inouts();
                        //}
                        //catch
                        //{

                        //}
                    }
                    //have to also redo the data
                    // logical_representation.doIprocess();  
                    //logical_representation.prochan += new PUPPIModule.processhandler(logicchanged);
                }
            }

            //deletes the connection visual on specified input
            internal void deleteInputConnectionVisual(int inputindex)
            {
                if (inputindex >= 0 && inputindex < logical_representation.inputs.Count)
                {

                    ModViz3DInput disinput = vizinputs[inputindex];
                    //check if it's actually connected to anything

                    if (disinput.myinput.module != null)
                    {

                        if (disinput.myconnector != null)
                        {

                            disinput.myconnector.deletevisual();
                        }
                        disinput.myconnector = null;
                        //remove connection from output list
                        string thisconnid = "conn_" + disinput.myinput.module.GUID.ToString() + "_" + disinput.myinput.outParIndex.ToString() + "_" + nodeGUID.ToString() + "_" + inputindex.ToString();
                        if (mycanvas.connpaths.ContainsKey(thisconnid))
                            mycanvas.connpaths[thisconnid].sourcenode.vizoutputs[mycanvas.connpaths[thisconnid].sourceoutindex].outboundconns.Remove(mycanvas.connpaths[thisconnid]);
                        mycanvas.connpaths.Remove(thisconnid);


                    }

                }
            }

            //gets the nodes downstream
            internal List<ModViz3DNode> getAllNodesDownstream(int oindex)
            {
                List<ModViz3DNode> ds = new List<ModViz3DNode>();
                foreach (ModViz3DNode mv in mycanvas.stacks.Values)
                {
                    if (mv.getAllNodesUpstream().Contains(this))
                    {
                        for (int i = 0; i < mv.logical_representation.inputs.Count; i++)
                        {
                            PUPPIInParameter pinp = mv.logical_representation.inputs[i];
                            if (pinp.module == logical_representation && pinp.outParIndex == oindex)
                            {
                                ds.Add(mv);
                            }
                        }
                    }
                }
                return ds;
            }
            //gets the nodes upstream
            internal List<ModViz3DNode> getAllNodesUpstream()
            {
                List<ModViz3DNode> ds = new List<ModViz3DNode>();

                for (int i = 0; i < logical_representation.inputs.Count; i++)
                {
                    PUPPIInParameter pinp = logical_representation.inputs[i];
                    if (pinp.module != null)
                    {
                        ModViz3DNode mia;
                        bool bi = mycanvas.stacks.TryGetValue(pinp.module.GUID.ToString(), out mia);
                        if (bi) ds.Add(mia);
                    }
                }
                return ds;
            }


            //gets the nodes upstream
            internal ModViz3DNode getNodeUpstreamByInput(int ii)
            {
                if (ii < 0 || ii >= vizinputs.Count) return null;

                if (logical_representation == null) return null;
                PUPPIInParameter pinp = logical_representation.inputs[ii];
                if (pinp.module != null)
                {
                    ModViz3DNode mia;
                    bool bi = mycanvas.stacks.TryGetValue(pinp.module.GUID.ToString(), out mia);
                    if (bi) return mia;
                }
                return null;

            }

            //creates a number node and connects it to the input
            internal void setinputvaluenumeric(int inputindex)
            {
                //for now only works in 3d
                //if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional) return;

                ModViz3DNode gotnode = this;
                //we add on top of the stack    
                if (acceptschilds() == false)
                {
                    gotnode = getrectopchild();
                }


                //disable updating nodes until we are done
                gotnode.mycanvas.blockconnupdates = true;
                ModViz3DNode newone;
                //add on cnavas
                if (gotnode.acceptschilds() == false || PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    Point3D p = gotnode.myposition;
                    //p.Offset(-PUPPIGUISettings.nodeSide-PUPPIGUISettings.nodeSpacing,0,0   );
                    newone = new ModViz3DNode(Visual3DExtensions.makedefaultbox(p), gotnode.mycanvas);
                    //force update
                    //newone.replacebox(newone.boundingBox);  
                }
                else
                {
                    newone = gotnode.addontopof(gotnode, null);

                }
                //newone.fitroots(newone.mycanvas.stacks   );  
                //get class name (subclass of PUPPImodule)



                object pm1 = new PUPPIModel.PUPPIPremadeModules.DataInputModules.PUPPINumber();
                //but we need to also keep the changed caption

                newone.setlogic(pm1 as PUPPIModule);
                gotnode.mycanvas.stacks.Add(newone.nodeGUID.ToString(), newone);
                if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    gotnode.fitroots(gotnode.mycanvas.stacks);
                }
                else
                {
                    gotnode.getroot().fitroots(gotnode.mycanvas.stacks);
                }


                //also make sure to add unique node

                //have the user enter data
                setlistlevelform sella = new setlistlevelform(newone.list_level, newone.logical_representation.inputs.Count == 0, newone.logical_representation.countListMode);
                sella.ShowDialog();
                newone.setlistlevel(sella.lstlevel, sella.numelem);
                newone.update_inouts();
                newone.logical_representation.doubleclickme(0, 0, 0);


                //now connect the number node
                PUPPIModel.PUPPIInParameter pinp = new PUPPIInParameter();
                bool successfulconn = pinp.getinputfrom(newone.logical_representation, 0);



                bool connected = this.logical_representation.connect_input(pinp, inputindex, true); //.inputs[dinputindex] = pinp;
                //newone.logical_representation.doIprocess();
                newone.logical_representation.userdoIprocess();
                //this.logical_representation.doIprocess();
                //this.update_inouts();

                string cnf = "conn_" + pinp.module.GUID.ToString() + "_" + pinp.outParIndex.ToString() + "_" + this.logical_representation.GUID.ToString() + "_" + inputindex.ToString();
                ModViz3DConn newconnenctor = new ModViz3DConn(newone, pinp.outParIndex, this, inputindex, cnf);
                gotnode.mycanvas.blockconnupdates = false;
                //calls refresh on connectors
                gotnode.mycanvas.update_all_connectors();

                if (PUPPIGUISettings.useMultiThreading)
                    newconnenctor.drawmethread();
                else newconnenctor.drawme();
                //if this has been deleted by a disconenct then the key is still in the dictionary
                if (gotnode.mycanvas.connpaths.ContainsKey(newconnenctor.visualGUID) == true)
                {
                    gotnode.mycanvas.connpaths[newconnenctor.visualGUID] = newconnenctor;
                }
                else
                {
                    gotnode.mycanvas.connpaths.Add(newconnenctor.visualGUID, newconnenctor);
                }
                this.vizinputs[inputindex].myconnector = newconnenctor;
                this.vizinputs[inputindex].myinput = pinp;



                ////in 2d mode something screwy
                //if (PUPPIGUISettings.canvasMode==PUPPIGUISettings.CanvasModeEnum.TwoDimensional     )
                //{
                //    gotnode.movestack(PUPPIGUISettings.nodeSpacing  , 0); 
                //}
                //if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                //{
                //    newone.fitroots(newone.mycanvas.stacks);  
                //}
                update_inouts();
            }

            //creates a  module and connects it to the input
            internal void setinputvaluefrommodule(int inputindex, PUPPIModule pm, int oi)
            {
                //for now only works in 3d
                //if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional) return;

                ModViz3DNode gotnode = this;
                //we add on top of the stack    
                if (acceptschilds() == false)
                {
                    gotnode = getrectopchild();
                }


                //disable updating nodes until we are done
                gotnode.mycanvas.blockconnupdates = true;
                ModViz3DNode newone;
                //add on cnavas
                if (gotnode.acceptschilds() == false || PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    Point3D p = gotnode.myposition;
                    //p.Offset(-PUPPIGUISettings.nodeSide-PUPPIGUISettings.nodeSpacing,0,0   );
                    newone = new ModViz3DNode(Visual3DExtensions.makedefaultbox(p), gotnode.mycanvas);
                    //force update
                    //newone.replacebox(newone.boundingBox);  
                }
                else
                {
                    newone = gotnode.addontopof(gotnode, null);

                }
                //newone.fitroots(newone.mycanvas.stacks   );  
                //get class name (subclass of PUPPImodule)



                object pm1 = PUPPIModel.AutomaticPUPPImodulesCreator.instantiatePUPPIModule(pm.GetType());
                (pm1 as PUPPIModule).cleancap = pm.cleancap;

                //but we need to also keep the changed caption

                newone.setlogic(pm1 as PUPPIModule);
                gotnode.mycanvas.stacks.Add(newone.nodeGUID.ToString(), newone);
                if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    gotnode.fitroots(gotnode.mycanvas.stacks);
                }
                else
                {
                    gotnode.getroot().fitroots(gotnode.mycanvas.stacks);
                }


                //now connect the node
                PUPPIModel.PUPPIInParameter pinp = new PUPPIInParameter();
                bool successfulconn = pinp.getinputfrom(newone.logical_representation, oi);



                bool connected = this.logical_representation.connect_input(pinp, inputindex, true); //.inputs[dinputindex] = pinp;
                //newone.logical_representation.doIprocess();
                newone.logical_representation.userdoIprocess();
                //this.logical_representation.doIprocess();
                //this.update_inouts();

                string cnf = "conn_" + pinp.module.GUID.ToString() + "_" + pinp.outParIndex.ToString() + "_" + this.logical_representation.GUID.ToString() + "_" + inputindex.ToString();
                ModViz3DConn newconnenctor = new ModViz3DConn(newone, pinp.outParIndex, this, inputindex, cnf);
                gotnode.mycanvas.blockconnupdates = false;
                //calls refresh on connectors
                gotnode.mycanvas.update_all_connectors();

                if (PUPPIGUISettings.useMultiThreading)
                    newconnenctor.drawmethread();
                else newconnenctor.drawme();
                //if this has been deleted by a disconenct then the key is still in the dictionary
                if (gotnode.mycanvas.connpaths.ContainsKey(newconnenctor.visualGUID) == true)
                {
                    gotnode.mycanvas.connpaths[newconnenctor.visualGUID] = newconnenctor;
                }
                else
                {
                    gotnode.mycanvas.connpaths.Add(newconnenctor.visualGUID, newconnenctor);
                }
                this.vizinputs[inputindex].myconnector = newconnenctor;
                this.vizinputs[inputindex].myinput = pinp;


                update_inouts();
            }

            //creates a  module and connects it to the output
            internal void setoutputvaluefrommodule(int outputindex, PUPPIModule pm, int ii)
            {
                //for now only works in 3d
                //if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional) return;

                ModViz3DNode gotnode = this;
                //we add on top of the stack    
                if (acceptschilds() == false)
                {
                    gotnode = getrectopchild();
                }


                //disable updating nodes until we are done
                gotnode.mycanvas.blockconnupdates = true;
                ModViz3DNode newone;
                //add on cnavas
                if (gotnode.acceptschilds() == false || PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    Point3D p = gotnode.myposition;
                    //p.Offset(-PUPPIGUISettings.nodeSide-PUPPIGUISettings.nodeSpacing,0,0   );
                    newone = new ModViz3DNode(Visual3DExtensions.makedefaultbox(p), gotnode.mycanvas);
                    //force update
                    //newone.replacebox(newone.boundingBox);  
                }
                else
                {
                    newone = gotnode.addontopof(gotnode, null);

                }
                //newone.fitroots(newone.mycanvas.stacks   );  
                //get class name (subclass of PUPPImodule)



                object pm1 = PUPPIModel.AutomaticPUPPImodulesCreator.instantiatePUPPIModule(pm.GetType());
                (pm1 as PUPPIModule).cleancap = pm.cleancap;

                //but we need to also keep the changed caption

                newone.setlogic(pm1 as PUPPIModule);
                gotnode.mycanvas.stacks.Add(newone.nodeGUID.ToString(), newone);
                if (PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    gotnode.fitroots(gotnode.mycanvas.stacks);
                }
                else
                {
                    gotnode.getroot().fitroots(gotnode.mycanvas.stacks);
                }


                //now connect the node
                PUPPIModel.PUPPIInParameter pinp = new PUPPIInParameter();
                bool successfulconn = pinp.getinputfrom(gotnode.logical_representation, outputindex);



                bool connected = newone.logical_representation.connect_input(pinp, ii, true); //.outputs[doutputindex] = pinp;
                //newone.logical_representation.doIprocess();

                gotnode.logical_representation.userdoIprocess();
                //this.logical_representation.doIprocess();
                //this.update_inouts();

                string cnf = "conn_" + pinp.module.GUID.ToString() + "_" + pinp.outParIndex.ToString() + "_" + newone.logical_representation.GUID.ToString() + "_" + ii.ToString();
                ModViz3DConn newconnenctor = new ModViz3DConn(this, pinp.outParIndex, newone, ii, cnf);
                gotnode.mycanvas.blockconnupdates = false;
                //calls refresh on connectors
                gotnode.mycanvas.update_all_connectors();

                if (PUPPIGUISettings.useMultiThreading)
                    newconnenctor.drawmethread();
                else newconnenctor.drawme();
                //if this has been deleted by a disconenct then the key is still in the dictionary
                if (gotnode.mycanvas.connpaths.ContainsKey(newconnenctor.visualGUID) == true)
                {
                    gotnode.mycanvas.connpaths[newconnenctor.visualGUID] = newconnenctor;
                }
                else
                {
                    gotnode.mycanvas.connpaths.Add(newconnenctor.visualGUID, newconnenctor);
                }
                newone.vizinputs[ii].myconnector = newconnenctor;
                newone.vizinputs[ii].myinput = pinp;


                newone.update_inouts();
            }


            //sets the list level
            internal void setlistlevel(int llevel, int numberelems = 0)
            {

                //try
                //{
                //we only wanna do it for  nodes where we use default pre-processing
                if (this.logical_representation.completeProcessOverride == false)
                {
                    this.list_level = llevel;
                    this.logical_representation.listprocess = Convert.ToBoolean(llevel);
                    //set the number of list elements to 0 if no list
                    if (llevel == 0) this.logical_representation.countListMode = 0;
                    else this.logical_representation.countListMode = numberelems;
                    //this.logical_representation.doIprocess();
                    this.logical_representation.userdoIprocess();
                }
                //}
                //catch
                //{

                //}
            }
            //sets the list level for the entire stack
            internal void setstacklistlevel(int llevel, int numberelems = 0)
            {
                this.setlistlevel(llevel, numberelems);
                for (int ssl = 0; ssl < childs.Count; ssl++)
                //foreach (ModViz3DNode ch in this.childs )
                {
                    childs[ssl].setstacklistlevel(llevel, numberelems);
                }
            }
            internal ModViz3DNode(ModelVisual3D mod3d)
            {
                vizinputs = new List<ModViz3DInput>();
                vizoutputs = new List<ModViz3DOutput>();
                childs = new List<ModViz3DNode>();
                boundingBox = mod3d.Content.Bounds;
                myposition = boundingBox.rectcenter();
                myself = mod3d;
                parent = null;
                nodeGUID = GUIDcount;
                myself.SetName(nodeGUID.ToString());
                hiddenOnLockedCanvas = false;
                GUIDcount++;
                creationTime = DateTime.Now;

            }
            internal ModViz3DNode addmodelchild(ModelVisual3D chi)
            {
                ModViz3DNode nechild = new ModViz3DNode(chi);
                nechild.mycanvas = mycanvas;
                nechild.parent = this;

                //change to add in the beginning to keep consistent
                //3-13-14
                childs.Insert(0, nechild);
                //childs.Add(nechild);
                return nechild;
            }
            internal void addnodechild(ModViz3DNode chi)
            {
                chi.parent = this;

                //change to add in the beginning to keep consistent
                //3-13-14
                childs.Insert(0, chi);
                //chi.mycanvas = mycanvas; 
                //childs.Add(chi);
            }
            //gets the rootnode
            internal ModViz3DNode getroot()
            {
                if (parent == null)
                {
                    return this;
                }
                else
                {
                    return this.parent.getroot();
                }
            }
            //gets the parent right above root 
            internal ModViz3DNode getparentaboveroot()
            {

                if (parent == null)
                {
                    return null;
                }
                else if (parent.parent == null)
                {
                    return this;
                }
                else
                {
                    return parent.getparentaboveroot();
                }


            }

            //from all levels
            internal ArrayList getallvisuals()
            {
                ArrayList Allofthem = new ArrayList();
                Allofthem.Add(myself);
                foreach (ModViz3DNode mvnode in childs)
                {
                    Allofthem.AddRange(mvnode.getallvisuals());
                }
                return Allofthem;
            }
            //all the children-visuals only but not the children's children
            internal List<ModelVisual3D> getallvisualsnextlevel()
            {
                //try
                //{
                List<ModelVisual3D> ar = new List<ModelVisual3D>();
                foreach (ModViz3DNode mvc in childs)
                {
                    ar.Add(mvc.myself);

                }
                return ar;
                //}
                //catch
                //{
                //    throw new Exception("Failed to get visuals on next level");
                //}
            }
            //returns all the branches on level
            internal List<ModViz3DNode> getallnodesnextlevel()
            {
                List<ModViz3DNode> ar = new List<ModViz3DNode>();
                //foreach (ModViz3DNode mvc in childs)
                //{
                //    ar.Add(mvc);

                //}
                ar.AddRange(childs.ToList());
                return ar;
            }

            //takes the branch represented by a ModelVisual3D out and puts it out as a new tree
            internal ModViz3DNode splitstack(ModelVisual3D splitrootvisual, out bool found)
            {

                if (splitrootvisual == myself)
                {
                    found = true;
                    return this;
                }

                found = false;
                ModViz3DNode newstack = null;
                foreach (ModViz3DNode child in getallnodesnextlevel())
                {
                    newstack = child.splitstack(splitrootvisual, out found);
                    if (found == true)
                    {

                        childs.Remove(newstack);

                        break;
                    }
                }


                return newstack;
            }

            internal void splitmynodestack()
            {
                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log("Splitting stack " + nodeGUID.ToString());
                }
                if (parent == null) return;

                //clears selection
                mycanvas.selstacks.Clear();
                //check how many levels up we are
                int myl = 0;
                ModViz3DNode mp = parent;
                while (mp != null)
                {
                    myl++;
                    mp = mp.parent;
                }

                parent.childs.Remove(this);
                mp = parent;
                parent = null;





                //disconnect all the children and connect them to the parent
                List<ModViz3DNode> toupdatepyr = new List<ModViz3DNode>();


                descend_stack(myl);

                if (mp.gettopchildren().Count > 0)
                {
                    mp.bottompyramid(mp.gettopchildren()[0]);
                }
                else
                {
                    mp.bottompyramid(mp);
                }

                if (gettopchildren().Count > 0)
                {
                    bottompyramid(gettopchildren()[0]);
                }
                else
                {
                    bottompyramid(this);
                }

                //refit roots 
                fitroots(mycanvas.stacks);
                mycanvas.removemanipulator();

                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log("Finshed splitting stack " + nodeGUID.ToString());
                }

            }

            //returns the branch starting with the given visual
            internal ModViz3DNode returnbranch(ModelVisual3D rootvisual, out bool found)
            {

                if (rootvisual == myself)
                {
                    found = true;
                    return this;
                }
                found = false;
                ModViz3DNode newstack = null;
                foreach (ModViz3DNode child in getallnodesnextlevel())
                {
                    newstack = child.returnbranch(rootvisual, out found);
                    if (found == true)
                    {


                        break;
                    }
                }


                return newstack;
            }
            //return if it has changed, by moving or box size
            internal bool movestack(double xoffset, double yoffset, bool forceUpdate = false)
            {
                bool hasc = false;
                //xoffset = xoffset.nodespaceconvert();
                //yoffset = yoffset.nodespaceconvert();   
                //try
                //{
                myview = mycanvas.hv;
                Rect3D thisbox = boundingBox;
                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log("Started moving " + nodeGUID.ToString() + " from " + boundingBox.ToString() + " X offset " + xoffset.ToString() + " Y offset " + yoffset.ToString());
                }
                Rect3D newbox = new Rect3D();
                //try
                //{
                newbox = new Rect3D(thisbox.Location.X + xoffset.nodespaceconvert(), thisbox.Location.Y + yoffset.nodespaceconvert(), thisbox.Location.Z, thisbox.SizeX, thisbox.SizeY, thisbox.SizeZ);

                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log("New boundary supposed to be " + newbox.ToString());
                }

                //}
                //catch
                //{
                //    newbox = new Rect3D();  
                //}
                //if (newbox.IsEmpty || Double.IsNaN(thisbox.Location.X) || Double.IsNaN(thisbox.Location.Y) || Double.IsNaN(thisbox.Location.Z) || Double.IsNaN(thisbox.SizeX) || Double.IsNaN(thisbox.SizeY) || Double.IsNaN(thisbox.SizeZ))
                //{

                //    newbox= new Rect3D(xoffset.nodespaceconvert(),yoffset.nodespaceconvert(), thisbox.Location.Z, PUPPIGUISettings.nodeSide ,PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeHeight); 
                //}

                //Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);

                if (!thisbox.Equals(newbox)) hasc = true;
                ModelVisual3D newme = null;
                if (hasc || forceUpdate)
                    newme = replacebox(newbox);

                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log("Finished moving node. " + nodeGUID.ToString() + " New boundary is " + boundingBox.ToString());
                }

                //if (thisbox != boundingBox)
                //{
                //    hasc = true;
                //}
                //try parallel 4
                // Parallel.For(0, childs.Count, chc =>

                if (xoffset != 0 || yoffset != 0)
                {
                    hasc = true;
                    for (int chc = 0; chc < childs.Count; chc++)
                    {


                        if (childs[chc].myself != null)
                        {
                            childs[chc].movestack(xoffset, yoffset);
                        }
                    }
                }//);
                //}
                //catch
                //{
                //    throw new Exception("Failed to move node stack");
                //}
                //for custom renderers, if it was rebuilt
                // if (thisbox.Equals(boundingBox) == false) hasc = true;
                return hasc;
            }
            //adds to the stack on a certain node
            //works with both existing ModViz3DNodes and new nodes
            internal ModViz3DNode addontopof(ModViz3DNode baseon, ModViz3DNode nodexists = null)
            {

                //will disable caption and inout updates
                PUPPIruntimesettings.currentstate = PUPPIruntimesettings.graphicalnodeupdatestates.IsNotReady;
                ModelVisual3D newbox;

                myview = mycanvas.hv;
                //bool foundit = false;

                ModViz3DNode branchbase = baseon;

                //figure out where to add
                d2collisionmodel levelredo = new d2collisionmodel();

                //try with extra sizes

                int edgespacemult = 1;
                int i = 0;
                double divspace = 1.0 / (double)PUPPIGUISettings.maxConnPerSpace;
                //only do this if on bottom base
                if (branchbase.parent == null)
                {

                    for (i = 0; i < branchbase.childs.Count; i++)
                    {
                        ModViz3DNode myelement = branchbase.childs[i] as ModViz3DNode;
                        if (myelement != null)
                        {
                            if (myelement.myself != null)
                            {
                                edgespacemult = Convert.ToInt16((myelement.numconn + Math.Max(Math.Max(myelement.vizinputs.Count, myelement.vizoutputs.Count), myelement.number_outbound_connections) * divspace));
                                if (edgespacemult == 0) edgespacemult = 1;
                                levelredo.footprints.Add(myelement.boundingBox.padme(edgespacemult * PUPPIGUISettings.nodeSpacing));
                            }
                        }

                    }

                }
                levelredo.region_perimeter = branchbase.boundingBox;
                Point3D addpoint = new Point3D();



                //check we aqctually have stuff on same add level
                if (levelredo.footprints.Count > 0)
                {
                    //padding here not needed because already taken care of by footprints
                    addpoint = levelredo.wheretoadd(1);//numconn);
                    //make sure it stays centered
                    addpoint.Y = branchbase.boundingBox.rectcenter().Y - PUPPIGUISettings.nodeSide * 0.5;
                }
                else
                {
                    addpoint = branchbase.boundingBox.Location;
                    //make sure it stays centered
                    addpoint.Y = branchbase.boundingBox.rectcenter().Y - PUPPIGUISettings.nodeSide * 0.5;
                }


                //add a new box on top of this level
                //Rect3D addpos = new Rect3D(addontop.Content.Bounds.Location.X, addontop.Content.Bounds.Location.Y, addontop.Content.Bounds.Location.Z + 1, 1, 1, 1);   
                Rect3D addpos = new Rect3D();
                if (nodexists != null && nodexists.logical_representation != null && (nodexists.logical_representation.inputs.Count > 2 || nodexists.logical_representation.outputs.Count > 2))
                {
                    double newy = PUPPIGUISettings.nodeSide;
                    //but that can be too small
                    double ispacing = Math.Min((newy - logical_representation.inputs.Count * PUPPIGUISettings.ioLength) / (logical_representation.inputs.Count + 1), (newy - logical_representation.outputs.Count * PUPPIGUISettings.ioLength) / (logical_representation.outputs.Count + 1));

                    //iheight = boundingBox.SizeY / (logical_representation.inputs.Count + 0.5 * (logical_representation.inputs.Count + 1));
                    if (ispacing < PUPPIGUISettings.ioMinSpacing - PUPPIGUISettings.errF)
                    {
                        newy = Math.Max(nodexists.logical_representation.inputs.Count * (PUPPIGUISettings.ioLength + PUPPIGUISettings.ioMinSpacing) + PUPPIGUISettings.ioMinSpacing + PUPPIGUISettings.errF, nodexists.logical_representation.outputs.Count * (PUPPIGUISettings.ioLength + PUPPIGUISettings.ioMinSpacing) + PUPPIGUISettings.ioMinSpacing + PUPPIGUISettings.errF);
                        double divvy = newy.nodespaceconvert();
                        if (divvy < newy) newy = divvy + PUPPIGUISettings.nodeSpacing;
                        // newy = divvy;
                        //make even numbered for nicer symmetry
                        if (Convert.ToInt16(newy / PUPPIGUISettings.nodeSpacing) % 2 != 0)
                        {
                            newy += PUPPIGUISettings.nodeSpacing;
                        }
                    }
                    //center y
                    addpoint.Y = (branchbase.boundingBox.rectcenter().Y - newy * 0.5).nodespaceconvert();
                    addpos = new Rect3D(addpoint.X, addpoint.Y, branchbase.boundingBox.Location.Z + PUPPIGUISettings.nodeHeight, PUPPIGUISettings.nodeSide, newy, PUPPIGUISettings.nodeHeight).locationnodeSpacing();
                    if (nodexists.nodeUpdatedMaterial == null)
                    {
                        newbox = addbox(addpos, mycanvas.node_default_mat);
                    }
                    else
                    {
                        newbox = addbox(addpos, nodexists.nodeUpdatedMaterial);
                    }
                }
                //    //has renderer
                //else if (nodexists != null && nodexists.logical_representation != null && nodexists.nodeCustomRenderer!=null  )
                //{
                //   nodexists.useRenderer();  
                //   addpoint.Y=branchbase.boundingBox.rectcenter().Y.nodespaceconvert();

                //    addpos=new Rect3D  
                //}
                else
                {
                    addpos = new Rect3D(addpoint.X, addpoint.Y, branchbase.boundingBox.Location.Z + PUPPIGUISettings.nodeHeight, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeHeight).locationnodeSpacing();
                    newbox = addbox(addpos, mycanvas.node_default_mat);
                }


                ModViz3DNode newnode = null;
                if (nodexists == null)
                {
                    newnode = branchbase.addmodelchild(newbox);
                }
                else
                {

                    if (nodeCustomRenderer != null && nodeCustomRenderer.use3D)
                    {
                        mycanvas.hv.Children.Remove(newbox);
                        double smallBoxSize = PUPPIGUISettings.nodeSide * 0.01;
                        nodexists.useRenderer();
                        ModelVisual3D replacer = new ModelVisual3D();
                        nodeCustomRenderer.model3D.SetName(myself.GetName());
                        Vector3D tranv = Point3D.Subtract(addpos.rectcenter(), new Point3D(0, 0, 0));//nodeCustomRenderer.bbox.rectcenter());
                        replacer = nodeCustomRenderer.model3D.moveVisualChildren(tranv, addpos.rectcenter().makeSizeBox(smallBoxSize, smallBoxSize, smallBoxSize), mycanvas.customRenderBox_default_mat);
                        //replacer = nodeCustomRenderer.model2D.moveVisualChildren(tranv);
                        if (!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas)
                            myview.Children[myview.Children.IndexOf(nodexists.myself)] = replacer;
                        nodexists.myself = replacer;
                        //make sure the bounding box scales accordingly in x and y
                        Rect3D cBB = Rect3D.Offset(nodeCustomRenderer.bbox, tranv);
                        cBB.Z = addpos.Z;
                        cBB.SizeZ = addpos.SizeZ;
                        nodeCustomRenderer.displacedBbox = cBB;
                        cBB.Union(addpos);
                        addpos = cBB.locationnodeSpacing();
                        newnode = nodexists;

                    }
                    else
                    {
                        newnode = nodexists;
                        newnode.myself = newbox;
                    }

                }

                newnode.boundingBox = addpos;
                newnode.myposition = newnode.boundingBox.rectcenter();
                //base childs index
                newnode.baseindex = branchbase.childs.Count - 1;
                edgespacemult = Convert.ToInt16(Math.Max(newnode.vizinputs.Count, newnode.vizoutputs.Count) * divspace);
                if (edgespacemult == 0) edgespacemult = 1;

                levelredo = new d2collisionmodel();
                Rect3D newbp = branchbase.boundingBox;
                if (branchbase.parent == null)
                {
                    //when multiple childs
                    if (branchbase.childs.Count > 1)
                    {

                        //if node exists we need to put it at the beginnning
                        if (nodexists != null)
                        {
                            branchbase.childs.Remove(newnode);
                            branchbase.childs.Insert(0, newnode);
                        }

                        for (i = 0; i < branchbase.childs.Count; i++)
                        {
                            ModViz3DNode myelement = branchbase.childs[i] as ModViz3DNode;
                            if (myelement != null)
                            {
                                if (myelement.myself != null)
                                {
                                    if (myelement != newnode)
                                    {
                                        edgespacemult = Convert.ToInt16((myelement.numconn + Math.Max(Math.Max(myelement.vizinputs.Count, myelement.vizoutputs.Count), myelement.number_outbound_connections)) * divspace);
                                        if (edgespacemult == 0) edgespacemult = 1;
                                        levelredo.footprints.Add(myelement.boundingBox.padme(edgespacemult * PUPPIGUISettings.nodeSpacing));
                                    }
                                }
                            }

                        }


                        levelredo.footprints.Insert(0, newnode.boundingBox.padme(edgespacemult * PUPPIGUISettings.nodeSpacing));

                        //try with regular for so that maybe it doesn't crash


                        for (i = 0; i < branchbase.childs.Count; i++)
                        {
                            ModViz3DNode curbranch = branchbase.childs[i] as ModViz3DNode;
                            if (curbranch != null)
                            {
                                if (curbranch.myself != null)
                                {
                                    curbranch.movestack(d2collisionmodel.getrectcenter(levelredo.footprints[i]).X - d2collisionmodel.getrectcenter(curbranch.boundingBox).X, d2collisionmodel.getrectcenter(levelredo.footprints[i]).Y - d2collisionmodel.getrectcenter(curbranch.boundingBox).Y);

                                }
                            }

                        }





                        levelredo.recalculate_perimeter();
                        //padding already added 3-13-14
                        newbp = new Rect3D(levelredo.region_perimeter.Location.X, levelredo.region_perimeter.Location.Y, branchbase.boundingBox.Location.Z, levelredo.region_perimeter.SizeX, levelredo.region_perimeter.SizeY, branchbase.boundingBox.SizeZ).locationnodeSpacing();
                    }
                    //added right above base, and only one
                    else
                    {
                        if (nodexists != null)
                        {
                            edgespacemult = Convert.ToInt16((newnode.numconn + Math.Max(Math.Max(newnode.vizinputs.Count, newnode.vizoutputs.Count), newnode.number_outbound_connections)) * divspace);
                            if (edgespacemult == 0) edgespacemult = 1;
                        }
                        else
                        {
                            edgespacemult = 1;
                        }
                        //center it
                        //biggest between default section, top base+input/output widths and based on number of connectors.
                        double maxsizex = 0;
                        double maxsizey = 0;


                        maxsizex = Math.Max(addpos.SizeX + edgespacemult * 2 * PUPPIGUISettings.nodeSpacing, branchbase.boundingBox.SizeX);
                        maxsizey = Math.Max(addpos.SizeY + edgespacemult * 2 * PUPPIGUISettings.nodeSpacing, branchbase.boundingBox.SizeY);
                        if (maxsizex <= 0) maxsizex = PUPPIGUISettings.nodeSide;
                        if (maxsizey <= 0) maxsizey = PUPPIGUISettings.nodeSide;

                        //center it

                        newbp = new Rect3D(addpos.rectcenter().X - maxsizex * 0.5, addpos.rectcenter().Y - maxsizey * 0.5, newbp.Location.Z, maxsizex, maxsizey, newbp.SizeZ).locationnodeSpacing();
                        //temporary patch, if no spacing, move down
                        //  if (newbp.Location.Y > newbox.Content.Bounds.Location.Y - PUPPIGUISettings.nodeSpacing) newbp.Offset(0, -PUPPIGUISettings.nodeSpacing, 0);
                    }
                }
                else
                {
                    //center it
                    //biggest between default section, top base+input/output widths and based on number of connectors.
                    double maxsizex = 0;
                    double maxsizey = 0;


                    maxsizex = Math.Max(Math.Max(addpos.SizeX, branchbase.boundingBox.SizeX), edgespacemult * PUPPIGUISettings.nodeSpacing);
                    maxsizey = Math.Max(addpos.SizeY, branchbase.boundingBox.SizeY);
                    if (maxsizex <= 0) maxsizex = PUPPIGUISettings.nodeSide;
                    if (maxsizey <= 0) maxsizey = PUPPIGUISettings.nodeSide;

                    //center it

                    newbp = new Rect3D(addpos.rectcenter().X - maxsizex * 0.5, addpos.rectcenter().Y - maxsizey * 0.5, newbp.Location.Z, maxsizex, maxsizey, newbp.SizeZ).locationnodeSpacing();


                }

                branchbase.replacebox(newbp);
                if (nodexists == null)
                {
                    branchbase.bottompyramid(branchbase);
                }
                else
                {
                    //only do bottom if no children
                    if (nodexists.childs.Count == 0)
                    {
                        branchbase.bottompyramid(nodexists);
                    }
                }

                //reset to perform updates and update nodes
                PUPPIruntimesettings.currentstate = PUPPIruntimesettings.graphicalnodeupdatestates.DoUpdate;
                for (int nu = 0; nu < mycanvas.nodestoupdate.Count; nu++)
                {
                    mycanvas.nodestoupdate[nu].update_caption();
                    mycanvas.nodestoupdate[nu].update_inouts();
                }
                mycanvas.nodestoupdate.Clear();
                return newnode;

            }

            //internal void moveontopof(ModViz3DNode tom)
            //{

            //    //will disable caption and inout updates
            //    PUPPIruntimesettings.currentstate = PUPPIruntimesettings.graphicalnodeupdatestates.IsNotReady;
            //    ModelVisual3D newbox;

            //    myview = mycanvas.hv;
            //    //bool foundit = false;

            //    ModViz3DNode branchbase = this;

            //    //figure out where to add
            //    d2collisionmodel levelredo = new d2collisionmodel();

            //    //try with extra sizes

            //    int edgespacemult = 1;
            //    int i = 0;
            //    double divspace = 1.0 / (double)PUPPIGUISettings.maxConnPerSpace;
            //    //only do this if on bottom base
            //    if (branchbase.parent == null)
            //    {

            //        for (i = 0; i < branchbase.childs.Count; i++)
            //        {
            //            ModViz3DNode myelement = branchbase.childs[i] as ModViz3DNode;
            //            if (myelement != null)
            //            {
            //                if (myelement.myself != null)
            //                {
            //                    edgespacemult = Convert.ToInt16((myelement.numconn + Math.Max(Math.Max(myelement.vizinputs.Count, myelement.vizoutputs.Count), myelement.number_outbound_connections) * divspace));
            //                    if (edgespacemult == 0) edgespacemult = 1;
            //                    levelredo.footprints.Add(myelement.boundingBox.padme(edgespacemult * PUPPIGUISettings.nodeSpacing));
            //                }
            //            }

            //        }

            //    }
            //    levelredo.region_perimeter = branchbase.boundingBox;
            //    Point3D addpoint = new Point3D();



            //    //check we aqctually have stuff on same add level
            //    if (levelredo.footprints.Count > 0)
            //    {
            //        //padding here not needed because already taken care of by footprints
            //        addpoint = levelredo.wheretoadd(1);//numconn);
            //        //make sure it stays centered
            //        addpoint.Y = branchbase.boundingBox.rectcenter().Y - PUPPIGUISettings.nodeSide * 0.5;
            //    }
            //    else
            //    {
            //        addpoint = branchbase.boundingBox.Location;
            //        //make sure it stays centered
            //        addpoint.Y = branchbase.boundingBox.rectcenter().Y - PUPPIGUISettings.nodeSide * 0.5;
            //    }

            //   //replace box here


            //    //base childs index
            //    tom.baseindex = branchbase.childs.Count - 1;
            //    edgespacemult = Convert.ToInt16(Math.Max(tom.vizinputs.Count, tom.vizoutputs.Count) * divspace);
            //    if (edgespacemult == 0) edgespacemult = 1;

            //    levelredo = new d2collisionmodel();
            //    Rect3D newbp = branchbase.boundingBox;
            //    if (branchbase.parent == null)
            //    {
            //        //when multiple childs
            //        if (branchbase.childs.Count > 1)
            //        {


            //                branchbase.childs.Remove(tom);
            //                branchbase.childs.Insert(0, tom);

            //            for (i = 0; i < branchbase.childs.Count; i++)
            //            {
            //                ModViz3DNode myelement = branchbase.childs[i] as ModViz3DNode;
            //                if (myelement != null)
            //                {
            //                    if (myelement.myself != null)
            //                    {
            //                        if (myelement != tom)
            //                        {
            //                            edgespacemult = Convert.ToInt16((myelement.numconn + Math.Max(Math.Max(myelement.vizinputs.Count, myelement.vizoutputs.Count), myelement.number_outbound_connections)) * divspace);
            //                            if (edgespacemult == 0) edgespacemult = 1;
            //                            levelredo.footprints.Add(myelement.boundingBox.padme(edgespacemult * PUPPIGUISettings.nodeSpacing));
            //                        }
            //                    }
            //                }

            //            }


            //            levelredo.footprints.Insert(0, tom.boundingBox.padme(edgespacemult * PUPPIGUISettings.nodeSpacing));

            //            //try with regular for so that maybe it doesn't crash


            //            for (i = 0; i < branchbase.childs.Count; i++)
            //            {
            //                ModViz3DNode curbranch = branchbase.childs[i] as ModViz3DNode;
            //                if (curbranch != null)
            //                {
            //                    if (curbranch.myself != null)
            //                    {
            //                        curbranch.movestack(d2collisionmodel.getrectcenter(levelredo.footprints[i]).X - d2collisionmodel.getrectcenter(curbranch.boundingBox).X, d2collisionmodel.getrectcenter(levelredo.footprints[i]).Y - d2collisionmodel.getrectcenter(curbranch.boundingBox).Y);

            //                    }
            //                }

            //            }





            //            levelredo.recalculate_perimeter();
            //            //padding already added 3-13-14
            //            newbp = new Rect3D(levelredo.region_perimeter.Location.X, levelredo.region_perimeter.Location.Y, branchbase.boundingBox.Location.Z, levelredo.region_perimeter.SizeX, levelredo.region_perimeter.SizeY, branchbase.boundingBox.SizeZ).locationnodeSpacing();
            //        }
            //        //added right above base, and only one
            //        else
            //        {

            //                edgespacemult = Convert.ToInt16((tom.numconn + Math.Max(Math.Max(tom.vizinputs.Count, tom.vizoutputs.Count), tom.number_outbound_connections)) * divspace);
            //                if (edgespacemult == 0) edgespacemult = 1;

            //            //center it
            //            //biggest between default section, top base+input/output widths and based on number of connectors.
            //            double maxsizex = 0;
            //            double maxsizey = 0;


            //            maxsizex = Math.Max(addpos.SizeX + edgespacemult * 2 * PUPPIGUISettings.nodeSpacing, branchbase.boundingBox.SizeX);
            //            maxsizey = Math.Max(addpos.SizeY + edgespacemult * 2 * PUPPIGUISettings.nodeSpacing, branchbase.boundingBox.SizeY);
            //            if (maxsizex <= 0) maxsizex = PUPPIGUISettings.nodeSide;
            //            if (maxsizey <= 0) maxsizey = PUPPIGUISettings.nodeSide;

            //            //center it

            //            newbp = new Rect3D(addpos.rectcenter().X - maxsizex * 0.5, addpos.rectcenter().Y - maxsizey * 0.5, newbp.Location.Z, maxsizex, maxsizey, newbp.SizeZ).locationnodeSpacing();
            //            //temporary patch, if no spacing, move down
            //            //  if (newbp.Location.Y > newbox.Content.Bounds.Location.Y - PUPPIGUISettings.nodeSpacing) newbp.Offset(0, -PUPPIGUISettings.nodeSpacing, 0);
            //        }
            //    }
            //    else
            //    {
            //        //center it
            //        //biggest between default section, top base+input/output widths and based on number of connectors.
            //        double maxsizex = 0;
            //        double maxsizey = 0;


            //        maxsizex = Math.Max(Math.Max(addpos.SizeX, branchbase.boundingBox.SizeX), edgespacemult * PUPPIGUISettings.nodeSpacing);
            //        maxsizey = Math.Max(addpos.SizeY, branchbase.boundingBox.SizeY);
            //        if (maxsizex <= 0) maxsizex = PUPPIGUISettings.nodeSide;
            //        if (maxsizey <= 0) maxsizey = PUPPIGUISettings.nodeSide;

            //        //center it

            //        newbp = new Rect3D(addpos.rectcenter().X - maxsizex * 0.5, addpos.rectcenter().Y - maxsizey * 0.5, newbp.Location.Z, maxsizex, maxsizey, newbp.SizeZ).locationnodeSpacing();


            //    }

            //    branchbase.replacebox(newbp);

            //        //only do bottom if no children
            //        if (tom.childs.Count == 0)
            //        {
            //            branchbase.bottompyramid(tom);
            //        }


            //    //reset to perform updates and update nodes
            //    PUPPIruntimesettings.currentstate = PUPPIruntimesettings.graphicalnodeupdatestates.DoUpdate;
            //    for (int nu = 0; nu < mycanvas.nodestoupdate.Count; nu++)
            //    {
            //        mycanvas.nodestoupdate[nu].update_caption();
            //        mycanvas.nodestoupdate[nu].update_inouts();
            //    }
            //    mycanvas.nodestoupdate.Clear();


            //}

            //  rescales and displaces all items as needed moving down from the node specified
            internal void bottompyramid(ModViz3DNode topchanged)
            {
                try
                {
                    int i = 0;
                    if (topchanged.parent == null)
                    {
                        return;
                    }
                    //mycanvas.levelchange++;  
                    double divspace = 1.0 / (double)PUPPIGUISettings.maxConnPerSpace;
                    ModViz3DNode branchbase = topchanged.parent;
                    //get all the connectors,including the children's connectors
                    branchbase.numconn = 0;
                    for (int bi = 0; bi < branchbase.childs.Count; bi++)
                    //foreach (ModViz3DNode chinode in branchbase.childs)
                    {
                        branchbase.numconn += branchbase.childs[bi].numconn + Math.Max(Math.Max(branchbase.childs[bi].vizinputs.Count, branchbase.childs[bi].vizoutputs.Count), branchbase.number_outbound_connections);
                    }



                    d2collisionmodel levelredo = new d2collisionmodel();
                    int edgespacemult = 1;
                    //default
                    Rect3D newbp = branchbase.boundingBox;
                    if (branchbase.parent == null)
                    {

                        if (branchbase.childs.Count > 1)
                        {
                            ////reorder. the current top needs to be the first
                            //foreach (ModViz3DNode myelement in branchbase.childs)
                            //{
                            //    if (myelement == topchanged)
                            //    {
                            //        branchbase.childs.Remove(myelement);
                            //        branchbase.childs.Insert(0, myelement);
                            //        break;

                            //    }

                            //}

                            branchbase.childs.Remove(topchanged);
                            branchbase.childs.Insert(0, topchanged);

                            //try with extra sizes
                            //3-14-14

                            for (i = 0; i < branchbase.childs.Count; i++)
                            {
                                ModViz3DNode myelement = branchbase.childs[i] as ModViz3DNode;
                                if (myelement != null)
                                {
                                    if (myelement.myself != null)
                                    {
                                        edgespacemult = Convert.ToInt16((myelement.numconn + Math.Max(Math.Max(myelement.vizinputs.Count, myelement.vizoutputs.Count), myelement.number_outbound_connections)) * divspace);
                                        if (edgespacemult == 0) edgespacemult = 1;

                                        levelredo.footprints.Add(myelement.boundingBox.padme(edgespacemult * PUPPIGUISettings.nodeSpacing));

                                    }
                                }

                            }

                            //they can only move x direction
                            levelredo.recompute(1);




                            //try parallel
                            //  Parallel.For(0,branchbase.childs.Count,ii=>
                            for (int ii = 0; ii < branchbase.childs.Count; ii++)
                            {
                                ModViz3DNode curbranch = branchbase.childs[ii] as ModViz3DNode;
                                if (curbranch != null)
                                {
                                    if (curbranch.myself != null)
                                    {
                                        curbranch.movestack(d2collisionmodel.getrectcenter(levelredo.footprints[ii]).X - d2collisionmodel.getrectcenter(curbranch.boundingBox).X, d2collisionmodel.getrectcenter(levelredo.footprints[ii]).Y - d2collisionmodel.getrectcenter(curbranch.boundingBox).Y);

                                    }
                                }
                            }//);

                            levelredo.recalculate_perimeter();
                            newbp = new Rect3D(levelredo.region_perimeter.Location.X, levelredo.region_perimeter.Location.Y, branchbase.boundingBox.Location.Z, levelredo.region_perimeter.SizeX, levelredo.region_perimeter.SizeY, branchbase.boundingBox.SizeZ);
                        }//faster and hopefully correct
                        else
                        {

                            edgespacemult = Convert.ToInt16((topchanged.numconn + Math.Max(Math.Max(topchanged.vizinputs.Count, topchanged.vizoutputs.Count), topchanged.number_outbound_connections)) * divspace);
                            if (edgespacemult == 0) edgespacemult = 1;
                            //center it
                            //biggest between default section, top base+input/output widths and based on number of connectors.
                            double maxsizex = 0;
                            double maxsizey = 0;
                            Rect3D addpos = topchanged.boundingBox;

                            maxsizex = Math.Max(addpos.SizeX + edgespacemult * 2 * PUPPIGUISettings.nodeSpacing, branchbase.boundingBox.SizeX);
                            maxsizey = Math.Max(addpos.SizeY + edgespacemult * 2 * PUPPIGUISettings.nodeSpacing, branchbase.boundingBox.SizeY);
                            if (maxsizex <= 0) maxsizex = PUPPIGUISettings.nodeSide;
                            if (maxsizey <= 0) maxsizey = PUPPIGUISettings.nodeSide;

                            //center it

                            newbp = new Rect3D(addpos.rectcenter().X - maxsizex * 0.5, addpos.rectcenter().Y - maxsizey * 0.5, newbp.Location.Z, maxsizex, maxsizey, newbp.SizeZ);

                        }
                    }
                    else
                    {
                        //biggest between default section, top base+input/output widths and based on number of connectors.
                        double maxsizex = 0;
                        double maxsizey = 0;
                        edgespacemult = Convert.ToInt16(branchbase.numconn * divspace);

                        maxsizex = 0;//Math.Max(Math.Max(topchanged.boundingBox.SizeX, branchbase.boundingBox.SizeX), edgespacemult * PUPPIGUISettings.nodeSpacing);
                        maxsizey = Math.Max(topchanged.boundingBox.SizeY, branchbase.boundingBox.SizeY);
                        if (maxsizex <= 0) maxsizex = PUPPIGUISettings.nodeSide;
                        if (maxsizey <= 0) maxsizey = PUPPIGUISettings.nodeSide;


                        newbp = new Rect3D(topchanged.boundingBox.rectcenter().X - maxsizex * 0.5, topchanged.boundingBox.rectcenter().Y - maxsizey * 0.5, newbp.Location.Z, maxsizex, maxsizey, newbp.SizeZ);

                    }
                    branchbase.replacebox(newbp, 2);
                    //   MessageBox.Show(branchbase.logical_representation.name);

                    bottompyramid(branchbase);
                    //  mycanvas.levelchange--;
                }
                catch (Exception exy)
                {
                    if (PUPPIDebugger.debugenabled == true)
                    {
                        PUPPIDebugger.log("branchbase error " + nodeGUID.ToString() + ". error content: " + exy.ToString());
                    }

                }

            }

            //creates new box
            internal ModelVisual3D addbox(Rect3D newbounds, Material bmat, bool addToView = true)
            {
                //discretization
                // Rect3D newbounds = new Rect3D(nbounds.Location, nbounds.Size);
                //  newbounds=newbounds.locationnodeSpacing();
                //try
                //{
                var meshBuilder = new MeshBuilder(false, false);
                Point3D newpos = new Point3D(newbounds.Location.X, newbounds.Location.Y, newbounds.Location.Z);
                newpos.Offset(newbounds.SizeX * 0.5, newbounds.SizeY * 0.5, newbounds.SizeZ * 0.5);


                if (PUPPIGUISettings.roundedCornerRadius == 0)
                {
                    meshBuilder.AddBox(newpos, newbounds.SizeX, newbounds.SizeY, newbounds.SizeZ);
                }
                else
                {


                    Point3D p0 = new Point3D(newpos.X, newpos.Y, newbounds.Z);
                    Point3D p1 = new Point3D(newpos.X, newpos.Y, newbounds.Z + newbounds.SizeZ);

                    // meshBuilder.AddExtrudedGeometry(Visual3DExtensions.makeroundedrect(newbounds.SizeX, newbounds.SizeY, PUPPIGUISettings.roundedCornerRadius * (Math.Min(newbounds.SizeX, newbounds.SizeY))), new Vector3D(1, 0, 0), p0, p1);
                    Visual3DExtensions.makeverticalextrusion(meshBuilder, Visual3DExtensions.makeroundedrect(newbounds.SizeX, newbounds.SizeY, PUPPIGUISettings.roundedCornerRadius * (Math.Min(newbounds.SizeX, newbounds.SizeY))), p0, p1);

                }
                // meshBuilder.AddCubeFace(newpos, new Vector3D(1, 1, 0), new Vector3D(0, 0, 1), newbounds.SizeX * 0.5, newbounds.SizeX, newbounds.SizeZ  );     

                //chamfer mesh
                if (PUPPIGUISettings.chamferCornerDepth > 0)
                {
                    double chaccod = Math.Min(Math.Min(newbounds.SizeX, newbounds.SizeY), newbounds.SizeZ) * PUPPIGUISettings.chamferCornerDepth;
                    meshBuilder.ChamferCorner(newbounds.Location, chaccod);
                    meshBuilder.ChamferCorner(Point3D.Add(newbounds.Location, new Vector3D(newbounds.SizeX, 0, 0)), chaccod);
                    meshBuilder.ChamferCorner(Point3D.Add(newbounds.Location, new Vector3D(0, newbounds.SizeY, 0)), chaccod);
                    meshBuilder.ChamferCorner(Point3D.Add(newbounds.Location, new Vector3D(newbounds.SizeX, newbounds.SizeY, 0)), chaccod);
                    meshBuilder.ChamferCorner(Point3D.Add(newbounds.Location, new Vector3D(newbounds.SizeX, 0, newbounds.SizeZ)), chaccod);
                    meshBuilder.ChamferCorner(Point3D.Add(newbounds.Location, new Vector3D(0, newbounds.SizeY, newbounds.SizeZ)), chaccod);
                    meshBuilder.ChamferCorner(Point3D.Add(newbounds.Location, new Vector3D(newbounds.SizeX, newbounds.SizeY, newbounds.SizeZ)), chaccod);
                    meshBuilder.ChamferCorner(Point3D.Add(newbounds.Location, new Vector3D(0, 0, newbounds.SizeZ)), chaccod);
                }


                var mesh = meshBuilder.ToMesh(true);
                GeometryModel3D newModel = new GeometryModel3D();
                newModel.Geometry = mesh;
                newModel.Material = bmat;// node_default_mat;
                //Model3DGroup modelGroup = new Model3DGroup();
                //modelGroup.Children.Add(cubeModel);
                ModelVisual3D model = new ModelVisual3D();
                model.Content = newModel;

                // this.myoriginalposition = this.myposition; 
                //myself = model;
                //myposition = newModel.Bounds.rectcenter();    
                myview = mycanvas.hv;

                if ((!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas) && addToView)
                    myview.Children.Add(model);
                return model;
                //}
                //catch
                //{
                //    throw new Exception("Failed to add new visual box");
                //}
            }
            //moves the roots 
            //fits them around this
            internal void fitroots(Dictionary<string, ModViz3DNode> allnodes)
            {
                if (mycanvas.blockfitroots == true || isSolid == false || PUPPIGUISettings.nodesCanIntersect)
                {
                    return;
                }

                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log(utils.StringConstants.startedfittingtoots + nodeGUID.ToString());
                }
                //mycanvas.levelchange++;  
                double divsize = 1.0 / (double)PUPPIGUISettings.maxConnPerSpace;
                myview = mycanvas.hv;
                List<ModViz3DNode> allroots = new List<ModViz3DNode>();
                foreach (ModViz3DNode mv in allnodes.Values)
                {

                    if (mv.parent == null && mv.isSolid)
                    {
                        //bool added = false;
                        ////ordered insertion
                        //for (int ii = 0; ii < allroots.Count;ii++ )
                        //{
                        //    Rect3D rb=allroots[ii].boundingBox; 
                        //    if (Math.Sqrt(mv.boundingBox.SizeX*mv.boundingBox.SizeX+mv.boundingBox.SizeY*mv.boundingBox.SizeY )> Math.Sqrt(rb.SizeX*rb.SizeX+rb.SizeY*rb.SizeY ))
                        //    {
                        //        allroots.Insert(ii, mv);
                        //        added = true;
                        //        break;
                        //    }
                        //}
                        //        if (added==false)
                        allroots.Add(mv);
                    }
                }
                if (allroots.Count == 0) return;
                allroots.Remove(this);
                allroots.Insert(0, this);
                int i = 0;
                d2collisionmodel levelredo = new d2collisionmodel();
                //street list
                //List<Rect3D> blvds = new List<Rect3D>();
                Rect3D canvasbbox = mycanvas.bbox();



                for (i = 0; i < allroots.Count; i++)
                {
                    //levelredo.footprints.Add(myelement.boundingBox.padme(Math.Max(PUPPIGUISettings.nodeSpacing * 0.5, myelement.numconn / PUPPIGUISettings.maxConnPerSpace / 2)));
                    //if (allroots[i].boundingBox.SizeX > 4 * PUPPIGUISettings.nodeSide)
                    //{
                    //    levelredo.footprints.Add(allroots[i].boundingBox.padme(Math.Max(PUPPIGUISettings.nodeSpacing, allroots[i].numconn * divsize)).extendx(canvasbbox));

                    //}
                    //else
                    //{
                    if (PUPPIDebugger.debugenabled == true)
                    {
                        PUPPIDebugger.log("To change root " + i + " GUID " + allroots[i].nodeGUID.ToString() + " BB " + allroots[i].boundingBox.ToString());
                    }

                    levelredo.footprints.Add(allroots[i].boundingBox.padme(Math.Max(PUPPIGUISettings.nodeSpacing, allroots[i].numconn * divsize)));
                    //if a bigger node, add a busy corner boulevardf
                    //}
                }
                //get perimeter
                levelredo.recalculate_perimeter();
                levelredo.recompute(0);
                //Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);

                for (i = 1; i < allroots.Count; i++)
                {
                    //ModViz3DNode mv3d = allroots[i];
                    // mv3d.movestack(levelredo.footprints[i].Location.X - mv3d.boundingBox.Location.X, levelredo.footprints[i].Location.Y - mv3d.boundingBox.Location.Y, d3view);



                    allroots[i].movestack(d2collisionmodel.getrectcenter(levelredo.footprints[i]).X - d2collisionmodel.getrectcenter(allroots[i].boundingBox).X, d2collisionmodel.getrectcenter(levelredo.footprints[i]).Y - d2collisionmodel.getrectcenter(allroots[i].boundingBox).Y);
                    //   Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);
                    if (PUPPIDebugger.debugenabled == true)
                    {
                        PUPPIDebugger.log("Changed root " + i + " GUID " + allroots[i].nodeGUID.ToString() + " BB " + allroots[i].boundingBox.ToString());
                    }

                }


                ////extra fit for blvd
                //if (boundingBox.SizeX > 4 * PUPPIGUISettings.nodeSide)// && boundingBox.SizeY > 2 * PUPPIGUISettings.nodeSide)
                //{
                //     Rect3D canvasbbox = mycanvas.bbox(); 
                //    Rect3D blvd=d2collisionmodel.blvdabove(boundingBox,canvasbbox    )  ;
                //    levelredo = new d2collisionmodel();
                //    levelredo.footprints.Add(blvd);
                //    for (i = 0; i < allroots.Count; i++)
                //    {
                //               levelredo.footprints.Add(allroots[i].boundingBox.padme(Math.Max(PUPPIGUISettings.nodeSpacing, allroots[i].numconn * divsize)));


                //    }
                //    levelredo.recompute(false);
                //    for (i = 0; i < allroots.Count; i++)
                //    {

                //        allroots[i].movestack(d2collisionmodel.getrectcenter(levelredo.footprints[i + 1]).X - d2collisionmodel.getrectcenter(allroots[i].boundingBox).X, d2collisionmodel.getrectcenter(levelredo.footprints[i + 1]).Y - d2collisionmodel.getrectcenter(allroots[i].boundingBox).Y);

                //    }
                //    //for (i = 0; i < allroots.Count; i++)
                //    //{
                //    //    if (allroots[i].boundingBox.Location.Y>=blvd.Location.Y       )
                //    //    {
                //    //        allroots[i].movestack(0, PUPPIGUISettings.nodeSpacing);  
                //    //    }
                //    //    else
                //    //    {
                //    //        allroots[i].movestack(0, -PUPPIGUISettings.nodeSpacing);  
                //    //    }
                //    //}
                //}



                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log(utils.StringConstants.finishedfittingroots + nodeGUID.ToString());
                }
                if (mycanvas != null)
                {
                    mycanvas.lastChanged = DateTime.Now;

                    if ((PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning || PUPPIruntimesettings.PUPPICanvasHTTPServerIsRunning) && PUPPIruntimesettings.PUPPICanvasServerUpdatingFully)
                    {
                        PUPPICanvas.currentCanvasStatusServer = mycanvas.readMyCanvasStatus();
                        mycanvas.saveReponThread();
                        mycanvas.updateNodeInfoServer(this.nodeGUID.ToString());
                    }
                }
                // mycanvas.levelchange--;
            }

            internal event NodeChangedHandler NodeChanged;
            //replaces the box in the window with new one
            //replaces a box with a new one based on the position

            //1 reason for replace is update-inouts
            //2 reason for replace is bottompyramid
            //3 deferred update caption and in outs as there will be a bottompyramid in the future
            internal ModelVisual3D replacebox(Rect3D newbounds, int reason = 0)
            {

                //to make a little transparent box in the middle
                double smallBoxSize = PUPPIGUISettings.nodeSide * 0.01;
                Point3D newboundscenter = newbounds.rectcenter();
                ModViz3DNode stackrep = this;
                myview = mycanvas.hv;
                ModelVisual3D original = null;
                ModelVisual3D model = new ModelVisual3D();
                //try
                //{
                original = stackrep.myself;
                //}
                //catch
                //{
                //    return null;
                //}
                if (original == null)
                {
                    return null;
                }
                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log(utils.StringConstants.startedrepnodebox + nodeGUID.ToString());
                }
                string keepGUID = original.GetName();

                bool rendered = false;
                //custom renderer
                if (nodeCustomRenderer != null && PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional && nodeCustomRenderer.use2D)
                {
                    rendered = true;
                    if (nodeCustomRenderer.needsRender) rendered = nodeCustomRenderer.renderCustom();
                    if (rendered)
                    {
                        if ((PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning || PUPPIruntimesettings.PUPPICanvasHTTPServerIsRunning) && PUPPIruntimesettings.PUPPICanvasServerUpdatingFully)
                            exportMyNRenderer();

                        ModelVisual3D replacer = new ModelVisual3D();
                        nodeCustomRenderer.model2D.SetName(myself.GetName());
                        Point3D nbRC = newbounds.rectcenter();
                        Point3D ncrRC = nodeCustomRenderer.bbox.rectcenter();
                        Vector3D tranv = Point3D.Subtract(nbRC, ncrRC);
                        //match Z bottom
                        tranv.Z = nbRC.Z - newbounds.SizeZ / 2 - ncrRC.Z + nodeCustomRenderer.bbox.SizeZ / 2;
                        if (PUPPIDebugger.debugenabled == true)
                        {
                            PUPPIDebugger.log("Moving 2D renderer node " + nodeGUID.ToString() + " by vector " + tranv.ToString());
                        }

                        replacer = nodeCustomRenderer.model2D.moveVisualChildren(tranv, newboundscenter.makeSizeBox(smallBoxSize, smallBoxSize, smallBoxSize), mycanvas.customRenderBox_default_mat);

                        //replacer = nodeCustomRenderer.model2D.moveVisualChildren(tranv);
                        if (!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas)
                            myview.Children[myview.Children.IndexOf(myself)] = replacer;
                        myself = replacer;

                        //  //if renderer has valid box
                        //if (nodeCustomRenderer.bbox.IsEmpty || Double.IsNaN(nodeCustomRenderer.bbox.Location.X) || Double.IsNaN(nodeCustomRenderer.bbox.Location.Y) || Double.IsNaN(nodeCustomRenderer.bbox.Location.Z) || Double.IsNaN(nodeCustomRenderer.bbox.SizeX) || Double.IsNaN(nodeCustomRenderer.bbox.SizeY) || Double.IsNaN(nodeCustomRenderer.bbox.SizeZ))
                        //{


                        //    Rect3D cBB = Rect3D.Offset(boundingBox, tranv);
                        //    cBB.Z = newbounds.Z;
                        //    cBB.SizeZ = newbounds.SizeZ;
                        //    nodeCustomRenderer.displacedBbox = cBB;
                        //    cBB.Union(newbounds);
                        //    boundingBox = cBB.locationnodeSpacing();
                        //}
                        //else
                        //{
                        //make sure the bounding box scales accordingly in x and y
                        Rect3D cBB = Rect3D.Offset(nodeCustomRenderer.bbox, tranv);
                        cBB.Z = newbounds.Z;
                        cBB.SizeZ = newbounds.SizeZ;
                        nodeCustomRenderer.displacedBbox = cBB;


                        if (reason == 0 || reason == 3)
                        {
                            ////maybe newbounds is bigger than what we need
                            Rect3D defnbb = newboundscenter.makeSizeBox(PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeHeight);


                            cBB.Union(defnbb);
                        }
                        else
                        {

                            cBB.Union(newbounds);
                        }


                        boundingBox = cBB.locationnodeSpacing();
                        if (PUPPIDebugger.debugenabled == true)
                        {
                            PUPPIDebugger.log("Node  " + nodeGUID.ToString() + " actual boundary is " + replacer.getBBRecursive() + " versus calculated " + boundingBox.ToString());
                        }
                        //}
                    }
                    else
                    {
                        //nodeCustomRenderer = null;
                    }

                }
                else if (nodeCustomRenderer != null && PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional && nodeCustomRenderer.use3D)
                {
                    rendered = true;
                    if (nodeCustomRenderer.needsRender) rendered = nodeCustomRenderer.renderCustom();
                    if (rendered)
                    {
                        if ((PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning || PUPPIruntimesettings.PUPPICanvasHTTPServerIsRunning) && PUPPIruntimesettings.PUPPICanvasServerUpdatingFully)
                            exportMyNRenderer();
                        ModelVisual3D replacer = new ModelVisual3D();

                        nodeCustomRenderer.model3D.SetName(myself.GetName());
                        Point3D nbRC = newbounds.rectcenter();
                        Point3D ncrRC = nodeCustomRenderer.bbox.rectcenter();
                        Vector3D tranv = Point3D.Subtract(nbRC, ncrRC);
                        //match Z bottom
                        tranv.Z = nbRC.Z - newbounds.SizeZ / 2 - ncrRC.Z + nodeCustomRenderer.bbox.SizeZ / 2;
                        if (PUPPIDebugger.debugenabled == true)
                        {
                            PUPPIDebugger.log("Moving 3D renderer node " + nodeGUID.ToString() + " by vector " + tranv.ToString());
                        }
                        replacer = nodeCustomRenderer.model3D.moveVisualChildren(tranv, newbounds.rectcenter().makeSizeBox(smallBoxSize, smallBoxSize, smallBoxSize), mycanvas.customRenderBox_default_mat);
                        //replacer = nodeCustomRenderer.model3D.moveVisualChildren(tranv);
                        if (!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas)
                            myview.Children[myview.Children.IndexOf(myself)] = replacer;
                        myself = replacer;

                        ////if renderer has valid box
                        //if (nodeCustomRenderer.bbox.IsEmpty || Double.IsNaN(nodeCustomRenderer.bbox.Location.X) || Double.IsNaN(nodeCustomRenderer.bbox.Location.Y) || Double.IsNaN(nodeCustomRenderer.bbox.Location.Z) || Double.IsNaN(nodeCustomRenderer.bbox.SizeX) || Double.IsNaN(nodeCustomRenderer.bbox.SizeY) || Double.IsNaN(nodeCustomRenderer.bbox.SizeZ))
                        //{
                        //    Rect3D cBB = Rect3D.Offset(boundingBox, tranv);
                        //    cBB.Z = newbounds.Z;
                        //    cBB.SizeZ = newbounds.SizeZ;
                        //    nodeCustomRenderer.displacedBbox = cBB;
                        //    cBB.Union(newbounds);
                        //    boundingBox = cBB.locationnodeSpacing();
                        //} else
                        //{
                        //make sure the bounding box scales accordingly in x and y
                        Rect3D cBB = Rect3D.Offset(nodeCustomRenderer.bbox, tranv);
                        cBB.Z = newbounds.Z;
                        cBB.SizeZ = newbounds.SizeZ;
                        nodeCustomRenderer.displacedBbox = cBB;
                        if (reason == 0 || reason == 3)
                        {
                            //maybe newbounds is bigger than what we need
                            Rect3D defnbb = newboundscenter.makeSizeBox(PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeHeight);


                            cBB.Union(defnbb);

                        }
                        else
                        {
                            cBB.Union(newbounds);
                        }


                        boundingBox = cBB.locationnodeSpacing();
                        //}
                        if (PUPPIDebugger.debugenabled == true)
                        {
                            PUPPIDebugger.log("Node  " + nodeGUID.ToString() + " actual boundary is " + replacer.getBBRecursive() + " versus calculated " + boundingBox.ToString());
                        }
                    }
                    else
                    {
                        //nodeCustomRenderer = null;
                    }

                }

                if (!rendered)
                {

                    //if size has changed, and no custom renderer
                    if (boundingBox.getDiagonal() != newbounds.getDiagonal())
                    {

                        var meshBuilder = new MeshBuilder(false, false);
                        //Point3D newpos = newbounds.Location;
                        //newpos.Offset(newbounds.SizeX * 0.5, newbounds.SizeY * 0.5, newbounds.SizeZ * 0.5);
                        Point3D newpos = newboundscenter;
                        if (PUPPIGUISettings.roundedCornerRadius == 0)
                        {

                            meshBuilder.AddBox(newpos, newbounds.SizeX, newbounds.SizeY, newbounds.SizeZ);
                        }
                        else
                        {
                            Point3D p0 = new Point3D(newpos.X, newpos.Y, newbounds.Z);
                            Point3D p1 = new Point3D(newpos.X, newpos.Y, newbounds.Z + newbounds.SizeZ);

                            // meshBuilder.AddExtrudedGeometry(Visual3DExtensions.makeroundedrect(newbounds.SizeX, newbounds.SizeY, PUPPIGUISettings.roundedCornerRadius * (Math.Min(newbounds.SizeX, newbounds.SizeY))), new Vector3D(1, 0, 0), p0, p1);
                            Visual3DExtensions.makeverticalextrusion(meshBuilder, Visual3DExtensions.makeroundedrect(newbounds.SizeX, newbounds.SizeY, PUPPIGUISettings.roundedCornerRadius * (Math.Min(newbounds.SizeX, newbounds.SizeY))), p0, p1);

                        }
                        //chamfer mesh
                        if (PUPPIGUISettings.chamferCornerDepth > 0)
                        {
                            double chaccod = Math.Min(Math.Min(newbounds.SizeX, newbounds.SizeY), newbounds.SizeZ) * PUPPIGUISettings.chamferCornerDepth;
                            meshBuilder.ChamferCorner(newbounds.Location, chaccod);
                            meshBuilder.ChamferCorner(Point3D.Add(newbounds.Location, new Vector3D(newbounds.SizeX, 0, 0)), chaccod);
                            meshBuilder.ChamferCorner(Point3D.Add(newbounds.Location, new Vector3D(0, newbounds.SizeY, 0)), chaccod);
                            meshBuilder.ChamferCorner(Point3D.Add(newbounds.Location, new Vector3D(newbounds.SizeX, newbounds.SizeY, 0)), chaccod);
                            meshBuilder.ChamferCorner(Point3D.Add(newbounds.Location, new Vector3D(newbounds.SizeX, 0, newbounds.SizeZ)), chaccod);
                            meshBuilder.ChamferCorner(Point3D.Add(newbounds.Location, new Vector3D(0, newbounds.SizeY, newbounds.SizeZ)), chaccod);
                            meshBuilder.ChamferCorner(Point3D.Add(newbounds.Location, new Vector3D(newbounds.SizeX, newbounds.SizeY, newbounds.SizeZ)), chaccod);
                            meshBuilder.ChamferCorner(Point3D.Add(newbounds.Location, new Vector3D(0, 0, newbounds.SizeZ)), chaccod);
                        }


                        var mesh = meshBuilder.ToMesh(true);
                        GeometryModel3D newModel = new GeometryModel3D();

                        newModel.Geometry = mesh;
                        if (nodeUpdatedMaterial == null)
                        {
                            newModel.Material = mycanvas.node_default_mat;
                        }
                        else
                        {
                            newModel.Material = nodeUpdatedMaterial;
                        }

                        // new EmissiveMaterial(new SolidColorBrush(Colors.Red));
                        //Model3DGroup modelGroup = new Model3DGroup();
                        //modelGroup.Children.Add(cubeModel);

                        model.SetName(keepGUID);
                        model.Content = newModel;
                        if (!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas)
                            myview.Children[myview.Children.IndexOf(original)] = model;

                        stackrep.myself = model;

                        boundingBox = newbounds;


                    }//translate
                    else
                    {

                        Vector3D mv = Point3D.Subtract(newbounds.rectcenter(), stackrep.myposition);
                        int cindex = -1;
                        //if (caption != null)
                        //{

                        //    cindex = stackrep.myself.Children.IndexOf(caption);


                        //}
                        //if (cindex != -1) stackrep.myself.Children.RemoveAt(cindex);
                        //just change material

                        //if (mv.X != 0 || mv.Y != 0 || mv.Z != 0)
                        //{
                        ModelVisual3D m = new ModelVisual3D();
                        GeometryModel3D newModel = new GeometryModel3D();
                        newModel = stackrep.myself.moveMyVisual(mv);
                        newModel.Material = mycanvas.node_default_mat;
                        try
                        {
                            if (nodeUpdatedMaterial == null)
                            {

                            }
                            else
                            {
                                newModel.Material = nodeUpdatedMaterial;
                            }
                        }
                        catch
                        {

                        }

                        m.Content = newModel;
                        m.SetName(keepGUID);
                        //stackrep.myself = m;
                        if (!mycanvas.thiscanvasdefinitelylocked || !hiddenOnLockedCanvas)
                            myview.Children[myview.Children.IndexOf(original)] = m;
                        stackrep.myself = m;

                        //}
                        //else
                        //{
                        //    try
                        //    {
                        //        if (nodeUpdatedMaterial == null)
                        //        {
                        //            (stackrep.myself.Content as GeometryModel3D).Material = mycanvas.node_default_mat;
                        //        }
                        //        else
                        //        {
                        //            (stackrep.myself.Content as GeometryModel3D).Material = nodeUpdatedMaterial;
                        //        }
                        //    }
                        //    catch
                        //    {

                        //    }

                        //}

                        boundingBox = newbounds;

                    }
                }
                myposition = boundingBox.rectcenter();
                //sets the logic
                // if (logical_representation != null)
                //{
                //  setlogic(logical_representation);
                //}

                if (logical_representation != null)
                {

                    //try multithread to see if works
                    //there should not be much following from these commands and they should be able to be called
                    //from new threads. also, boxes already have size in based on inputs and outputs
                    //                        System.Threading.ThreadPool.QueueUserWorkItem(
                    //new System.Threading.WaitCallback(threadcapupdate));
                    //                        System.Threading.ThreadPool.QueueUserWorkItem(
                    //        new System.Threading.WaitCallback(threadioupdate));
                    //above failed to update connections

                    //we either update or add this to the nodes to update
                    //this is to make sure we don't run this more than once
                    if (PUPPIruntimesettings.currentstate == PUPPIruntimesettings.graphicalnodeupdatestates.DoUpdate)
                    {
                        //don't want to update these forever
                        if (reason != 3)
                        {
                            stackrep.update_caption();
                            stackrep.update_inouts();
                        }

                    }

                    else
                    {
                        //stackrep.deleteall_inouts();  
                        if (mycanvas.nodestoupdate.Contains(this) == false)
                        {
                            mycanvas.nodestoupdate.Add(this);
                        }

                    }
                }
                //don't want to update these forever
                if (reason != 3)
                {
                    if (NodeChanged != null) NodeChanged(mycanvas, null);
                }
                // Dispatcher.CurrentDispatcher.Invoke(new Action(() => { }), DispatcherPriority.ContextIdle, null);

                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log(utils.StringConstants.finishedrepnodebox + nodeGUID.ToString());
                }
                return model;

                //}
                //catch(Exception exy)
                //{
                //    throw new Exception("Failed to update node visual \n" + exy.ToString() );
                //}
                if (mycanvas != null)
                {
                    mycanvas.lastChanged = DateTime.Now;

                    if ((PUPPIruntimesettings.PUPPICanvasTCPServerIsRunning || PUPPIruntimesettings.PUPPICanvasHTTPServerIsRunning) && PUPPIruntimesettings.PUPPICanvasServerUpdatingFully)
                    {
                        PUPPICanvas.currentCanvasStatusServer = mycanvas.readMyCanvasStatus();
                        mycanvas.saveReponThread();
                        mycanvas.updateNodeInfoServer(this.nodeGUID.ToString());
                    }
                }
            }
            //gets the input names
            internal List<string> getinputnames()
            {
                List<String> ginputnames = new List<string>();
                for (int i = 0; i < logical_representation.inputs.Count; i++)
                {

                    ginputnames.Add(logical_representation.inputnames[i]);

                }
                return ginputnames;
            }

            //gets the output names
            internal List<string> getoutputnames()
            {
                List<String> gonames = new List<string>();
                for (int i = 0; i < logical_representation.outputs.Count; i++)
                {

                    gonames.Add(logical_representation.outputnames[i]);

                }
                return gonames;
            }

            //here we figure out how to place inputs and outputs
            //does not count bottom base or it inputs and outputs
            internal int getoutputindex(int ocount)
            {
                if (parent == null) return 0;
                int ret = ocount;
                ModViz3DNode godown = parent;
                while (godown.parent != null)
                {
                    ret += godown.vizoutputs.Count;
                    godown = godown.parent;
                }
                return ret;
            }
            internal int getinputindex(int icount)
            {
                if (parent == null) return 0;
                int ret = icount;
                ModViz3DNode godown = parent;
                while (godown.parent != null)
                {
                    ret += godown.vizinputs.Count;
                    godown = godown.parent;
                }
                return ret;
            }
            //also get total number of inputs and outputs on stack
            internal int getstackinputs()
            {

                if (parent == null) return 0;
                int inpnum = 0;
                ModViz3DNode godown = parent;
                ModViz3DNode above = this;
                while (godown.parent != null)
                {
                    above = godown;
                    godown = godown.parent;
                }
                godown = above;
                inpnum += godown.vizinputs.Count;
                while (godown.childs.Count > 0)
                {
                    if (godown.childs[0] != null)
                    {
                        godown = godown.childs[0] as ModViz3DNode;
                        inpnum += godown.vizinputs.Count;
                    }
                    else
                    {
                        break;
                    }
                }
                return inpnum;
            }

            internal int getstackoutputs()
            {

                if (parent == null) return 0;
                int inpnum = 0;
                ModViz3DNode godown = parent;
                ModViz3DNode above = this;
                while (godown.parent != null)
                {
                    above = godown;
                    godown = godown.parent;
                }
                godown = above;
                inpnum += godown.vizoutputs.Count;
                while (godown.childs.Count > 0)
                {
                    if (godown.childs[0] != null)
                    {
                        godown = godown.childs[0] as ModViz3DNode;
                        inpnum += godown.vizoutputs.Count;
                    }
                    else
                    {
                        break;
                    }
                }
                return inpnum;
            }


            internal Rect3D getmaxbound()
            {
                if (parent == null) return new Rect3D(0, 0, 0, 0, 0, 0);

                ModViz3DNode godown = this;
                while (godown.parent.parent != null)
                {

                    godown = godown.parent;
                }
                return godown.boundingBox;
            }
            //gets the smallest y of any of the base children in order to know where to go through with the output going from base to one of its children
            internal double getminychilds()
            {
                double retme = boundingBox.Location.Y;
                if (parent != null) return retme;
                retme = boundingBox.Location.Y + boundingBox.SizeY * 0.5;
                for (int i = 0; i < childs.Count; i++)
                {
                    if (childs[i] != null)
                    {

                        if (childs[i].myself != null)
                        {
                            if (childs[i].boundingBox.Location.Y < retme)
                            {
                                retme = childs[i].boundingBox.Location.Y;
                            }
                        }
                    }
                }
                return retme;
            }
            //gets the smallest y of any of the base children in order to know where to go through with the output going from base to one of its children
            internal double getmaxychilds()
            {
                double retme = boundingBox.Location.Y + boundingBox.SizeY;
                if (parent != null) return retme;
                retme = boundingBox.Location.Y + boundingBox.SizeY * 0.5;
                for (int i = 0; i < childs.Count; i++)
                {
                    if (childs[i] != null)
                    {

                        if (childs[i].myself != null)
                        {
                            if (childs[i].boundingBox.Location.Y + childs[i].boundingBox.SizeY > retme)
                            {
                                retme = childs[i].boundingBox.Location.Y + childs[i].boundingBox.SizeY;
                            }
                        }
                    }
                }
                return retme;
            }
        }
        //this will check footprints and displace
        //footprint at zero is the only one assumed changed
        //this will not be moved
        //will return main perimeter and new locations in the same order as fed Rect3Ds
        internal class d2collisionmodel
        {
            static int recomputes;
            internal List<Rect3D> footprints;
            internal Rect3D region_perimeter;
            //store division size if we get matrix;
            internal double mydiv = 0;
            int[,] occup_matrix = null;
            //store this information for faster access
            internal static d2collisionmodel canvaslevelmap;
            internal static Point3D canvaslevelmaporigin;
            internal d2collisionmodel()
            {
                footprints = new List<Rect3D>();

                region_perimeter = new Rect3D();
                recomputes = 0;

            }



            //moves everything to fit and gives the new perimeter
            //constrain can be 0 (no constrain) 1 (horizontal) 2(vertical) 3(vertical if spanning perimeter)
            internal void recompute(int constrain)
            {
                if (constrain == 3 && region_perimeter.IsEmpty) recalculate_perimeter();

                if (recomputes > PUPPIGUISettings.maxNumberTries)
                {

                    return;
                }
                if (footprints.Count < 2) return;
                bool itintersects = false;
                int ind = 1;
                Rect3D changed = footprints[0];

                for (ind = 1; ind < footprints.Count; ind++)
                {
                    Rect3D changee = footprints[ind];

                    Vector3D pushit = new Vector3D();
                    //if we use constrain=3 then spanning members are pushed up and down
                    int cstrain = constrain;
                    if (constrain == 3 && ((changee.SizeX == region_perimeter.SizeX) || (changed.SizeX == region_perimeter.SizeX)))
                    {
                        itintersects = boxintersectswith(changed, changee, out pushit, 2);
                        cstrain = 2;
                    }
                    else if (constrain == 3) { itintersects = boxintersectswith(changed, changee, out pushit, 0); cstrain = 0; }
                    else
                    {
                        itintersects = boxintersectswith(changed, changee, out pushit, constrain);
                        cstrain = constrain;
                    }

                    Vector push2d = new Vector(pushit.X, pushit.Y);


                    if (cstrain == 1) push2d.Y = 0;
                    else if (cstrain == 2) push2d.X = 0;
                    if (itintersects == true)
                    {
                        //moves all on that side
                        //try parallel
                        // Parallel.For(1, footprints.Count, pind =>
                        for (int pind = 1; pind < footprints.Count; pind++)
                        {

                            Rect3D sidechangee = footprints[pind];
                            Vector3D sidechangeedir = Point3D.Subtract(getrectcenter(sidechangee), getrectcenter(changed));
                            Vector scd2d = new Vector(sidechangeedir.X, sidechangeedir.Y);

                            if ((Vector.AngleBetween(scd2d, push2d) < 90 && Vector.AngleBetween(scd2d, push2d) > -90) || Vector.AngleBetween(scd2d, push2d) > 270 || sidechangeedir.Length == 0)
                            {
                                Rect3D newchangee = new Rect3D(sidechangee.Location.X + pushit.X, sidechangee.Location.Y + pushit.Y, sidechangee.Location.Z + pushit.Z, sidechangee.SizeX, sidechangee.SizeY, sidechangee.SizeZ);
                                footprints[pind] = newchangee;
                                if (PUPPIDebugger.debugenabled == true)
                                {
                                    PUPPIDebugger.log("Determined new position for root " + pind + " to " + newchangee.ToString() + " using vector " + pushit.ToString());
                                }
                            }
                        }//);


                        // break;
                    }

                }

                //if (itintersects == true)
                //{
                //    recomputes++;
                //    recompute(constrain);
                //}



            }

            internal void recalculate_perimeter()
            {
                double minx = 1000000000;
                double miny = 1000000000;
                double maxx = -1000000000;
                double maxy = -1000000000;

                for (int fpi = 0; fpi < footprints.Count; fpi++)
                //foreach (Rect3D fp in footprints)
                {
                    if (footprints[fpi].Location.X < minx)
                    {
                        minx = footprints[fpi].Location.X;
                    }
                    if (footprints[fpi].Location.X + footprints[fpi].SizeX > maxx)
                    {
                        maxx = footprints[fpi].Location.X + footprints[fpi].SizeX;
                    }
                    if (footprints[fpi].Location.Y < miny)
                    {
                        miny = footprints[fpi].Location.Y;
                    }
                    if (footprints[fpi].Location.Y + footprints[fpi].SizeY > maxy)
                    {
                        maxy = footprints[fpi].Location.Y + footprints[fpi].SizeY;
                    }


                }
                if (footprints.Count > 0)
                {
                    region_perimeter = new Rect3D(minx, miny, footprints[0].Location.Z, maxx - minx, maxy - miny, footprints[0].SizeZ);
                }
            }

            internal static Point3D getrectcenter(Rect3D r)
            {
                if (r == null)
                {
                    return new Point3D(-1000000, -1000000, -1000000);
                }
                else
                {


                    return new Point3D(r.Location.X + r.SizeX * 0.5, r.Location.Y + r.SizeY * 0.5, r.Location.Z + r.SizeZ * 0.5);
                }
            }
            //returns rectangles to make busy corner
            internal static List<Rect3D> busycorner(Rect3D bbox, Rect3D bigbuilding)
            {
                List<Rect3D> bc = new List<Rect3D>();
                try
                {
                    Rect3D tleft = new Rect3D(bbox.Location.X, bigbuilding.Location.Y + bigbuilding.SizeY, 0, bigbuilding.Location.X + bigbuilding.SizeX - bbox.Location.X, PUPPIGUISettings.nodeSpacing, PUPPIGUISettings.nodeHeight);

                    Rect3D tright = new Rect3D(bigbuilding.Location.X + bigbuilding.SizeX + PUPPIGUISettings.nodeSpacing, bigbuilding.Location.Y + bigbuilding.SizeY, 0, bbox.Location.X + bbox.SizeX - (bigbuilding.Location.X + bigbuilding.SizeX + PUPPIGUISettings.nodeSpacing), PUPPIGUISettings.nodeSpacing, PUPPIGUISettings.nodeHeight);

                    Rect3D tdown = new Rect3D(bigbuilding.Location.X + bigbuilding.SizeX, bbox.Location.Y, 0, PUPPIGUISettings.nodeSpacing, bbox.SizeY, PUPPIGUISettings.nodeHeight);
                    bc.Add(tleft);
                    bc.Add(tright);
                    bc.Add(tdown);

                }
                catch
                {

                }
                return bc;
            }
            //makes boulevard spanning width
            internal static Rect3D blvdabove(Rect3D bigbuilding, Rect3D bbox)
            {
                //make longer to ensure we push down
                return new Rect3D(bbox.Location.X - bbox.SizeX, bigbuilding.Location.Y + bigbuilding.SizeY, 0, 2 * bbox.SizeX, 2 * PUPPIGUISettings.nodeSpacing, PUPPIGUISettings.nodeHeight);
            }
            //this must be +
            internal double getVInNSIMax(double V)
            {
                double nspc = Math.Ceiling(V / PUPPIGUISettings.nodeSpacing);
                return nspc * PUPPIGUISettings.nodeSpacing;
            }

            //checks if boxes intersect, provides the shortest x or y vector to get r2 out of r1
            internal bool boxintersectswith(Rect3D r1, Rect3D r2, out Vector3D pushvector, int constrain)
            {


                bool inter = false;
                pushvector = new Vector3D();
                //since wWeakEventListener calculate now spacing between them...
                if (Math.Abs(getrectcenter(r1).X - getrectcenter(r2).X) < r1.SizeX * 0.5 + r2.SizeX * 0.5 && Math.Abs(getrectcenter(r1).Y - getrectcenter(r2).Y) < r1.SizeY * 0.5 + r2.SizeY * 0.5 && Math.Abs(getrectcenter(r1).Z - getrectcenter(r2).Z) < r1.SizeZ * 0.5 + r2.SizeZ * 0.5)
                //if (Math.Abs(getrectcenter(r1).X - getrectcenter(r2).X) < r1.SizeX *0.5 + r2.SizeX *0.5 + PUPPIGUISettings.nodeSpacing  && Math.Abs(getrectcenter(r1).Y - getrectcenter(r2).Y) < r1.SizeY *0.5 + r2.SizeY *0.5 +PUPPIGUISettings.nodeSpacing && Math.Abs(getrectcenter(r1).Z - getrectcenter(r2).Z) < r1.SizeZ *0.5 + r2.SizeZ *0.5)
                {
                    inter = true;

                    Vector3D pushdir = quaddir(getrectcenter(r1), getrectcenter(r2), constrain);
                    // Vector3D bordermatch = new Vector3D(getVInNSIMax(pushdir.X * (r1.SizeX * 0.5 + r2.SizeX * 0.5)), getVInNSIMax(pushdir.Y * (r1.SizeY * 0.5 + r2.SizeY * 0.5)), 0);

                    Vector3D bordermatch = new Vector3D((pushdir.X * (r1.SizeX * 0.5 + r2.SizeX * 0.5)), (pushdir.Y * (r1.SizeY * 0.5 + r2.SizeY * 0.5)), 0);


                    Point3D whereto = Point3D.Add(getrectcenter(r1), bordermatch);

                    pushvector = Point3D.Subtract(whereto, getrectcenter(r2));
                    if (pushdir.X == 0) pushvector.X = 0;
                    if (pushdir.Y == 0) pushvector.Y = 0;
                    pushvector.Z = 0;

                }



                return inter;
            }
            //checks oif connector intersects with box
            bool conintersectswith(Rect3D r1, Rect3D r2)
            {


                bool inter = false;


                if (Math.Abs(getrectcenter(r1).X - getrectcenter(r2).X) < r1.SizeX * 0.5 + r2.SizeX * 0.5 - PUPPIGUISettings.intersectToler && Math.Abs(getrectcenter(r1).Y - getrectcenter(r2).Y) < r1.SizeY * 0.5 + r2.SizeY * 0.5 - PUPPIGUISettings.intersectToler && Math.Abs(getrectcenter(r1).Z - getrectcenter(r2).Z) < r1.SizeZ * 0.5 + r2.SizeZ * 0.5 - PUPPIGUISettings.intersectToler)
                {
                    inter = true;



                }



                return inter;
            }
            //the occupancy matrix for box placement
            internal void getboxoccupancymatrix(out int[,] mtrx, double divsize)
            {

                mydiv = divsize;
                mtrx = null;
                if (footprints.Count == 0 || divsize == 0)
                {
                    return;
                }
                //recalculate_perimeter();
                double nodiv = 1.0 / divsize;
                int xdivs = (int)Math.Floor(region_perimeter.SizeX * nodiv);
                int ydivs = (int)Math.Floor(region_perimeter.SizeY * nodiv);
                double startx = region_perimeter.Location.X;
                double starty = region_perimeter.Location.Y;
                if (xdivs == 0 || ydivs == 0)
                {
                    return;
                }
                mtrx = new int[ydivs, xdivs];
                //get the footptint height from first rect
                double zloc = footprints[0].Location.Z;
                for (int j = 1; j <= ydivs; j++)
                {

                    for (int i = 1; i <= xdivs; i++)
                    {

                        Rect3D mypos = new Rect3D(startx + (i - 1) * divsize + PUPPIGUISettings.nodeSpacing, starty + (j - 1) * divsize + PUPPIGUISettings.nodeSpacing, zloc, divsize - PUPPIGUISettings.nodeSpacing, divsize - PUPPIGUISettings.nodeSpacing, PUPPIGUISettings.nodeHeight);
                        for (int jj = 0; jj < footprints.Count; jj++)
                        //foreach (Rect3D fm in footprints)
                        {
                            //not needed
                            Vector3D dummy = new Vector3D();
                            if (boxintersectswith(footprints[jj], mypos, out dummy, 0) == true)
                            //if (centerinrectangle(getrectcenter(fm) , mypos) == true)
                            {
                                mtrx[j - 1, i - 1] = 1;
                                break;
                            }
                        }

                    }

                }
                occup_matrix = mtrx;
                return;
            }
            //for connectors
            internal void getconoccupancymatrix(out int[,] mtrx, double divsize)
            {

                mydiv = divsize;
                mtrx = null;
                if (footprints.Count == 0 || divsize == 0)
                {
                    return;
                }
                //recalculate_perimeter();
                double nodiv = 1.0 / divsize;
                int xdivs = (int)Math.Floor(region_perimeter.SizeX * nodiv);
                int ydivs = (int)Math.Floor(region_perimeter.SizeY * nodiv);
                double startx = region_perimeter.Location.X;
                double starty = region_perimeter.Location.Y;
                if (xdivs == 0 || ydivs == 0)
                {
                    return;
                }
                int[,] omtrx = new int[ydivs, xdivs];
                //get the footptint height from first rect
                double zloc = footprints[0].Location.Z;
                Parallel.For(1, ydivs + 1, j =>
                // for (int j = 1; j <= ydivs; j++)
                {

                    for (int i = 1; i <= xdivs; i++)
                    {

                        Rect3D mypos = new Rect3D(startx + (i - 1) * divsize, starty + (j - 1) * divsize, zloc, divsize, divsize, PUPPIGUISettings.nodeHeight);
                        for (int jj = 0; jj < footprints.Count; jj++)
                        // foreach (Rect3D fm in footprints)
                        {

                            if (conintersectswith(footprints[jj], mypos) == true)
                            //if (centerinrectangle(getrectcenter(fm) , mypos) == true)
                            {
                                omtrx[j - 1, i - 1] = 1;
                                break;
                            }
                        }

                    }

                });
                occup_matrix = omtrx;
                mtrx = omtrx;
                return;
            }

            //previous connectors
            internal void getprevconnoccupancymatrix(d2collisionmodel oldconns, out int[,] mtrx, double divsize)
            {
                double nodiv = 0;
                mydiv = divsize;
                mtrx = null;
                if (footprints.Count == 0 || divsize == 0)
                {
                    return;
                }
                //recalculate_perimeter();
                nodiv = 1.0 / divsize;
                double bodiv = divsize;
                int xdivs = (int)Math.Floor(region_perimeter.SizeX * nodiv);
                int ydivs = (int)Math.Floor(region_perimeter.SizeY * nodiv);
                double startx = region_perimeter.Location.X;
                double starty = region_perimeter.Location.Y;
                if (xdivs == 0 || ydivs == 0)
                {
                    return;
                }
                mtrx = new int[ydivs, xdivs];
                //get the footptint height from first rect
                double zloc = footprints[0].Location.Z;
                for (int j = 1; j <= ydivs; j++)
                {

                    for (int i = 1; i <= xdivs; i++)
                    {

                        Rect3D mypos = new Rect3D(startx + (i - 1) * divsize, starty + (j - 1) * divsize, zloc, divsize, divsize, PUPPIGUISettings.nodeHeight);
                        //
                        for (int jj = 0; jj < oldconns.footprints.Count; jj++)
                        // foreach (Rect3D fm in oldconns.footprints)
                        {

                            //  Rect3D tm = new Rect3D(new Point3D(fm.Location.X, fm.Location.Y, zloc), new Size3D(fm.SizeX, fm.SizeY, footprints[0].SizeZ));

                            Rect3D tm = new Rect3D(new Point3D(oldconns.footprints[jj].Location.X, oldconns.footprints[jj].Location.Y, zloc), new Size3D(oldconns.footprints[jj].SizeX, oldconns.footprints[jj].SizeY, footprints[0].SizeZ));

                            if (conintersectswith(tm, mypos) == true)
                            {
                                mtrx[j - 1, i - 1]++;

                            }
                        }

                    }

                }

                return;
            }


            //update with the latest set of connectors
            internal static void updateconnmatrixcount(Point3D regorigin, d2collisionmodel uconns, int[,] mtrx, int[,] maze, double divsize)
            {

                double mydiv = divsize;

                if (uconns.footprints.Count == 0 || divsize == 0 || mtrx == null || maze == null)
                {
                    return;
                }
                //recalculate_perimeter();
                double nodiv = 1.0 / divsize;
                int xdivs = mtrx.GetLength(1);
                int ydivs = mtrx.GetLength(0);
                double startx = regorigin.X;
                double starty = regorigin.Y;
                if (xdivs == 0 || ydivs == 0 || xdivs != maze.GetLength(1) || ydivs != maze.GetLength(0))
                {
                    return;
                }
                //mtrx = new int[ydivs, xdivs];
                //get the footptint height from first rect
                double zloc = uconns.footprints[0].Location.Z;
                for (int jj = 0; jj < uconns.footprints.Count; jj++)
                {
                    //get first point
                    Point3D mypoint = uconns.footprints[jj].Location;
                    double locx = mypoint.X - regorigin.X;
                    double locy = mypoint.Y - regorigin.Y;
                    //centerize
                    locx = locx.nodespacecenterconvert(divsize);
                    locy = locy.nodespacecenterconvert(divsize);
                    int myx = Convert.ToInt32(Math.Floor(locx * nodiv));
                    int myy = Convert.ToInt32(Math.Floor(locy * nodiv));
                    if (myx >= 0 && myy >= 0 && myx <= mtrx.GetUpperBound(1) && myy <= mtrx.GetUpperBound(0))
                    {

                        if (PUPPIGUISettings.useMultiThreading)
                        {
                            //try threading
                            Interlocked.Increment(ref mtrx[myy, myx]);
                            if (Interlocked.Equals(mtrx[myy, myx], PUPPIGUISettings.maxConnPerSpace))
                            {
                                Interlocked.Exchange(ref maze[myy, myx], 1);

                            }

                        }
                        else
                        {

                            mtrx[myy, myx]++;
                            if (mtrx[myy, myx] == PUPPIGUISettings.maxConnPerSpace)
                            {

                                maze[myy, myx] = 1;
                            }


                        }
                    }
                }

                ////try parallel for
                //Parallel.For(1, ydivs + 1, j =>

                // //for (int j = 1; j <= ydivs; j++)
                // {

                //     for (int i = 1; i <= xdivs; i++)
                //     {

                //         Rect3D mypos = new Rect3D(startx + (i - 1) * divsize, starty + (j - 1) * divsize, zloc, divsize, divsize, PUPPIGUISettings.nodeHeight);
                //         //
                //         for (int jj = 0; jj < uconns.footprints.Count; jj++)
                //         // foreach (Rect3D fm in oldconns.footprints)
                //         {

                //             //  Rect3D tm = new Rect3D(new Point3D(fm.Location.X, fm.Location.Y, zloc), new Size3D(fm.SizeX, fm.SizeY, footprints[0].SizeZ));

                //             Rect3D tm = new Rect3D(new Point3D(uconns.footprints[jj].Location.X, uconns.footprints[jj].Location.Y, zloc), new Size3D(uconns.footprints[jj].SizeX, uconns.footprints[jj].SizeY, uconns.footprints[0].SizeZ));

                //             if (uconns.conintersectswith(tm, mypos) == true)
                //             {
                //                 mtrx[j - 1, i - 1]++;
                //                 //since we can only have one connection from one path occupying the same space, we can break
                //                 break;

                //             }
                //         }

                //     }

                // });

                return;
            }
            //updates with points
            internal static void updateconnPointsmatrixcount(Point3D regorigin, List<Point3D> cPs, int[,] hmtrx, int[,] vmtrx, int[,] hmaze, int[,] vmaze, double divsize)
            {

                double mydiv = divsize;

                if (cPs.Count == 0 || divsize == 0 || vmtrx == null || vmaze == null)
                {
                    return;
                }
                //recalculate_perimeter();
                double nodiv = 1.0 / divsize;
                int xdivs = hmtrx.GetLength(1);
                int ydivs = hmtrx.GetLength(0);
                double startx = regorigin.X;
                double starty = regorigin.Y;
                if (xdivs == 0 || ydivs == 0 || xdivs != hmaze.GetLength(1) || ydivs != hmaze.GetLength(0))
                {
                    return;
                }

                for (int jj = 0; jj < cPs.Count; jj++)
                {

                    Point3D mypoint = cPs[jj];
                    double locx = mypoint.X - regorigin.X;
                    double locy = mypoint.Y - regorigin.Y;
                    //centerize
                    locx = locx.nodespacecenterconvert(divsize);
                    locy = locy.nodespacecenterconvert(divsize);
                    int myx = Convert.ToInt32(Math.Floor(locx * nodiv));
                    int myy = Convert.ToInt32(Math.Floor(locy * nodiv));
                    if (myx >= 0 && myy >= 0 && myx <= hmtrx.GetUpperBound(1) && myy <= hmtrx.GetUpperBound(0))
                    {
                        if (mypoint.Z == 1 || mypoint.Z == 0)
                        {

                            if (PUPPIGUISettings.useMultiThreading)
                            {
                                //try threading
                                Interlocked.Increment(ref hmtrx[myy, myx]);
                                if (Interlocked.Equals(hmtrx[myy, myx], PUPPIGUISettings.maxConnPerSpace))
                                {
                                    Interlocked.Exchange(ref hmaze[myy, myx], 1);

                                }

                            }
                            else
                            {

                                hmtrx[myy, myx]++;
                                if (hmtrx[myy, myx] == PUPPIGUISettings.maxConnPerSpace)
                                {

                                    hmaze[myy, myx] = 1;
                                }


                            }
                        }
                        else if (mypoint.Z == 2 || mypoint.Z == 0)
                        {

                            if (PUPPIGUISettings.useMultiThreading)
                            {
                                //try threading
                                Interlocked.Increment(ref vmtrx[myy, myx]);
                                if (Interlocked.Equals(vmtrx[myy, myx], PUPPIGUISettings.maxConnPerSpace))
                                {
                                    Interlocked.Exchange(ref vmaze[myy, myx], 1);

                                }

                            }
                            else
                            {

                                vmtrx[myy, myx]++;
                                if (vmtrx[myy, myx] == PUPPIGUISettings.maxConnPerSpace)
                                {

                                    vmaze[myy, myx] = 1;
                                }


                            }
                        }
                    }
                }


                return;
            }


            //checks if any connections intersect the matrix
            //this has to be done for both x and y connection lines on different matrices
            internal static bool connsintersectmatrix(Point3D regorigin, d2collisionmodel uconns, int[,] mtrx, double divsize)
            {

                double mydiv = divsize;

                if (uconns.footprints.Count == 0 || divsize == 0)
                {
                    return false;
                }
                //recalculate_perimeter();
                double nodiv = 1.0 / divsize;
                int xdivs = mtrx.GetLength(1);
                int ydivs = mtrx.GetLength(0);
                double startx = regorigin.X;
                double starty = regorigin.Y;
                if (xdivs == 0 || ydivs == 0)
                {
                    return false;
                }
                //mtrx = new int[ydivs, xdivs];
                //get the footptint height from first rect
                double zloc = uconns.footprints[0].Location.Z;

                for (int jj = 0; jj < uconns.footprints.Count; jj++)
                {

                    //get first point
                    Point3D mypoint = uconns.footprints[jj].Location;
                    double locx = mypoint.X - regorigin.X;
                    double locy = mypoint.Y - regorigin.Y;
                    //centerize
                    locx = locx.nodespacecenterconvert(divsize);
                    locy = locy.nodespacecenterconvert(divsize);
                    int myx = Convert.ToInt32(Math.Floor(locx / divsize));
                    int myy = Convert.ToInt32(Math.Floor(locy / divsize));
                    if (myx >= 0 && myy >= 0 && myx <= mtrx.GetUpperBound(1) && myy <= mtrx.GetUpperBound(0))
                    {
                        if (mtrx[myy, myx] == 1)
                        {
                            return true;
                        }
                    }
                    //try simpler


                    // for (int j = 1; j <= ydivs; j++)
                    //{

                    //for (int i = 1; i <= xdivs; i++)
                    //{

                    //    Rect3D mypos = new Rect3D(startx + (i - 1) * divsize, starty + (j - 1) * divsize, zloc, divsize, divsize, PUPPIGUISettings.nodeHeight);
                    //


                    //  Rect3D tm = new Rect3D(new Point3D(fm.Location.X, fm.Location.Y, zloc), new Size3D(fm.SizeX, fm.SizeY, footprints[0].SizeZ));

                    //  Rect3D tm = new Rect3D(new Point3D(uconns.footprints[jj].Location.X, uconns.footprints[jj].Location.Y, zloc), new Size3D(uconns.footprints[jj].SizeX, uconns.footprints[jj].SizeY, uconns.footprints[0].SizeZ));

                    //  if (uconns.conintersectswith(tm, mypos) == true)
                    //   {
                    //     if (mtrx[j - 1, i - 1] == 1) { 
                    //     return true; 
                    //}



                    //   }
                    //    }

                    //  }

                }

                return false;
            }
            internal static bool connsPointsintersectmatrix(Point3D regorigin, List<Point3D> cPs, int[,] hmtrx, int[,] vmtrx, int[,] hC, int[,] vC, double divsize)
            {

                double mydiv = divsize;

                if (cPs.Count == 0 || divsize == 0 || vmtrx.GetLength(1) != hmtrx.GetLength(1) || vmtrx.GetLength(0) != hmtrx.GetLength(0))
                {
                    return false;
                }
                //recalculate_perimeter();
                double nodiv = 1.0 / divsize;
                int xdivs = vmtrx.GetLength(1);
                int ydivs = vmtrx.GetLength(0);
                double startx = regorigin.X;
                double starty = regorigin.Y;
                if (xdivs == 0 || ydivs == 0)
                {
                    return false;
                }
                //mtrx = new int[ydivs, xdivs];
                //get the footptint height from first rect


                for (int jj = 0; jj < cPs.Count; jj++)
                {


                    Point3D mypoint = cPs[jj];
                    double locx = mypoint.X - regorigin.X;
                    double locy = mypoint.Y - regorigin.Y;
                    //centerize
                    locx = locx.nodespacecenterconvert(divsize);
                    locy = locy.nodespacecenterconvert(divsize);
                    int myx = Convert.ToInt32(Math.Floor(locx / divsize));
                    int myy = Convert.ToInt32(Math.Floor(locy / divsize));
                    if (myx >= 0 && myy >= 0 && myx <= vmtrx.GetUpperBound(1) && myy <= vmtrx.GetUpperBound(0))
                    {
                        if (((hmtrx[myy, myx] == 1 || hC[myy, myx] == 1) && (mypoint.Z == 1 || mypoint.Z == 0)) || ((vmtrx[myy, myx] == 1 || vC[myy, myx] == 1) && (mypoint.Z == 2 || mypoint.Z == 0)))
                        {
                            return true;
                        }
                    }


                }

                return false;
            }

            //generates the levelmap for the entire canvas
            internal static d2collisionmodel make_levelmap(PUPPICanvas mycanvas)
            {
                d2collisionmodel levelmap = new d2collisionmodel();
                int basenumconn = 0;
                foreach (ModViz3DNode mn in mycanvas.stacks.Values)
                {

                    if (mn.myself != null)
                    {

                        if (mn.parent == null)
                        {
                            levelmap.footprints.Add(mn.boundingBox);
                        }
                        basenumconn += Math.Max(Math.Max(mn.vizinputs.Count, mn.vizoutputs.Count), mn.number_outbound_connections) + mn.numconn;


                    }

                }
                levelmap.recalculate_perimeter();
                //need to leave extra space for connecting lines
                int edgespacemult = Convert.ToInt16(basenumconn) / PUPPIGUISettings.maxConnPerSpace;
                if (edgespacemult == 0) edgespacemult = 1;
                levelmap.region_perimeter = levelmap.region_perimeter.padme(edgespacemult * PUPPIGUISettings.nodeSpacing);
                d2collisionmodel.canvaslevelmaporigin = levelmap.region_perimeter.Location;
                return levelmap;


            }








            //update the maze matrix for areas already filled with connections
            //areas right above aread filled with 1 are not counted to allow stuff to get out
            internal static void updatewithconns(int[,] mazemat, int[,] connlvlmat, out int[,] updatedmat)
            {
                if (mazemat != null && connlvlmat != null)
                {

                    int[,] umat = new int[mazemat.GetLength(0), mazemat.GetLength(1)];
                    // int rcount = 0;
                    //   int ccount = 0;
                    //try parallen
                    Parallel.For(0, mazemat.GetLength(0), rcount =>
                    //   for (int rcount = 0; rcount < mazemat.GetLength(0); rcount++)
                    {
                        for (int ccount = 0; ccount < mazemat.GetLength(1); ccount++)
                        {
                            umat[rcount, ccount] = mazemat[rcount, ccount];
                            if (mazemat[rcount, ccount] == 0)
                            {
                                if (connlvlmat[rcount, ccount] >= PUPPIGUISettings.maxConnPerSpace)
                                {
                                    if (rcount > 0)
                                    {


                                        //don't bother with spaces just above objects
                                        if (mazemat[rcount - 1, ccount] == 0)
                                        {
                                            umat[rcount, ccount] = 1;
                                        }
                                    }
                                    else
                                    {
                                        umat[rcount, ccount] = 1;
                                    }
                                }
                            }
                        }
                    });
                    updatedmat = umat;
                }
                else
                {
                    updatedmat = null;
                }
            }

            //leaves enough space
            internal Point3D wheretoadd(int padnumber)
            {
                //scale up leaving space around
                // int edgespacemult = Convert.ToInt16(numberconn / PUPPIGUISettings.maxConnPerSpace);
                //if (edgespacemult == 0) edgespacemult = 1;
                Point3D wta = new Point3D();

                //add at end, same y
                wta = new Point3D(region_perimeter.Location.X + region_perimeter.SizeX, region_perimeter.rectcenter().Y - PUPPIGUISettings.nodeSide * 0.5, 0);
                return wta;

            }
            //figures out where to push - if constrained=1,x ,if constrain=2,y
            Vector3D quaddir(Point3D baseposition, Point3D insertposition, int constrain)
            {
                Vector3D myquaddir = new Vector3D();
                Vector3D basevec = baseposition.ToVector3D();
                basevec.Negate();
                Vector3D invec = insertposition.ToVector3D();
                Vector3D dirvec = new Vector3D(invec.X + basevec.X, invec.Y + basevec.Y, 0);
                if (dirvec.Length == 0) return new Vector3D(1, 0, 0);
                dirvec.Normalize();
                //try 10-28-14 for blvds
                if ((Math.Abs(dirvec.X) >= Math.Abs(dirvec.Y) && constrain == 0) || constrain == 1)
                {
                    myquaddir = new Vector3D(Math.Sign(dirvec.X), 0, 0);
                }
                else if ((Math.Abs(dirvec.Y) > Math.Abs(dirvec.X) && constrain == 0) || constrain == 2)
                {
                    myquaddir = new Vector3D(0, Math.Sign(dirvec.Y), 0);
                }


                if (myquaddir.Length == 0)
                {
                    myquaddir = new Vector3D(1, 0, 0);
                }
                return myquaddir;
            }




            //gets the coordinate of a point based on matrix. this will be used for path finding
            internal void getmatrixcoord(Point3D mypoint, double divsize, out int myx, out int myy)
            {
                myx = -1;
                myy = -1;
                if (region_perimeter == null) return;
                int[,] mtx = null;
                if (occup_matrix == null || divsize != mydiv)
                {
                    getboxoccupancymatrix(out mtx, divsize);
                }
                if (occup_matrix == null) return;
                if (mypoint.isinsiderectangle(region_perimeter) == false) return;
                double locx = mypoint.X - region_perimeter.Location.X;
                double locy = mypoint.Y - region_perimeter.Location.Y;
                //centerize
                locx = locx.nodespacecenterconvert(divsize);
                locy = locy.nodespacecenterconvert(divsize);
                myx = Convert.ToInt32(Math.Floor(locx / divsize));
                myy = Convert.ToInt32(Math.Floor(locy / divsize));
            }
            //converts a point on the matrix to real coords (probably not the z )
            internal Point3D getrealcoord(int myx, int myy)
            {

                if (region_perimeter == null || occup_matrix == null || mydiv <= 0) return new Point3D(-999, -999, -999);


                double locx = (region_perimeter.Location.X + myx * mydiv).nodespacecenterconvert(mydiv);
                double locy = (region_perimeter.Location.Y + myy * mydiv).nodespacecenterconvert(mydiv);
                return new Point3D(locx, locy, 0);
            }
            //converts a point on the matrix to real coords (probably not the z )-lower left corner so we can displace as needed
            internal Point3D getllcornerrealcoord(int myx, int myy)
            {

                if (region_perimeter == null || occup_matrix == null || mydiv <= 0) return new Point3D(-999, -999, -999);


                double locx = (region_perimeter.Location.X + myx * mydiv);
                double locy = (region_perimeter.Location.Y + myy * mydiv);
                return new Point3D(locx, locy, 0);
            }






        }
        internal class connectorpath
        {
            internal List<Point3D> mybpts;
            //figures out a path for the connector arrow
            //make sure we don't get stuck
            internal int cococoindex = 0;
            static int movecounts;
            internal static bool noConnDrawnYet = true;
            internal HelixViewport3D testview;
            ModViz3DConn myconn;
            internal Point3D endpoint;
            internal Point3D startpoint;
            Point3D currentpoint;
            internal List<Vector3D> lineparts;
            Stack<Vector3D> lineprogress;
            Dictionary<string, ModViz3DNode> allnodes;
            //paths now needed for weaving though
            Dictionary<string, ModViz3DConn> allpaths;
            //these are for remembering to displace outbound connections from same output 
            int ydispint = 0;
            int zdispint = 0;
            int xdispint = 0;
            //in order to keep track of the occupancy matrices
            //nodes in connection sizing
            internal static int[,] nodeconnoccup;
            //number connections per spacing
            internal static int[,] hconncount;
            internal static int[,] vconncount;
            //a connection was drawn there during this cycle
            internal static int[,] HconnsWereDrawnHere;
            internal static int[,] VconnsWereDrawnHere;

            //areas that are completely blocked off by connections
            internal static int[,] hconnmaze;
            internal static int[,] vconnmaze;
            internal ModViz3DNode combase = null;
            //generates the connection matrices with 0s from the node matrix
            internal static void initialize_cmatrix(int[,] nodematrix, out int[,] connmatrix)
            {
                connmatrix = null;
                if (nodematrix == null) return;
                int xc = nodematrix.GetUpperBound(0) + 1;
                int yc = nodematrix.GetUpperBound(1) + 1;
                connmatrix = new int[xc, yc];

            }


            //entry point in current box
            Point3D bentryp;
            internal connectorpath(ModViz3DConn connectorrep, Dictionary<string, ModViz3DNode> stacks, Dictionary<string, ModViz3DConn> connpaths)
            {
                startpoint = new Point3D();
                endpoint = new Point3D();
                currentpoint = new Point3D();
                myconn = connectorrep;
                bentryp = new Point3D(-999, -999, -999);
                mybpts = new List<Point3D>();
                ModelVisual3D sviz = null;
                ModelVisual3D dviz = null;
                Point3D svizP = new Point3D();
                Point3D dvizP = new Point3D();
                Rect3D svizBB = new Rect3D();
                Rect3D dvizBB = new Rect3D();
                try
                {
                    //sviz = myconn.sourcenode.vizoutputs[myconn.sourceoutindex].myself;
                    svizP = myconn.sourcenode.vizoutputs[myconn.sourceoutindex].myPosition;
                    // dviz = myconn.destnode.vizinputs[myconn.destinindex].myself;
                    dvizP = myconn.destnode.vizinputs[myconn.destinindex].myPosition;
                    svizBB = myconn.sourcenode.vizoutputs[myconn.sourceoutindex].myBB;
                    dvizBB = myconn.destnode.vizinputs[myconn.destinindex].myBB;
                }
                catch (Exception exy)
                {
                    throw new Exception("Failed to retrieve connector nodes \n" + exy.ToString());
                }
                startpoint = svizP;
                //2d connections over nodes
                if (PUPPIGUISettings.connsCanIntersectNodes && PUPPIGUISettings.canvasMode == PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    //lower corner
                    startpoint.Offset(-PUPPIGUISettings.ioWidth * 0.5, 0, PUPPIGUISettings.ioHeight * 0.5 + PUPPIGUISettings.connRaise);

                }
                else
                {

                    //lower corner
                    startpoint.Offset(-PUPPIGUISettings.ioWidth * 0.5, -PUPPIGUISettings.ioLength * 0.5, -PUPPIGUISettings.ioHeight * 0.5);

                }
                //figures out more offsets based on number of outbound connections from this output
                int coindex = 0;
                try
                {
                    coindex = myconn.sourcenode.vizoutputs[myconn.sourceoutindex].outboundconns.IndexOf(connectorrep);
                    if (coindex == -1) coindex = myconn.sourcenode.vizoutputs[myconn.sourceoutindex].outboundconns.Count;
                }
                catch
                {

                }
                cococoindex = coindex;
                double ds = Math.Min(fastconstants.dds, PUPPIGUISettings.solidConnectionSize);
                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    //gets the spacing for lines

                    //gets how many fit in io
                    int yfit = (int)(PUPPIGUISettings.ioLength / ds);
                    int zfit = (int)(PUPPIGUISettings.ioHeight / ds);
                    //figures out where to offset to
                    int posindex = 0;
                    int remindex = Math.DivRem(coindex, yfit * zfit, out posindex);
                    ydispint = 0;
                    zdispint = 0;
                    ydispint = Math.DivRem(posindex, yfit, out zdispint);
                    //offsets based on number of conecetions
                    startpoint.Offset(0, ydispint * ds + PUPPIGUISettings.solidConnectionSize * 0.5, zdispint * ds + PUPPIGUISettings.solidConnectionSize * 0.5);
                }
                else
                {
                    //gets the spacing for lines

                    //gets how many fit in io
                    int yfit = (int)(PUPPIGUISettings.ioLength / ds);
                    int xfit = (int)((PUPPIGUISettings.nodeSpacing / 2 - PUPPIGUISettings.ioWidth / 2) / ds);
                    //figures out where to offset to
                    int posindex = 0;
                    int remindex = Math.DivRem(coindex, yfit * xfit, out posindex);
                    ydispint = 0;
                    xdispint = 0;
                    xdispint = Math.DivRem(posindex, xfit, out ydispint);
                    //offsets based on number of conecetions
                    startpoint.Offset(xdispint * ds + PUPPIGUISettings.solidConnectionSize * 0.5, ydispint * ds + PUPPIGUISettings.solidConnectionSize * 0.5, 0);

                }

                //pushes out

                //startpoint.Offset(PUPPIGUISettings.ioWidth , 0, 0);
                startpoint.Offset(PUPPIGUISettings.ioWidth, 0, 0);
                endpoint = dvizP; //dviz.Content.getboxcenter();
                // endpoint.Offset(-dvizBB.SizeX   * 0.5, 0, 0);
                endpoint.Offset(-PUPPIGUISettings.ioWidth * 0.5, 0, 0);

                currentpoint = startpoint;

                lineparts = new List<Vector3D>();

                lineprogress = new Stack<Vector3D>();
                allnodes = stacks;
                allpaths = connpaths;
            }
            //generates the line vectors to go from one place to the other
            internal bool findpath(out List<Point3D> connPoints)
            {
                mybpts = new List<Point3D>();
                connPoints = new List<Point3D>();
                bool bf = true;
                combase = myconn.getcommonbase();
                ModViz3DNode destbase = myconn.destnode.getroot();
                Vector3D go = new Vector3D();
                double ds = PUPPIGUISettings.nodeSpacing / (double)(PUPPIGUISettings.maxConnPerSpace + 1);
                ModViz3DNode sroot = myconn.sourcenode.getroot();

                int sourcestacktotalout = myconn.sourcenode.getstackoutputs();
                int deststacktotalin = myconn.destnode.getstackinputs();
                //part 1: while on building
                if (myconn.sourcenode.parent != null)
                {

                    //move out x+
                    //the ones below move more
                    go = new Vector3D((currentpoint.X + (sourcestacktotalout - myconn.sourcenode.getoutputindex(myconn.sourceoutindex) + 1) * ds).nodespacecenterconvert(ds) - currentpoint.X, 0, 0); ;
                    lineparts.Add(go);
                    currentpoint.Offset(go.X, go.Y, go.Z);



                    if (combase != null && combase.parent != null)
                    {
                        //move up y+
                        //max y between source and dest
                        double maxypad = Math.Max(myconn.sourcenode.boundingBox.Location.Y + myconn.sourcenode.boundingBox.SizeY, myconn.destnode.boundingBox.Location.Y + myconn.destnode.boundingBox.SizeY);
                        go = new Vector3D(0, (maxypad).nodespacecenterconvert(ds) + (myconn.sourcenode.getoutputindex(myconn.sourceoutindex) + ydispint) * ds - currentpoint.Y, 0); ;
                        lineparts.Add(go);
                        currentpoint.Offset(go.X, go.Y, go.Z);

                        //we are now on the same building
                        //go up or down
                        go = new Vector3D(0, 0, (myconn.destnode.vizinputs[myconn.destinindex].myPosition.Z - PUPPIGUISettings.ioHeight * 0.5 + Math.Min(zdispint * ds, PUPPIGUISettings.ioHeight)) - currentpoint.Z);
                        lineparts.Add(go);
                        currentpoint.Offset(go.X, go.Y, go.Z);

                        //we will move x- till we reach the input location edge, - input index
                        go = new Vector3D((myconn.destnode.vizinputs[myconn.destinindex].myPosition.X - PUPPIGUISettings.ioWidth * 0.5).nodespacecenterconvert(ds) - currentpoint.X - myconn.destinindex * ds, 0, 0);
                        lineparts.Add(go);
                        currentpoint.Offset(go.X, go.Y, go.Z);

                        //go down y - to the center of the input
                        //  go = new Vector3D(0, myconn.destnode.vizinputs[myconn.destinindex].myPosition.Y  - currentpoint.Y,  0);
                        go = new Vector3D(0, endpoint.Y - currentpoint.Y, 0);
                        lineparts.Add(go);
                        currentpoint.Offset(go.X, go.Y, go.Z);

                        //go x+ to the center of the input
                        // go = new Vector3D(myconn.destnode.vizinputs[myconn.destinindex].myPosition.X - currentpoint.X,0, 0);
                        go = new Vector3D(endpoint.X - currentpoint.X, 0, 0);
                        lineparts.Add(go);
                        currentpoint.Offset(go.X, go.Y, go.Z);
                        return bf;

                    }

                    //either the base is common or null common with destination



                    //check if we need to exit base
                    if (combase == null)
                    {
                        //move up y+
                        go = new Vector3D(0, (myconn.sourcenode.boundingBox.Location.Y + myconn.sourcenode.boundingBox.SizeY).nodespacecenterconvert(ds) + (myconn.sourcenode.getoutputindex(myconn.sourceoutindex) + ydispint + zdispint) * ds - currentpoint.Y, 0); ;
                        lineparts.Add(go);
                        currentpoint.Offset(go.X, go.Y, go.Z);


                        //go down to base
                        go = new Vector3D(0, 0, PUPPIGUISettings.nodeHeight + PUPPIGUISettings.connRaise + zdispint * ds - currentpoint.Z);
                        lineparts.Add(go);
                        currentpoint.Offset(go.X, go.Y, go.Z);

                        //simply go to the y+ end of the base+divsize*child index ( so that we don't dump on another line)

                        Point3D pexitop = new Point3D(currentpoint.X, (sroot.boundingBox.Location.Y + sroot.boundingBox.SizeY + ds * sroot.childs.IndexOf(myconn.sourcenode.getparentaboveroot()) + (ydispint + zdispint) * ds).nodespacecenterconvert(ds), currentpoint.Z);
                        go = new Vector3D(0, pexitop.Y - currentpoint.Y, 0); //-PUPPIGUISettings. // PUPPIGUISettings.ioHeight / 2));
                        lineparts.Add(go);
                        currentpoint.Offset(go.X, go.Y, go.Z);

                        //go down to ground
                        // go = new Vector3D(0, 0, -(PUPPIGUISettings.nodeHeight)); //-PUPPIGUISettings. // PUPPIGUISettings.ioHeight / 2));
                        go = new Vector3D(0, 0, -currentpoint.Z + PUPPIGUISettings.connRaise);
                        lineparts.Add(go);
                        currentpoint.Offset(go.X, go.Y, go.Z);
                        //if we need to go up

                        if (myconn.destnode != destbase)
                        {
                            //point to go to
                            Point3D wtt = new Point3D();
                            bf = findentry(destbase, myconn.destnode, myconn.destinindex, out wtt, out connPoints);
                            go = new Vector3D(0, 0, (PUPPIGUISettings.nodeHeight));
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);
                            //need to also move to where we wanna be inr elation to node on x axis
                            go = new Vector3D(wtt.X - currentpoint.X, 0, 0);
                            if (go.Length != 0)
                            {
                                lineparts.Add(go);
                                currentpoint.Offset(go.X, go.Y, go.Z);
                            }

                            //now move inside base, knowing we need to increase y cause we come from the bottom
                            //goes straight to connector
                            go = new Vector3D(0, myconn.destnode.vizinputs[myconn.destinindex].myPosition.Y - currentpoint.Y, 0);
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);


                            //go up
                            go = new Vector3D(0, 0, myconn.destnode.vizinputs[myconn.destinindex].myPosition.Z - currentpoint.Z);
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);

                        }
                        else
                        {
                            //goes straight to connector
                            Point3D mylo = new Point3D(((myconn.destnode.vizinputs[myconn.destinindex].myPosition.X - PUPPIGUISettings.ioWidth * 0.5) - ds * (myconn.destinindex + 1)).nodespacecenterconvert(ds), myconn.destnode.vizinputs[myconn.destinindex].myPosition.Y, PUPPIGUISettings.connRaise);

                            if (mylo.DistanceTo(currentpoint) < 5 * PUPPIGUISettings.nodeSpacing - (myconn.sourceoutindex + 1) * ds - 2 * PUPPIGUISettings.ioWidth * 0.5 - ds * (myconn.destinindex + 1))
                            {
                                //interpolate 

                                go = Point3D.Subtract(mylo, currentpoint);


                                //if (go.X > 0 && go.Y > 0)
                                //{

                                //    if (Math.Abs(go.X) > Math.Abs(go.Y))
                                //    {
                                //        double NX = 0.45 * go.X;
                                //        double NY = 0.5 * go.Y;
                                //        double NZ = 0.5 * go.Z;
                                //        lineparts.Add(new Vector3D(NX, NY, NZ));
                                //        currentpoint.Offset(NX, NY, NZ);
                                //        NX = 0.55 * go.X;
                                //        lineparts.Add(new Vector3D(NX, NY, NZ));
                                //        currentpoint.Offset(NX, NY, NZ);

                                //    }
                                //    else
                                //    {
                                //        double NX = 0.5 * go.X;
                                //        double NY = 0.45 * go.Y;
                                //        double NZ = 0.5 * go.Z;
                                //        lineparts.Add(new Vector3D(NX, NY, NZ));
                                //        currentpoint.Offset(NX, NY, NZ);
                                //        NY = 0.55 * go.Y;
                                //        lineparts.Add(new Vector3D(NX, NY, NZ));
                                //        currentpoint.Offset(NX, NY, NZ);
                                //    }
                                //}
                                //else if (go.X > 0 && go.Y < 0)
                                //{

                                //    if (Math.Abs(go.X) > Math.Abs(go.Y))
                                //    {
                                //        double NX = 0.45 * go.X;
                                //        double NY = 0.5 * go.Y;
                                //        double NZ = 0.5 * go.Z;
                                //        lineparts.Add(new Vector3D(NX, NY, NZ));
                                //        currentpoint.Offset(NX, NY, NZ);
                                //        NX = 0.55 * go.X;
                                //        lineparts.Add(new Vector3D(NX, NY, NZ));
                                //        currentpoint.Offset(NX, NY, NZ);

                                //    }
                                //    else
                                //    {
                                //        double NX = 0.5 * go.X;
                                //        double NY = 0.45 * go.Y;
                                //        double NZ = 0.5 * go.Z;
                                //        lineparts.Add(new Vector3D(NX, NY, NZ));
                                //        currentpoint.Offset(NX, NY, NZ);
                                //        NY = 0.55 * go.Y;
                                //        lineparts.Add(new Vector3D(NX, NY, NZ));
                                //        currentpoint.Offset(NX, NY, NZ);
                                //    }
                                //}
                                //if (go.X < 0 && go.Y > 0)
                                //{

                                //    if (Math.Abs(go.X) > Math.Abs(go.Y))
                                //    {
                                //        double NX = 0.35 * go.X;
                                //        double NY = 0.5 * go.Y;
                                //        double NZ = 0.5 * go.Z;
                                //        lineparts.Add(new Vector3D(NX, NY, NZ));
                                //        currentpoint.Offset(NX, NY, NZ);
                                //        NX = 0.65 * go.X;
                                //        lineparts.Add(new Vector3D(NX, NY, NZ));
                                //        currentpoint.Offset(NX, NY, NZ);

                                //    }
                                //    else
                                //    {
                                //        double NX = 0.5 * go.X;
                                //        double NY = 0.35 * go.Y;
                                //        double NZ = 0.5 * go.Z;
                                //        lineparts.Add(new Vector3D(NX, NY, NZ));
                                //        currentpoint.Offset(NX, NY, NZ);
                                //        NY = 0.65 * go.Y;
                                //        lineparts.Add(new Vector3D(NX, NY, NZ));
                                //        currentpoint.Offset(NX, NY, NZ);
                                //    }
                                //}
                                //else
                                //{
                                //    if (Math.Abs(go.X) > Math.Abs(go.Y))
                                //    {
                                //        double NX = 0.35 * go.X;
                                //        double NY = 0.5 * go.Y;
                                //        double NZ = 0.5 * go.Z;
                                //        lineparts.Add(new Vector3D(NX, NY, NZ));
                                //        currentpoint.Offset(NX, NY, NZ);
                                //        NX = 0.65 * go.X;
                                //        lineparts.Add(new Vector3D(NX, NY, NZ));
                                //        currentpoint.Offset(NX, NY, NZ);

                                //    }
                                //    else
                                //    {
                                //        double NX = 0.5 * go.X;
                                //        double NY = 0.35 * go.Y;
                                //        double NZ = 0.5 * go.Z;
                                //        lineparts.Add(new Vector3D(NX, NY, NZ));
                                //        currentpoint.Offset(NX, NY, NZ);
                                //        NY = 0.65 * go.Y;
                                //        lineparts.Add(new Vector3D(NX, NY, NZ));
                                //        currentpoint.Offset(NX, NY, NZ);
                                //    }
                                //}

                                if (Math.Abs(go.X) > Math.Abs(go.Y))
                                {
                                    double NX = 0.45 * go.X;
                                    double NY = 0.5 * go.Y;
                                    double NZ = 0.5 * go.Z;
                                    lineparts.Add(new Vector3D(NX, NY, NZ));
                                    currentpoint.Offset(NX, NY, NZ);
                                    NX = 0.55 * go.X;
                                    lineparts.Add(new Vector3D(NX, NY, NZ));
                                    currentpoint.Offset(NX, NY, NZ);

                                }
                                else
                                {
                                    double NX = 0.5 * go.X;
                                    double NY = 0.45 * go.Y;
                                    double NZ = 0.5 * go.Z;
                                    lineparts.Add(new Vector3D(NX, NY, NZ));
                                    currentpoint.Offset(NX, NY, NZ);
                                    NY = 0.55 * go.Y;
                                    lineparts.Add(new Vector3D(NX, NY, NZ));
                                    currentpoint.Offset(NX, NY, NZ);
                                }


                            }
                            else
                            {
                                bf = findlocation(mylo, out connPoints);
                            }


                            //go up
                            go = new Vector3D(0, 0, myconn.destnode.vizinputs[myconn.destinindex].myPosition.Z - currentpoint.Z);
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);

                        }



                    }
                    else
                    {

                        //so we share the base with the destination
                        //move up y+
                        //check if the boxes are adjacent
                        bool adjright = false;
                        bool adjleft = false;
                        //last child 0
                        int sbindex = -10;
                        try
                        {
                            sbindex = myconn.sourcenode.getparentaboveroot().baseindex;
                        }
                        catch
                        {

                        }
                        int dbindex = -20;


                        try
                        {
                            if (myconn.destnode != combase)
                            {

                                dbindex = myconn.destnode.getparentaboveroot().baseindex;
                                if (dbindex == sbindex + 1) adjleft = true;
                                if (dbindex == sbindex - 1) adjright = true;
                            }
                        }
                        catch
                        {

                        }



                        //based on the input index of the destination node plus the biggest box

                        if (adjleft == false && adjright == false)
                        {
                            double boxmaxy = combase.getmaxychilds();
                            go = new Vector3D(0, (boxmaxy + (myconn.destinindex + 1 + ydispint) * ds).nodespacecenterconvert(ds) - currentpoint.Y, 0); ;
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);
                        }
                        else if (adjright == true)
                        {
                            double maxypad = Math.Max(myconn.sourcenode.boundingBox.Location.Y + myconn.sourcenode.boundingBox.SizeY, myconn.destnode.boundingBox.Location.Y + myconn.destnode.boundingBox.SizeY);
                            go = new Vector3D(0, (maxypad + (myconn.destinindex + 1 + ydispint) * ds).nodespacecenterconvert(ds) - currentpoint.Y, 0); ;
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);
                        }

                        // the input is not on the root
                        if (myconn.destnode != combase)
                        {


                            //we try to create an unique position for the connector so use a proportion of baseindex for source and dest
                            int sindex = sbindex + dbindex;
                            double zdist2go = myconn.destnode.vizinputs[myconn.destinindex].myPosition.Z - currentpoint.Z;
                            double ud = 0;
                            //make sure going in opposite directions don't overlap

                            if (sbindex > dbindex) ud = zdist2go / (double)PUPPIGUISettings.maxConnPerSpace; else ud = -zdist2go / (double)PUPPIGUISettings.maxConnPerSpace;

                            //go up or down
                            go = new Vector3D(0, 0, ((double)sbindex / (double)sindex) * zdist2go + ud);
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);

                            //need to get to a good point and then go to connector
                            //also go up and down half way depending on direction
                            Point3D cp = currentpoint;
                            double dist = ((myconn.destnode.vizinputs[myconn.destinindex].myPosition.X - PUPPIGUISettings.ioWidth * 0.5) - ds * (myconn.destinindex + 1)).nodespacecenterconvert(ds) - currentpoint.X;
                            go = new Vector3D(dist, 0, ud);
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);

                            //go = new Vector3D(dist * 0.5, 0, -ud);
                            //lineparts.Add(go);
                            //currentpoint.Offset(go.X, go.Y, go.Z);

                            //go up or down
                            go = new Vector3D(0, 0, ((double)dbindex / (double)sindex) * zdist2go - ud);
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);

                            //((myconn.destnode.vizinputs[myconn.destinindex].myPosition.Y-PUPPIGUISettings.ioLength*0.5) + ds * myconn.sourcenode.getinputindex(myconn.destinindex    )).nodespacecenterconvert(ds)

                            //go to connector y
                            go = new Vector3D(0, myconn.destnode.vizinputs[myconn.destinindex].myPosition.Y - currentpoint.Y, 0);
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);
                        }
                        else
                        {
                            //go up or down
                            go = new Vector3D(0, 0, PUPPIGUISettings.nodeHeight + PUPPIGUISettings.connRaise - currentpoint.Z);
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);

                            //need to get to a good point and then go to connector

                            go = new Vector3D((combase.boundingBox.Location.X + ds * (myconn.destinindex + 1)).nodespacecenterconvert(ds) - currentpoint.X, 0, 0);
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);


                            //go to connector y
                            go = new Vector3D(0, myconn.destnode.vizinputs[myconn.destinindex].myPosition.Y - currentpoint.Y, 0);
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);

                            //go to connector x
                            go = new Vector3D(myconn.destnode.vizinputs[myconn.destinindex].myPosition.X - currentpoint.X, 0, 0);
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);
                            //go down to connector center
                            go = new Vector3D(0, 0, myconn.destnode.vizinputs[myconn.destinindex].myPosition.Z - currentpoint.Z);
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);
                        }

                    }
                }
                else
                {
                    //this is from a connector on base

                    //move out x+

                    go = new Vector3D((currentpoint.X + (myconn.sourceoutindex + 1) * ds).nodespacecenterconvert(ds) - currentpoint.X, 0, 0); ;
                    lineparts.Add(go);
                    currentpoint.Offset(go.X, go.Y, go.Z);
                    if (combase == null)
                    {
                        go = new Vector3D(0, 0, PUPPIGUISettings.connRaise - currentpoint.Z); //-PUPPIGUISettings. // PUPPIGUISettings.ioHeight / 2));
                        lineparts.Add(go);
                        currentpoint.Offset(go.X, go.Y, go.Z);
                        //if we need to go up

                        if (myconn.destnode != destbase)
                        {
                            Point3D wtt = new Point3D();
                            bf = findentry(destbase, myconn.destnode, myconn.destinindex, out wtt, out connPoints);
                            go = new Vector3D(0, 0, (PUPPIGUISettings.nodeHeight));
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);

                            //need to also move to where we wanna be inr elation to node on x axis
                            go = new Vector3D(wtt.X - currentpoint.X, 0, 0);
                            if (go.Length != 0)
                            {
                                lineparts.Add(go);
                                currentpoint.Offset(go.X, go.Y, go.Z);
                            }
                            //now move inside base, knowing we need to increase y cause we come from the bottom
                            //goes straight to connector
                            go = new Vector3D(0, myconn.destnode.vizinputs[myconn.destinindex].myPosition.Y - currentpoint.Y, 0);
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);


                            //go up
                            go = new Vector3D(0, 0, myconn.destnode.vizinputs[myconn.destinindex].myPosition.Z - currentpoint.Z);
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);

                        }
                        else
                        {
                            //goes straight to connector
                            //Point3D mylo = new Point3D(((myconn.destnode.vizinputs[myconn.destinindex].myPosition.X-PUPPIGUISettings.ioWidth*0.5) - ds * (myconn.destinindex + 1)).nodespacecenterconvert(ds), myconn.destnode.vizinputs[myconn.destinindex].myPosition.Y, PUPPIGUISettings.connRaise);
                            //now with custom nodes needs to go to default place

                            Point3D mylo = new Point3D((myconn.destnode.vizinputs[myconn.destinindex].myPosition.X - PUPPIGUISettings.ioWidth * 0.5 - ds * (myconn.destinindex + 1)).nodespacecenterconvert(ds), myconn.destnode.vizinputs[myconn.destinindex].myPosition.Y, PUPPIGUISettings.connRaise);
                            //if small distance we know there are no nodes inbetween
                            if (mylo.DistanceTo(currentpoint) < 5 * PUPPIGUISettings.nodeSpacing - (myconn.sourceoutindex + 1) * ds - 2 * PUPPIGUISettings.ioWidth * 0.5 - ds * (myconn.destinindex + 1))
                            {
                                //interpolate 

                                go = Point3D.Subtract(mylo, currentpoint);
                                if (Math.Abs(go.X) > Math.Abs(go.Y))
                                {
                                    double NX = 0.45 * go.X;
                                    double NY = 0.5 * go.Y;
                                    double NZ = 0.5 * go.Z;
                                    lineparts.Add(new Vector3D(NX, NY, NZ));
                                    currentpoint.Offset(NX, NY, NZ);
                                    NX = 0.55 * go.X;
                                    lineparts.Add(new Vector3D(NX, NY, NZ));
                                    currentpoint.Offset(NX, NY, NZ);

                                }
                                else
                                {
                                    double NX = 0.5 * go.X;
                                    double NY = 0.45 * go.Y;
                                    double NZ = 0.5 * go.Z;
                                    lineparts.Add(new Vector3D(NX, NY, NZ));
                                    currentpoint.Offset(NX, NY, NZ);
                                    NY = 0.55 * go.Y;
                                    lineparts.Add(new Vector3D(NX, NY, NZ));
                                    currentpoint.Offset(NX, NY, NZ);
                                }
                                //go = Point3D.Subtract(mylo, currentpoint);
                                //lineparts.Add(go);
                                //currentpoint.Offset(go.X, go.Y, go.Z);
                            }
                            else
                            {

                                //make sure we don't go too far down
                                //if (mylo.Y-mylo.Y.nodespaceconvert() >(mylo.Y+PUPPIGUISettings.nodeSpacing).nodespaceconvert()-mylo.Y)
                                //{
                                //    mylo.Y = (mylo.Y + PUPPIGUISettings.nodeSpacing).nodespaceconvert();
                                //}
                                bf = findlocation(mylo, out connPoints);
                            }
                            //go up
                            //go = new Vector3D(0, 0, myconn.destnode.vizinputs[myconn.destinindex].myPosition.Z - currentpoint.Z);
                            go = new Vector3D(0, 0, myconn.destnode.vizinputs[myconn.destinindex].myPosition.Z - currentpoint.Z);
                            lineparts.Add(go);
                            currentpoint.Offset(go.X, go.Y, go.Z);

                        }

                    }
                    else
                    {

                        //now moves up
                        go = new Vector3D(0, 0, PUPPIGUISettings.nodeHeight + PUPPIGUISettings.connRaise - currentpoint.Z);
                        lineparts.Add(go);
                        currentpoint.Offset(go.X, go.Y, go.Z);
                        //move back in, as a function of the output index so we don't have things on top of each other
                        go = new Vector3D((myconn.sourcenode.boundingBox.Location.X + myconn.sourcenode.boundingBox.SizeX - ds * (myconn.sourceoutindex + 1)).nodespacecenterconvert(ds) - currentpoint.X, 0, 0);
                        lineparts.Add(go);
                        currentpoint.Offset(go.X, go.Y, go.Z);
                        //move to bottom most box on same base y
                        go = new Vector3D(0, myconn.sourcenode.getminychilds() - ds * (myconn.destinindex + 1) - currentpoint.Y, 0);
                        lineparts.Add(go);
                        currentpoint.Offset(go.X, go.Y, go.Z);
                        //move towards input
                        int totaldestins = myconn.destnode.getstackinputs();
                        int destind = myconn.destnode.getinputindex(myconn.destinindex);
                        go = new Vector3D((myconn.destnode.boundingBox.Location.X - PUPPIGUISettings.ioWidth * 0.5 - ds * (totaldestins - destind)).nodespacecenterconvert(ds) - currentpoint.X, 0, 0);
                        lineparts.Add(go);
                        currentpoint.Offset(go.X, go.Y, go.Z);
                        //go up
                        go = new Vector3D(0, 0, myconn.destnode.vizinputs[myconn.destinindex].myPosition.Z - currentpoint.Z);
                        lineparts.Add(go);
                        currentpoint.Offset(go.X, go.Y, go.Z);
                        //go to connector y
                        go = new Vector3D(0, myconn.destnode.vizinputs[myconn.destinindex].myPosition.Y - currentpoint.Y, 0);
                        lineparts.Add(go);
                        currentpoint.Offset(go.X, go.Y, go.Z);

                    }

                }


                go = Point3D.Subtract(endpoint, currentpoint);
                lineparts.Add(go);
                foreach (Point3D ppp in connPoints)
                {
                    mybpts.Add(ppp);
                }
                return bf;
            }

            #region oldmazepoint

            ////gets the box on which both the start point and the end point are sitting, if any. Multiple levels

            ////uses maze function to move to a point. this is used for entry as well as connector move
            //internal void mazepoint(d2collisionmodel basemaze, d2collisionmodel prevhconns, d2collisionmodel prevvconns, Point3D destination, double spacing, out Vector3D[] movearray)
            //{
            //    movearray = null;
            //    int xdest = -1;
            //    int ydest = -1;
            //    int[,] occmat;
            //    int[,] hcoccmat;
            //    int[,] vcoccmat;
            //    //get the previous connections matrix with the number of connections found on each spot
            //    basemaze.getprevconnoccupancymatrix(prevhconns, out hcoccmat, spacing);
            //    basemaze.getprevconnoccupancymatrix(prevvconns, out vcoccmat, spacing);
            //    //gets the occupancy matrix for connections, this is just with nodes for maze
            //    basemaze.getconoccupancymatrix(out occmat, spacing);
            //    if (occmat == null) return;
            //    int curposx = -1;
            //    int curposy = -1;
            //    basemaze.getmatrixcoord(currentpoint, spacing, out curposx, out curposy);
            //    basemaze.getmatrixcoord(destination, spacing, out xdest, out ydest);
            //    //if already there then exit
            //    //if invalid coords then exit
            //    if ((xdest == -1 || ydest == -1) || (xdest == curposx && ydest == curposy) || (curposx == -1 || curposy == -1))
            //    {
            //        return;
            //    }
            //    //compares matrices
            //    int[,] updatedhmat;
            //    int[,] updatedvmat;
            //    basemaze.updatewithconns(occmat, hcoccmat, out updatedhmat);
            //    basemaze.updatewithconns(occmat, vcoccmat, out updatedvmat);

            //    // MazeSolver bmaze = new MazeSolver(toccmat);
            //    MazeSolver bmaze = new MazeSolver(occmat, updatedhmat, updatedvmat);
            //    int[,] foundpath = bmaze.FindPath(curposy, curposx, ydest, xdest);
            //    if (foundpath == null) return;
            //    //movearray = new Vector3D[bmaze.xindex.Count - 1];

            //    //go though found positions and add them to stack
            //    //we go in reverse
            //    int pindex = 0;
            //    int fymaze = Convert.ToInt32(bmaze.xindex[pindex]);
            //    int fxmaze = Convert.ToInt32(bmaze.yindex[pindex]);
            //    Point3D firstpos = basemaze.getllcornerrealcoord(fxmaze, fymaze);
            //    //move inside to cover with  conn
            //    firstpos.Offset(PUPPIGUISettings.solidConnectionSize * 0.5, PUPPIGUISettings.solidConnectionSize * 0.5, 0);

            //    firstpos.Z = currentpoint.Z;

            //    //we dump all the moves in an arraylist in order to not have a fixed number and be able to convert all
            //    List<Vector3D> allmoves = new List<Vector3D>();
            //    //move there
            //    allmoves.Add(new Vector3D(firstpos.X - currentpoint.X, firstpos.Y - currentpoint.Y, 0));
            //    //connector pipe lines to vertical and horizontal
            //    for (pindex = 1; pindex < bmaze.xindex.Count; pindex++)
            //    {
            //        int symaze = Convert.ToInt32(bmaze.xindex[pindex]);
            //        int sxmaze = Convert.ToInt32(bmaze.yindex[pindex]);
            //        Point3D secpos = basemaze.getllcornerrealcoord(sxmaze, symaze);
            //        secpos.Offset(PUPPIGUISettings.solidConnectionSize * 0.5, PUPPIGUISettings.solidConnectionSize * 0.5, 0);
            //        secpos.Z = currentpoint.Z;

            //        //decide how to offset (vertical or horizontal)
            //        int avgoffset = 0;
            //        // if (Math.Abs(firstpos.Y-secpos.Y)<PUPPIGUISettings.collinearToler   )
            //        if (fymaze == symaze)
            //        {
            //            //horizontal
            //            avgoffset = Math.Max(hcoccmat[fymaze, fxmaze], hcoccmat[symaze, sxmaze]);
            //            //firstpos.Offset(0, spacing / PUPPIGUISettings.maxConnPerSpace * avgoffset, 0);
            //            secpos.Offset(0, spacing / PUPPIGUISettings.maxConnPerSpace * avgoffset, 0);
            //        }
            //        else
            //        {
            //            avgoffset = Math.Max(vcoccmat[fymaze, fxmaze], vcoccmat[symaze, sxmaze]);
            //            //firstpos.Offset(spacing / PUPPIGUISettings.maxConnPerSpace * avgoffset,0, 0);
            //            secpos.Offset(spacing / PUPPIGUISettings.maxConnPerSpace * avgoffset, 0, 0);
            //        }
            //        Vector3D mvector = Vector3D.Subtract(secpos.ToVector3D(), firstpos.ToVector3D());
            //        if (Math.Abs(mvector.X) > PUPPIGUISettings.collinearToler && Math.Abs(mvector.Y) > PUPPIGUISettings.collinearToler)
            //        {
            //            allmoves.Add(new Vector3D(mvector.X, 0, 0));
            //            allmoves.Add(new Vector3D(0, mvector.Y, 0));

            //        }
            //        else
            //        {
            //            allmoves.Add(mvector);
            //        }


            //        firstpos = new Point3D(secpos.X, secpos.Y, currentpoint.Z);
            //        fxmaze = sxmaze;
            //        fymaze = symaze;
            //    }
            //    movearray = allmoves.ToArray();
            //}
            #endregion
            //uses maze function to move to a point. this is used for entry as well as connector move
            internal List<Point3D> mazepoint(d2collisionmodel basemaze, Point3D destination, double spacing, out Vector3D[] movearray)
            {
                List<Point3D> pl = new List<Point3D>();



                movearray = null;
                if (PUPPIGUISettings.connsCanIntersectNodes) return pl;
                int xdest = -1;
                int ydest = -1;

                //so we don't divide too much, it is slower
                double ds = spacing / (double)(PUPPIGUISettings.maxConnPerSpace + 1);
                if (connectorpath.nodeconnoccup == null) return pl;
                int curposx = -1;
                int curposy = -1;
                basemaze.getmatrixcoord(currentpoint, spacing, out curposx, out curposy);
                basemaze.getmatrixcoord(destination, spacing, out xdest, out ydest);
                //if already there then exit
                //if invalid coords then exit
                if ((xdest == -1 || ydest == -1) || (xdest == curposx && ydest == curposy) || (curposx == -1 || curposy == -1))
                {
                    return pl;
                }


                MazeSolver bmaze = new MazeSolver(connectorpath.nodeconnoccup, connectorpath.hconnmaze, connectorpath.vconnmaze);
                int[,] foundpath = bmaze.FindPath(curposy, curposx, ydest, xdest);
                if (foundpath == null) return pl;
                //go though found positions and add them to stack
                //we go in reverse
                int pindex = 0;
                int fymaze = Convert.ToInt32(bmaze.xindex[pindex]);// +truncrowstart;
                int fxmaze = Convert.ToInt32(bmaze.yindex[pindex]);// +trunccolstart;
                Point3D firstpos = basemaze.getllcornerrealcoord(fxmaze, fymaze);
                //thrird dimension used as flag
                //Z=0 is corner
                //Z=1 is horizontal
                //Z=2 is vertical
                //Z=3 is disregard (start and end)
                pl.Add(new Point3D(firstpos.X, firstpos.Y, 3));
                //move inside to cover with  conn
                //move to middle
                int mid = Convert.ToInt16(Math.Ceiling(PUPPIGUISettings.maxConnPerSpace * 0.5));
                int avgoffset = 0;
                //sneak connections > max count in between
                double addex = 0;
                avgoffset = connectorpath.hconncount[fymaze, fxmaze];
                if (avgoffset > PUPPIGUISettings.maxConnPerSpace)
                {
                    avgoffset = avgoffset - PUPPIGUISettings.maxConnPerSpace;
                    addex = ds * 0.5;
                }
                else
                {
                    addex = 0;
                }
                int r2 = 0;
                int d2 = 0;
                d2 = Math.DivRem(PUPPIGUISettings.maxConnPerSpace + 1, 2, out r2);


                double fho = addex + (mid + r2) * ds + ds * Math.Pow(-1, avgoffset) * Math.Ceiling(avgoffset * 0.5);
                avgoffset = connectorpath.vconncount[fymaze, fxmaze];
                if (avgoffset > PUPPIGUISettings.maxConnPerSpace)
                {
                    avgoffset = avgoffset - PUPPIGUISettings.maxConnPerSpace;
                    addex = ds * 0.5;
                }
                else
                {
                    addex = 0;
                }
                double fve = addex + (mid + r2) * ds + ds * Math.Pow(-1, avgoffset) * Math.Ceiling(avgoffset * 0.5);
                firstpos.Z = currentpoint.Z;
                firstpos.Offset(fve, fho, 0);
                //we dump all the moves in an arraylist in order to not have a fixed number and be able to convert all
                List<Vector3D> allmoves = new List<Vector3D>();
                //move there
                Vector3D vai = new Vector3D(firstpos.X - currentpoint.X, firstpos.Y - currentpoint.Y, 0);

                if (vai.Length < PUPPIGUISettings.roundedConnRadius)
                {
                    firstpos = currentpoint;
                }
                else
                {
                    allmoves.Add(new Vector3D(firstpos.X - currentpoint.X, firstpos.Y - currentpoint.Y, 0));
                }

                //keep track of how much last was displaced
                double lox = 0;
                double loy = 0;
                bool prevert = false;
                for (pindex = 1; pindex < bmaze.xindex.Count; pindex++)
                {
                    int symaze = Convert.ToInt32(bmaze.xindex[pindex]);// +truncrowstart;
                    int sxmaze = Convert.ToInt32(bmaze.yindex[pindex]);// +trunccolstart;
                    Point3D secpos = basemaze.getllcornerrealcoord(sxmaze, symaze);
                    secpos.Z = currentpoint.Z;

                    //decide how to offset (vertical or horizontal)
                    avgoffset = 0;

                    if (fymaze == symaze)
                    {
                        //horizontal


                        //avgoffset = Convert.ToInt16(0.5 * (connectorpath.hconncount[symaze, sxmaze] + connectorpath.hconncount[fymaze, fxmaze]));
                        avgoffset = connectorpath.hconncount[symaze, sxmaze];
                        if (avgoffset > PUPPIGUISettings.maxConnPerSpace)
                        {
                            avgoffset = avgoffset - PUPPIGUISettings.maxConnPerSpace;
                            addex = ds * 0.5;
                        }
                        else
                        {
                            addex = 0;
                        }

                        //don't do the very end
                        if (pindex < bmaze.xindex.Count - 1)
                        {

                            if (PUPPIGUISettings.useMultiThreading)
                            {
                                //try threading
                                Interlocked.Increment(ref connectorpath.hconncount[symaze, sxmaze]);
                                Interlocked.Exchange(ref connectorpath.HconnsWereDrawnHere[symaze, sxmaze], 1);
                                if (Interlocked.Equals(connectorpath.hconncount[symaze, sxmaze], PUPPIGUISettings.maxConnPerSpace))
                                {
                                    //leave blank above nodes for 3d exits
                                    if (symaze > 0)
                                    {
                                        if (Interlocked.Equals(connectorpath.hconnmaze[symaze - 1, sxmaze], 0))
                                            Interlocked.Exchange(ref connectorpath.hconnmaze[symaze, sxmaze], 1);
                                    }
                                    else
                                    {
                                        Interlocked.Exchange(ref connectorpath.hconnmaze[symaze, sxmaze], 1);
                                    }

                                }
                            }
                            else
                            {

                                connectorpath.hconncount[symaze, sxmaze]++;
                                connectorpath.HconnsWereDrawnHere[symaze, sxmaze] = 1;
                                if (connectorpath.hconncount[symaze, sxmaze] == PUPPIGUISettings.maxConnPerSpace)
                                {
                                    //leave blank above nodes for 3d exits
                                    if (symaze > 0)
                                    {
                                        if (connectorpath.hconnmaze[symaze - 1, sxmaze] == 0)
                                            connectorpath.hconnmaze[symaze, sxmaze] = 1;
                                    }
                                    else
                                    {
                                        connectorpath.hconnmaze[symaze, sxmaze] = 1;
                                    }

                                }

                            }



                        }
                        if (!prevert) lox = 0;

                        secpos.Offset(mid * ds + lox, addex + (mid + r2) * ds + ds * Math.Pow(-1, avgoffset) * Math.Ceiling(avgoffset * 0.5), 0);
                        loy = addex + (mid + r2) * ds + ds * Math.Pow(-1, avgoffset) * Math.Ceiling(avgoffset * 0.5) - mid * ds;
                        prevert = false;
                        if (pindex < bmaze.xindex.Count - 1)
                        {

                            pl.Add(new Point3D(secpos.X, secpos.Y, 1));
                        }
                    }
                    else
                    {
                        //avgoffset = Convert.ToInt16(0.5 * (connectorpath.vconncount[symaze, sxmaze] + connectorpath.vconncount[fymaze, fxmaze]));
                        avgoffset = connectorpath.vconncount[symaze, sxmaze];
                        if (avgoffset > PUPPIGUISettings.maxConnPerSpace)
                        {
                            avgoffset = avgoffset - PUPPIGUISettings.maxConnPerSpace;
                            addex = ds * 0.5;
                        }
                        else
                        {
                            addex = 0;
                        }
                        //update connector matrix
                        //don't do the very end
                        if (pindex < bmaze.xindex.Count - 1)
                        {
                            if (PUPPIGUISettings.useMultiThreading)
                            {
                                //try threading
                                Interlocked.Increment(ref connectorpath.vconncount[symaze, sxmaze]);
                                Interlocked.Exchange(ref connectorpath.VconnsWereDrawnHere[symaze, sxmaze], 1);
                                if (Interlocked.Equals(connectorpath.vconncount[symaze, sxmaze], PUPPIGUISettings.maxConnPerSpace))
                                {
                                    //leave blank above nodes for 3d exits
                                    if (symaze > 0)
                                    {
                                        if (Interlocked.Equals(connectorpath.vconnmaze[symaze - 1, sxmaze], 0))
                                            Interlocked.Exchange(ref connectorpath.vconnmaze[symaze, sxmaze], 1);
                                    }
                                    else
                                    {
                                        Interlocked.Exchange(ref connectorpath.vconnmaze[symaze, sxmaze], 1);
                                    }

                                }
                            }
                            else
                            {

                                connectorpath.vconncount[symaze, sxmaze]++;
                                connectorpath.VconnsWereDrawnHere[symaze, sxmaze] = 1;
                                if (connectorpath.vconncount[symaze, sxmaze] == PUPPIGUISettings.maxConnPerSpace)
                                {
                                    //leave blank above nodes for 3d exits
                                    if (symaze > 0)
                                    {
                                        if (connectorpath.vconnmaze[symaze - 1, sxmaze] == 0)
                                            connectorpath.vconnmaze[symaze, sxmaze] = 1;
                                    }
                                    else
                                    {
                                        connectorpath.vconnmaze[symaze, sxmaze] = 1;
                                    }

                                }

                            }


                        }
                        if (prevert) loy = 0;
                        secpos.Offset(addex + (mid + r2) * ds + ds * Math.Pow(-1, avgoffset) * Math.Ceiling(avgoffset * 0.5), mid * ds + loy, 0);
                        lox = addex + (mid + r2) * ds + ds * Math.Pow(-1, avgoffset) * Math.Ceiling(avgoffset * 0.5) - mid * ds;
                        prevert = true;
                        if (pindex < bmaze.xindex.Count - 1)
                        {

                            pl.Add(new Point3D(secpos.X, secpos.Y, 2));
                        }
                    }
                    Vector3D mvector = Vector3D.Subtract(secpos.ToVector3D(), firstpos.ToVector3D());
                    //make nice corners
                    if (Math.Abs(mvector.X) > PUPPIGUISettings.collinearToler && Math.Abs(mvector.Y) > PUPPIGUISettings.collinearToler)
                    {


                        if (allmoves.Count > 1)
                        {
                            Vector3D p1 = allmoves[allmoves.Count - 1];
                            Vector3D p2 = allmoves[allmoves.Count - 2];

                            if (Math.Abs(p1.X) > 0)
                            {



                                allmoves.Add(new Vector3D(mvector.X, 0, 0));
                                allmoves.Add(new Vector3D(0, mvector.Y, 0));
                            }
                            else
                            {

                                allmoves.Add(new Vector3D(0, mvector.Y, 0));
                                allmoves.Add(new Vector3D(mvector.X, 0, 0));

                            }



                        }
                        else
                        {
                            allmoves.Add(new Vector3D(mvector.X, 0, 0));
                            allmoves.Add(new Vector3D(0, mvector.Y, 0));
                        }



                    }
                    else
                    {
                        allmoves.Add(mvector);
                        //if (Math.Abs(mvector.X) > PUPPIGUISettings.collinearToler); 
                    }


                    firstpos = new Point3D(secpos.X, secpos.Y, currentpoint.Z);
                    fxmaze = sxmaze;
                    fymaze = symaze;
                }
                //last one, again not counted
                pl.Add(new Point3D(firstpos.X, firstpos.Y, 3));
                movearray = allmoves.ToArray();
                return pl;
            }

            //function to gnerate mtrix range
            int[,] mrange_parallel(int[,] sourcematrix, int rs, int cs, int re, int ce)
            {
                if (rs > re || cs > ce || sourcematrix == null) return null;
                if (rs < 0 || cs < 0 || re > sourcematrix.GetUpperBound(0) || ce > sourcematrix.GetUpperBound(1)) return null;
                int[,] retmat = new int[re - rs + 1, ce - cs + 1];
                //use parallel for loops to populate
                Parallel.For(0, re - rs + 1, rowmat =>
                    {
                        Parallel.For(0, ce - cs + 1, colmat =>
                            {
                                retmat[rowmat, colmat] = sourcematrix[rs + rowmat, cs + colmat];
                            });
                    });
                return retmat;
            }


            //figures out how to go on top of a box without hitting other boxes on top right away, connectors modules etc
            internal bool findentry(ModViz3DNode destbox, ModViz3DNode destnode, int destinindex, out Point3D wt, out List<Point3D> pList)
            {


                pList = new List<Point3D>();

                int totaldestins = destnode.getstackinputs();
                int destind = destnode.getinputindex(destinindex);

                //find the point to head to

                double ds = PUPPIGUISettings.nodeSpacing / (double)(PUPPIGUISettings.maxConnPerSpace + 1);
                Point3D whereto = new Point3D((destnode.boundingBox.Location.X - PUPPIGUISettings.ioWidth * 0.5 - ds * (totaldestins - destind)).nodespacecenterconvert(ds), (destbox.boundingBox.Location.Y - ds).nodespacecenterconvert(ds), destbox.boundingBox.Location.Z);
                bool bf = findlocation(whereto, out pList);

                wt = whereto;
                return bf;
            }

            #region oldfindlocation
            //internal void findlocation(Point3D loc)
            //{


            //    double ds = PUPPIGUISettings.nodeSpacing / (double)(PUPPIGUISettings.maxConnPerSpace + 1);

            //    d2collisionmodel levelmap = new d2collisionmodel();

            //    double basez = 0;

            //    int basenumconn = 0;
            //    //add stack roots
            //    Point3D whereto = new Point3D(loc.X.nodespacecenterconvert(ds), loc.Y.nodespacecenterconvert(ds), loc.Z);
            //    //we need to create a region where we will do our mazing
            //    double minx = Math.Min(currentpoint.X, loc.X) - 2 * PUPPIGUISettings.nodeSpacing;
            //    double maxx = Math.Max(currentpoint.X, loc.X) + 2 * PUPPIGUISettings.nodeSpacing;
            //    double sizex = maxx - minx;

            //    Rect3D sliceme = new Rect3D(minx, -30000, 0, sizex, 60000, PUPPIGUISettings.nodeHeight);
            //    List<Rect3D> leftovers = new List<Rect3D>();
            //    foreach (ModViz3DNode mn in allnodes.Values)
            //    {

            //        if (mn.parent == null)
            //        {
            //            if (mn.myself != null)
            //            {
            //                //only points within
            //                if (mn.myself.Content.Bounds.IntersectsWith(sliceme))
            //                {
            //                    levelmap.footprints.Add(mn.myself.Content.Bounds);
            //                    basenumconn += Math.Max(mn.vizinputs.Count, mn.vizoutputs.Count) + mn.numconn;
            //                }
            //                //need to add the others to a new array
            //                else
            //                {
            //                    leftovers.Add(mn.myself.Content.Bounds);
            //                }

            //            }
            //        }
            //    }
            //    levelmap.recalculate_perimeter();
            //    //need to leave extra space for connecting lines
            //    int edgespacemult = Convert.ToInt16(basenumconn) / PUPPIGUISettings.maxConnPerSpace;
            //    if (edgespacemult == 0) edgespacemult = 1;
            //    levelmap.region_perimeter = levelmap.region_perimeter.padme(edgespacemult * PUPPIGUISettings.nodeSpacing);
            //    //but now we also need to check the leftovers cause some might be partly intersecting this
            //    foreach (Rect3D rere in leftovers)
            //    {
            //        Rect3D myint = Rect3D.Intersect(levelmap.region_perimeter, rere);
            //        if (myint.SizeX > 0)
            //        {
            //            levelmap.footprints.Add(myint);
            //        }
            //    }

            //    basez = 0;

            //    //add the connection line rectangles, horizontal and vertical in xy
            //    d2collisionmodel connecthmap = new d2collisionmodel();
            //    d2collisionmodel connectvmap = new d2collisionmodel();
            //    //when updating existing connections, will only go up to its index 
            //    //this way the connection occupancy matrix gets updated as they are populated
            //    List<ModViz3DConn> econlist = allpaths.Values.ToList();
            //    int mycindex = econlist.IndexOf(myconn);
            //    if (mycindex <= -1)
            //    {
            //        //not found
            //        mycindex = econlist.Count - 1;
            //    }
            //    else
            //    {
            //        //only go up to this one not included
            //        mycindex--;
            //    }
            //    for (int lc = 0; lc <= mycindex; lc++)
            //    {
            //        ModViz3DConn mvcc = econlist[lc];

            //        if (mvcc != null && mvcc != myconn)
            //        {
            //            int pcnt = 0;
            //            for (pcnt = 0; pcnt < mvcc.allconnlines.Count; pcnt++)
            //            {
            //                connoccup ccon = mvcc.allconnlines[pcnt];
            //                //if (pcnt % PUPPIGUISettings.skipconns == 0)
            //                //{
            //                //Rect3D pathpoint = new Rect3D(ccon.poscenter.X - (PUPPIGUISettings.nodeSpacing / (PUPPIGUISettings.maxConnPerSpace + 1) / 2), ccon.poscenter.Y - (PUPPIGUISettings.nodeSpacing / (PUPPIGUISettings.maxConnPerSpace + 1) / 2), ccon.poscenter.Z, PUPPIGUISettings.nodeSpacing / (PUPPIGUISettings.maxConnPerSpace + 1), PUPPIGUISettings.nodeSpacing / (PUPPIGUISettings.maxConnPerSpace + 1), PUPPIGUISettings.nodeHeight);
            //                if (ccon.connbounds.IntersectsWith(levelmap.region_perimeter))
            //                {

            //                    if (ccon.ishorizontal == true)
            //                    {
            //                        connecthmap.footprints.Add(ccon.connbounds);
            //                    }
            //                    else
            //                    {
            //                        connectvmap.footprints.Add(ccon.connbounds);
            //                    }
            //                }


            //                //}
            //            }
            //        }
            //    }
            //    //use same perimeter as the maze
            //    connecthmap.region_perimeter = levelmap.region_perimeter;
            //    connectvmap.region_perimeter = levelmap.region_perimeter;

            //    lineprogress = new Stack<Vector3D>();

            //    Vector3D[] sarrayr = null;
            //    mazepoint(levelmap, connecthmap, connectvmap, whereto, PUPPIGUISettings.nodeSpacing, out sarrayr);
            //    if (sarrayr != null)
            //    {
            //        for (int ir = 0; ir < sarrayr.Length; ir++)
            //        {
            //            lineparts.Add(sarrayr[ir]);
            //            currentpoint.Offset(sarrayr[ir].X, sarrayr[ir].Y, sarrayr[ir].Z);
            //        }
            //    }

            //}
            #endregion
            internal bool findlocation(Point3D loc, out List<Point3D> pList)
            {
                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log("Trying to find path on canvas between " + currentpoint.X.ToString() + "," + currentpoint.Y.ToString() + " and " + loc.X.ToString() + "," + loc.Y.ToString());
                }

                pList = new List<Point3D>();
                double ds = PUPPIGUISettings.nodeSpacing / (double)(PUPPIGUISettings.maxConnPerSpace + 1);

                d2collisionmodel levelmap = new d2collisionmodel();

                double basez = 0;

                int basenumconn = 0;
                //add stack roots
                Point3D whereto = new Point3D(loc.X.nodespacecenterconvert(ds), loc.Y.nodespacecenterconvert(ds), loc.Z);


                //we need to create a region where we will do our mazing


                lineprogress = new Stack<Vector3D>();

                Vector3D[] sarrayr = null;
                //   mazepoint(levelmap, connecthmap, connectvmap, whereto, PUPPIGUISettings.nodeSpacing, out sarrayr);
                pList = mazepoint(d2collisionmodel.canvaslevelmap, whereto, PUPPIGUISettings.nodeSpacing, out sarrayr);
                if (sarrayr != null)
                {
                    for (int ir = 0; ir < sarrayr.Length; ir++)
                    {
                        lineparts.Add(sarrayr[ir]);
                        currentpoint.Offset(sarrayr[ir].X, sarrayr[ir].Y, sarrayr[ir].Z);
                    }
                    if (PUPPIDebugger.debugenabled == true)
                    {
                        PUPPIDebugger.log("Found path on canvas ");
                    }
                    return true;
                }
                //failed to find
                if (PUPPIDebugger.debugenabled == true)
                {
                    PUPPIDebugger.log("Did not find path on canvas ");
                }
                return false;
            }



        }
        //for right click on node
        class PUPPINodeContextMenu : ContextMenu
        {
            internal ModViz3DNode nodeaffected;
            internal MenuItem setlistlevel;
            internal MenuItem setstacklistlevel;
            internal MenuItem toPaste;
            internal MenuItem toAddOn;
            internal MenuItem addselnodestack;
            internal MenuItem copynodestack;
            internal MenuItem removeselnodestack;
            internal MenuItem explodeContainerMenuItem;
            internal MenuItem splitmystackatnode;

            //hide and show node and nodes above on locked canvas
            internal MenuItem hmnolc;
            internal MenuItem smnolc;
            internal PUPPINodeContextMenu()
            {
                //MenuItem delme = new MenuItem();
                //delme.Header = "Delete";
                //this.AddChild(delme);

                //display info on node. now for debug, to be expanded.
                MenuItem infoItem = new MenuItem();
                this.Items.Add(infoItem);
                infoItem.Header = "Node Information"; // define name of context menu
                //infoItem.ToolTip = "Shows information about the node and its PUPPIModule.";
                infoItem.Click += delegate { nodeaffected.showinfo(); };


                //display info on node. now for debug, to be expanded.
                MenuItem fPro = new MenuItem();
                this.Items.Add(fPro);
                fPro.Header = "Force Process"; // define name of context menu
                fPro.ToolTip = "Forces node module to process also causing nodes downstream to process.Downstream nodes will only process if in Run Live mode.";
                fPro.Click += delegate { if (nodeaffected.logical_representation != null) nodeaffected.logical_representation.process(); };


                //sets the display name
                MenuItem displaynameItem = new MenuItem();
                this.Items.Add(displaynameItem);
                displaynameItem.Header = "Change Caption"; // define name of context menu
                displaynameItem.Click += delegate
                {
                    string dn = "";
                    formutils.InputBox("Set node caption", "Set node caption", ref dn);
                    if (dn != "")
                    {
                        nodeaffected.mycanvas.canvasabouttochange();
                        nodeaffected.displayname = dn;
                        nodeaffected.update_caption();
                    }

                };

                MenuItem delItem = new MenuItem();
                this.Items.Add(delItem);
                delItem.Header = "Delete Node"; // define name of context menu
                delItem.Click += delegate { nodeaffected.mycanvas.canvasabouttochange(); nodeaffected.mycanvas.blockconnupdates = true; nodeaffected.delete(true); nodeaffected.mycanvas.blockconnupdates = false; nodeaffected.mycanvas.update_all_connectors(); };

                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    MenuItem delStackAbove = new MenuItem();
                    this.Items.Add(delStackAbove);
                    delStackAbove.Header = "Delete Node and Stack Above";
                    delStackAbove.Click += delegate { nodeaffected.mycanvas.canvasabouttochange(); nodeaffected.mycanvas.blockconnupdates = true; nodeaffected.deletestack(); nodeaffected.mycanvas.blockconnupdates = false; nodeaffected.mycanvas.update_all_connectors(); };
                }



                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    MenuItem cloneStackAbove = new MenuItem();
                    this.Items.Add(cloneStackAbove);
                    cloneStackAbove.Header = "Clone Node and Stack Above";
                    cloneStackAbove.Click += delegate { nodeaffected.mycanvas.selstacks.Clear(); nodeaffected.addstacktoselection(); nodeaffected.mycanvas.canvasabouttochange(); nodeaffected.mycanvas.copyselectiontoclipboard(); nodeaffected.mycanvas.pastefromclip(new Point3D(nodeaffected.myposition.X, nodeaffected.myposition.Y, 0)); };
                }


                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    splitmystackatnode = new MenuItem();
                    this.Items.Add(splitmystackatnode);
                    splitmystackatnode.Header = "Split Stack";
                    splitmystackatnode.ToolTip = "Splits the stack, this node becoming a base node.";
                    splitmystackatnode.Click += delegate { nodeaffected.mycanvas.canvasabouttochange(); nodeaffected.mycanvas.blockconnupdates = true; nodeaffected.splitmynodestack(); nodeaffected.mycanvas.blockconnupdates = false; nodeaffected.mycanvas.update_all_connectors(); };
                }

                copynodestack = new MenuItem();
                //this.Items.Add(copynodestack);
                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    copynodestack.Header = "Copy Node Stack";
                }
                else
                {
                    copynodestack.Header = "Copy Node";
                }
                copynodestack.Click += delegate { nodeaffected.copytoclip(); };

                addselnodestack = new MenuItem();
                this.Items.Add(addselnodestack);
                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    addselnodestack.Header = "Select Node and Stack Above";
                }
                else
                {
                    addselnodestack.Header = "Select Node";
                }
                addselnodestack.Click += delegate { nodeaffected.addstacktoselection(); };



                removeselnodestack = new MenuItem();
                this.Items.Add(removeselnodestack);
                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    removeselnodestack.Header = "Unselect Node and Stack Above";
                }
                else
                {
                    removeselnodestack.Header = "Unselect Node";
                }
                removeselnodestack.Click += delegate { nodeaffected.removestackfromselection(); };


                hmnolc = new MenuItem();
                this.Items.Add(hmnolc);
                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    hmnolc.Header = "Hide Node and Stack Above";
                }
                else
                {
                    hmnolc.Header = "Hide Node";
                }
                hmnolc.Click += delegate { nodeaffected.setNodeHiddenLockedCanvasStatus(true); };
                hmnolc.ToolTip = "Hides the node (and nodes above on 3D canvases) on locked canvas.(This doesn't change node appearance on an unlocked canvas).";

                smnolc = new MenuItem();
                this.Items.Add(smnolc);
                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    smnolc.Header = "Show Node and Stack Above";
                }
                else
                {
                    smnolc.Header = "Show Node";
                }
                smnolc.Click += delegate { nodeaffected.setNodeHiddenLockedCanvasStatus(false); };
                smnolc.ToolTip = "Shows the node (and nodes above on 3D canvases) on locked canvas.(This doesn't change node appearance on an unlocked canvas).";




                //to be able to change the array level
                setlistlevel = new MenuItem();
                this.Items.Add(setlistlevel);


                setlistlevel.Header = "List/Item for Node ";
                setlistlevel.ToolTip = "Sets if the node processes inputs as a single item or a list of items. Nodes without inputs also need the number of items specified for list mode.";


                setlistlevel.Click += delegate
            {

                //int number = 0;
                //int nelements = 0;

                setlistlevelform sella = new setlistlevelform(nodeaffected.list_level, nodeaffected.logical_representation.inputs.Count == 0, nodeaffected.logical_representation.countListMode);
                sella.ShowDialog();

                //string entered = "";
                //formutils.InputBox("Please enter a list level (0 means single value,1 means ArrayList)!", "Current List Level is  " + nodeaffected.list_level.ToString(), ref entered);
                //try
                //{
                //    number = Convert.ToInt16(entered);
                //}
                //catch
                //{
                //}
                //if (number < 0) number = 0;
                //if (number > 1) number = 1;
                ////ask for number of elements if we have a list
                ////but only if we don't have inputs
                //if (number == 1 && nodeaffected.logical_representation.inputs.Count == 0)
                //{
                //    formutils.InputBox("Please enter number of elements in list", "Enter data", ref entered);

                //    try
                //    {
                //        nelements = Convert.ToInt16(entered);
                //    }
                //    catch
                //    {
                //    }
                //    if (nelements <= 0) nelements = 1;
                //}
                nodeaffected.mycanvas.canvasabouttochange();
                nodeaffected.setlistlevel(sella.lstlevel, sella.numelem);
            };
                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    //to be able to change the array level
                    setstacklistlevel = new MenuItem();
                    this.Items.Add(setstacklistlevel);


                    setstacklistlevel.Header = "List/Item for Node and Stack Above";



                    setstacklistlevel.Click += delegate
                    {

                        //int number = 0;
                        //int nelements = 0;
                        //string entered = "";
                        //formutils.InputBox("Enter list level (0=single item,1 ArrayList)!", "Don't forget to double click on nodes with no inputs to set them!", ref entered);
                        //try
                        //{
                        //    number = Convert.ToInt16(entered);
                        //}
                        //catch
                        //{
                        //}
                        //if (number < 0) number = 0;
                        //if (number > 1) number = 1;
                        ////ask for number of elements if we have a list
                        ////but only if we don't have inputs

                        //formutils.InputBox("Please enter number of elements in list", "Please enter number of elements in list", ref entered);

                        //try
                        //{
                        //    nelements = Convert.ToInt16(entered);
                        //}
                        //catch
                        //{
                        //}
                        //if (nelements <= 0) nelements = 1;
                        setlistlevelform sella = new setlistlevelform(nodeaffected.list_level, true, nodeaffected.logical_representation.countListMode);
                        sella.ShowDialog();
                        nodeaffected.mycanvas.canvasabouttochange();
                        nodeaffected.setstacklistlevel(sella.lstlevel, sella.numelem);
                        //nodeaffected.setstacklistlevel(number, nelements);

                    };
                }

                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    toPaste = new MenuItem();

                    toPaste.Header = "Paste on";
                    toPaste.ToolTip = "Pastes selection on top of current node as children.";
                    toPaste.Click += delegate { nodeaffected.mycanvas.canvasabouttochange(); nodeaffected.pasteontopof(); };
                    this.Items.Add(toPaste);
                }

                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {
                    toAddOn = new MenuItem();

                    toAddOn.Header = "Add child node";
                    toAddOn.ToolTip = "Adds a node on top of this node with a module specieid by the user.";
                    toAddOn.Click += delegate
                    {


                        PUPPI.inputModulePicker pi = new PUPPI.inputModulePicker();
                        foreach (PUPPIModule p in nodeaffected.mycanvas.cvavailablePUPPIModules.Values)
                        {

                            pi.modNames.Add(p.name);


                            pi.modest.Add(p.description);
                        }
                        pi.ShowDialog();
                        PUPPIModule pl = null;
                        if (pi.selectedModule != "")
                        {
                            foreach (PUPPIModule ppi in nodeaffected.mycanvas.cvavailablePUPPIModules.Values)
                            {
                                if (ppi.name == pi.selectedModule)
                                {
                                    pl = ppi;
                                    break;
                                }
                            }
                            if (pl != null)
                            {
                                nodeaffected.mycanvas.canvasabouttochange();
                                int i = nodeaffected.mycanvas.addNodeOnTopOfNodeToTheCanvas(nodeaffected.nodeGUID, pl);
                                if (i == -1)
                                {
                                    MessageBox.Show("Failed to add node!");
                                    nodeaffected.mycanvas.undome();
                                }

                            }
                        }


                    };
                    this.Items.Add(toAddOn);
                }


                //only if there's a point to export
                if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                {

                    MenuItem exportstack = new MenuItem();
                    exportstack.Header = "Export Stack";
                    exportstack.ToolTip = "Exports the stack to a new file.";
                    exportstack.Click += delegate { List<ModViz3DNode> sl = new List<ModViz3DNode>(); sl.Add(nodeaffected); List<ModViz3DNode> ml = new List<ModViz3DNode>(); nodeaffected.getalllevelschildren(ml); sl.AddRange(ml); nodeaffected.mycanvas.saveas(sl, false); };
                    this.Items.Add(exportstack);
                }
                explodeContainerMenuItem = new MenuItem();
                explodeContainerMenuItem.Header = "Explode Container";
                explodeContainerMenuItem.ToolTip = "Explodes container node into constituent nodes.";
                this.Items.Add(explodeContainerMenuItem);
                explodeContainerMenuItem.Click += delegate { nodeaffected.mycanvas.canvasabouttochange(); nodeaffected.explodeMyContainerNodeOnCanvas(); };
                this.IsOpen = false;



            }
        }
        class PUPPICanvasContextMenu : ContextMenu
        {
            internal HelixViewport3D myview;
            internal PUPPICanvas mycanvas;
            internal Point3D position;
            MenuItem toPaste;
            MenuItem toAN;
            internal PUPPICanvasContextMenu()
            {
                toPaste = new MenuItem();

                toPaste.Header = "Paste";
                toPaste.Click += delegate { mycanvas.canvasabouttochange(); mycanvas.pastefromclip(position); };
                this.Items.Add(toPaste);

                toAN = new MenuItem();

                toAN.Header = "Add node";
                toAN.Click += delegate
                {

                    PUPPI.inputModulePicker pi = new PUPPI.inputModulePicker();
                    foreach (PUPPIModule p in mycanvas.cvavailablePUPPIModules.Values)
                    {

                        pi.modNames.Add(p.name);


                        pi.modest.Add(p.description);
                    }
                    pi.ShowDialog();
                    PUPPIModule pl = null;
                    if (pi.selectedModule != "")
                    {
                        foreach (PUPPIModule ppi in mycanvas.cvavailablePUPPIModules.Values)
                        {
                            if (ppi.name == pi.selectedModule)
                            {
                                pl = ppi;
                                break;
                            }
                        }
                        if (pl != null)
                        {
                            mycanvas.canvasabouttochange();
                            int i = mycanvas.addANodeToTheCanvas(position, pl);
                            if (i == -1)
                            {
                                MessageBox.Show("Failed to add node!");
                                mycanvas.undome();
                            }

                        }
                    }


                };
                this.Items.Add(toAN);
                this.IsOpen = false;
            }
        }

        internal bool discoAllNodeOutputs(string sourceNodeGUID, int sourceOutputIndex)
        {
            try
            {
                PUPPICanvas.ModViz3DNode nodeaffected = null;
                if (stacks.ContainsKey(sourceNodeGUID) == false) return false;
                else
                {
                    nodeaffected = stacks[sourceNodeGUID];
                }
                nodeaffected.mycanvas.canvasabouttochange();

                foreach (PUPPICanvas.ModViz3DNode testdisco in nodeaffected.mycanvas.stacks.Values)
                {
                    for (int tdi = 0; tdi < testdisco.vizinputs.Count; tdi++)
                    {
                        PUPPICanvas.ModViz3DInput testimp = testdisco.vizinputs[tdi];
                        if (testimp != null && testimp.myinput != null)
                        {
                            if (testimp.myinput.module == nodeaffected.logical_representation)
                            {
                                if (testimp.myinput.outParIndex == sourceOutputIndex)
                                {
                                    testdisco.disconnectinput(testdisco.vizinputs.IndexOf(testimp));
                                }
                            }
                        }
                    }
                }
                return true;
            }
            catch
            {
                return false;
            }
        }


        //when right clicking on output
        class PUPPIOutputConnectorContextMenu : ContextMenu
        {
            internal ModViz3DNode nodeaffected;
            internal int outputaffected;
            //this is for using the input's module to another input
            //needs to be grayed out if input module null
            internal MenuItem discItem;
            internal MenuItem mycanvasoutputobjectproperties;
            internal MenuItem t;
            internal MenuItem v;
            internal MenuItem suggestModule;
            internal MenuItem autoPopProperties;
            internal MenuItem autoPopFields;

            internal PUPPIOutputConnectorContextMenu()
            {
                t = new MenuItem();
                this.Items.Add(t);
                t.Background = new SolidColorBrush(Colors.LightGreen);
                t.Header = "T";
                // this.Items.Add(new Separator());

                v = new MenuItem();
                this.Items.Add(v);
                v.Background = new SolidColorBrush(Colors.GreenYellow);
                v.Header = "V";
                this.Items.Add(new Separator());

                discItem = new MenuItem();
                this.Items.Add(discItem);
                discItem.Header = "Disconnect All Connected";

                discItem.Click += delegate
                {
                    nodeaffected.mycanvas.canvasabouttochange();

                    foreach (ModViz3DNode testdisco in nodeaffected.mycanvas.stacks.Values)
                    {
                        for (int tdi = 0; tdi < testdisco.vizinputs.Count; tdi++)
                        {
                            ModViz3DInput testimp = testdisco.vizinputs[tdi];
                            if (testimp != null && testimp.myinput != null)
                            {
                                if (testimp.myinput.module == nodeaffected.logical_representation)
                                {
                                    if (testimp.myinput.outParIndex == outputaffected)
                                    {
                                        testdisco.disconnectinput(testdisco.vizinputs.IndexOf(testimp));
                                    }
                                }
                            }
                        }
                    }

                };


                mycanvasoutputobjectproperties = new MenuItem();
                this.Items.Add(mycanvasoutputobjectproperties);
                mycanvasoutputobjectproperties.Header = "Output Object Properties";

                mycanvasoutputobjectproperties.Click += delegate
                {



                    try
                    {

                        object ooj = nodeaffected.logical_representation.outputs[outputaffected];
                        if (ooj != null)
                        {
                            PUPPI.showOutputProperties shop = new PUPPI.showOutputProperties();
                            shop.proNamesValues = new List<string>();
                            foreach (var prop in ooj.GetType().GetProperties())
                            {
                                shop.proNamesValues.Add(prop.Name + "(" + prop.PropertyType.ToString() + ")" + "=" + prop.GetValue(ooj, null));
                            }
                            shop.Show();
                        }
                    }
                    catch
                    {
                        MessageBox.Show("Could not retrieve properties");
                    }


                };

                suggestModule = new MenuItem();
                this.Items.Add(suggestModule);
                suggestModule.Header = "Suggest Compatible PUPPIModule";
                suggestModule.ToolTip = "Presents the user with a list of modules to create nodes from to connect to this output. Said modules input matches the variable type required by this output.";
                suggestModule.Click += delegate
                {
                    PUPPIModule pm = nodeaffected.logical_representation;
                    if (pm != null)
                    {
                        List<Type> rl = pm.getOutputTypes();
                        if (rl != null && rl.Count == pm.outputs.Count)
                        {
                            Type ti = rl[outputaffected];
                            //no primitive types
                            if (ti != null && !ti.IsPrimitive)
                            {
                                List<PUPPIModule> matchesN = new List<PUPPIModule>();
                                List<int> matchesO = new List<int>();
                                //go through indexed modules to see if any have ouputs of matching type
                                foreach (PUPPIModule p in nodeaffected.mycanvas.cvavailablePUPPIModules.Values)
                                {
                                    List<Type> ll = p.getInputTypes();
                                    if (ll != null && ll.Count > 0)
                                    {
                                        bool fou = false;
                                        int oii = 0;
                                        foreach (Type ttt in ll)
                                        {
                                            if (ttt != null && ti != null && (ttt == ti || ttt == ti.BaseType))
                                            {
                                                //get the first matching output for now
                                                fou = true;
                                                break;
                                            }
                                            oii++;
                                        }
                                        if (fou)
                                        {
                                            matchesN.Add(p);
                                            matchesO.Add(oii);
                                        }
                                    }
                                }
                                if (matchesN.Count == 0)
                                {
                                    MessageBox.Show("No matching type module inputs found");
                                    return;
                                }
                                PUPPI.inputModulePicker pi = new PUPPI.inputModulePicker();
                                foreach (PUPPIModule p in matchesN)
                                {

                                    pi.modNames.Add(p.name);


                                    pi.modest.Add(p.description);
                                }
                                pi.ShowDialog();
                                if (pi.selectedModule != "")
                                {

                                    //destination node

                                    ModViz3DNode sourcenode = nodeaffected;
                                    PUPPIModule pl = null;
                                    int picko = -1;
                                    int oic = 0;
                                    foreach (PUPPIModule ppi in matchesN)
                                    {
                                        if (ppi.name == pi.selectedModule)
                                        {
                                            pl = ppi;
                                            picko = matchesO[oic];
                                            break;
                                        }
                                        oic++;
                                    }
                                    if (pl != null)
                                    {

                                        if (pl.inputs != null)
                                        {
                                            if (pl.inputs.Count > picko && picko != -1)
                                            {
                                                try
                                                {
                                                    nodeaffected.mycanvas.canvasabouttochange();
                                                    nodeaffected.setoutputvaluefrommodule(outputaffected, pl, picko);
                                                }
                                                catch
                                                {
                                                    MessageBox.Show("Failed to set output");
                                                    nodeaffected.mycanvas.undome();
                                                }
                                            }
                                        }

                                    }
                                }
                            }
                            else
                            {
                                MessageBox.Show("Could not determine output type!");
                            }
                        }
                        else
                        {
                            MessageBox.Show("Could not determine output type!");
                        }
                    }

                };
                autoPopProperties = new MenuItem();
                this.Items.Add(autoPopProperties);
                autoPopProperties.Header = "Generate Properties Node";
                autoPopProperties.ToolTip = "Creates an Input Class Properties node that accesses the properties of the output object.";
                autoPopProperties.Click += delegate
                {
                    try
                    {
                        nodeaffected.mycanvas.canvasabouttochange();
                        nodeaffected.setoutputvaluefrommodule(outputaffected, new PUPPIModel.PUPPIPremadeModules.DataExchangeModules.InputPUPPIClassProperties(), 0);
                    }
                    catch
                    {
                        MessageBox.Show("Failed to set output");
                        nodeaffected.mycanvas.undome();
                    }
                };

                autoPopFields = new MenuItem();
                this.Items.Add(autoPopFields);
                autoPopFields.Header = "Generate Fields Node";
                autoPopFields.ToolTip = "Creates an Input Class Fields node that accesses the fields of the output object.";
                autoPopFields.Click += delegate
                {
                    try
                    {
                        nodeaffected.mycanvas.canvasabouttochange();
                        nodeaffected.setoutputvaluefrommodule(outputaffected, new PUPPIModel.PUPPIPremadeModules.DataExchangeModules.InputPUPPIClassFields(), 0);
                    }
                    catch
                    {
                        MessageBox.Show("Failed to set output");
                        nodeaffected.mycanvas.undome();
                    }
                };

            }
        }

        //inputs can be set manually
        class PUPPIInputConnectorContextMenu : ContextMenu
        {
            internal ModViz3DNode nodeaffected;
            internal int inputaffected;
            //display name and value type
            internal MenuItem t;
            internal MenuItem v;

            //this is for using the input's module to another input
            //needs to be grayed out if input module null
            internal MenuItem discItem;
            //needs to be grayed out if input module null
            internal MenuItem goToSource;

            //grayed out if connected
            internal MenuItem setItem;
            //grayed out if connected
            internal MenuItem setItemTree;
            internal MenuItem setFromModule;
            internal MenuItem suggestModule;
            //changing header
            internal MenuItem autoListMode;

            // internal MenuItem useItem;
            internal PUPPIInputConnectorContextMenu()
            {
                ////title items
                //this.Items.Insert(0, new System.Windows.Forms.ToolStripLabel("Please select an option"));
                //this.Items.Insert(1, new System.Windows.Forms.ToolStripSeparator());

                //if (PUPPIGUISettings.canvasMode != PUPPIGUISettings.CanvasModeEnum.TwoDimensional)
                //{
                t = new MenuItem();
                this.Items.Add(t);
                t.Background = new SolidColorBrush(Colors.LightYellow);
                t.Header = "T";
                v = new MenuItem();
                this.Items.Add(v);
                v.Background = new SolidColorBrush(Colors.PeachPuff);
                v.Header = "V";
                this.Items.Add(new Separator());

                setItem = new MenuItem();
                this.Items.Add(setItem);
                setItem.Header = "Set Numeric";
                setItem.ToolTip = "Sets the input to a Number Input node output which gets generated and the user is prompted to enter a value.";
                setItem.Click += delegate { nodeaffected.mycanvas.canvasabouttochange(); nodeaffected.setinputvaluenumeric(inputaffected); };
                //}
                setItemTree = new MenuItem();
                this.Items.Add(setItemTree);
                setItemTree.Header = "Set from Tree";
                setItemTree.ToolTip = "Brings up the node tree view where the user can pick a node output to connect this input to.";
                setItemTree.Click += delegate
                {
                    PUPPIPickTreeInputForm ptf = new PUPPIPickTreeInputForm();
                    ptf.mycanvas = nodeaffected.mycanvas;
                    ptf.ShowDialog();
                    if (ptf.goforit == true)
                    {


                        //destination node

                        ModViz3DNode destnode = nodeaffected;
                        //  string sss = destnode.mycanvas.updatemyPCStatus("Processing user action...");

                        PUPPIModule destmod = null;
                        try
                        {
                            destmod = destnode.logical_representation;
                        }
                        catch
                        {
                            destmod = null;
                        }
                        if (destmod == null)
                        {
                            //   sss = destnode.mycanvas.updatemyPCStatus(sss);
                            return;
                        }
                        //destination input index
                        int dinputindex = -1;
                        try
                        {
                            dinputindex = inputaffected;
                        }
                        catch
                        {
                            dinputindex = -1;
                        }
                        if (dinputindex == -1)
                        {
                            //  sss = destnode.mycanvas.updatemyPCStatus(sss);
                            return;
                        }
                        ModViz3DInput destinput = destnode.vizinputs[dinputindex];
                        if (destinput == null)
                        {
                            //sss = destnode.mycanvas.updatemyPCStatus(sss);
                            return;
                        }
                        //make the module
                        PUPPIModel.PUPPIInParameter pinp = new PUPPIInParameter();
                        ModViz3DNode sourcenode = null;
                        try
                        {

                            nodeaffected.mycanvas.stacks.TryGetValue(ptf.nodeid.ToString(), out sourcenode);
                            if (sourcenode == null)
                            {
                                // sss = destnode.mycanvas.updatemyPCStatus(sss);
                                return;
                            }

                            //now connect the number node

                            bool successfulconn = pinp.getinputfrom(sourcenode.logical_representation, ptf.outputid);
                            if (!successfulconn)
                            {
                                //   sss = destnode.mycanvas.updatemyPCStatus(sss);
                                return;
                            }
                        }
                        catch
                        {
                            // sss = destnode.mycanvas.updatemyPCStatus(sss);
                            return;
                        }

                        //already filled number max outgoing connections
                        if (sourcenode.logical_representation.maxOutgoingConnections >= 0 && sourcenode.vizoutputs[pinp.outParIndex].outboundconns.Count == sourcenode.logical_representation.maxOutgoingConnections) return;

                        nodeaffected.mycanvas.canvasabouttochange();
                        bool connected = destmod.connect_input(pinp, dinputindex, true); //.inputs[dinputindex] = pinp;
                        if (connected == false)
                        {
                            // sss = destnode.mycanvas.updatemyPCStatus(sss);
                            return;
                        }


                        string cnf = "conn_" + pinp.module.GUID.ToString() + "_" + pinp.outParIndex.ToString() + "_" + destmod.GUID.ToString() + "_" + dinputindex.ToString();
                        ModViz3DConn newconnenctor = new ModViz3DConn(sourcenode, pinp.outParIndex, destnode, dinputindex, cnf);


                        if (PUPPIGUISettings.useMultiThreading)
                            newconnenctor.drawmethread();
                        else newconnenctor.drawme();

                        //if this has been deleted by a disconenct then the key is still in the dictionary
                        if (nodeaffected.mycanvas.connpaths.ContainsKey(newconnenctor.visualGUID) == true)
                        {
                            nodeaffected.mycanvas.connpaths[newconnenctor.visualGUID] = newconnenctor;
                        }
                        else
                        {
                            nodeaffected.mycanvas.connpaths.Add(newconnenctor.visualGUID, newconnenctor);
                        }
                        destinput.myconnector = newconnenctor;
                        destinput.myinput = pinp;


                        destmod.userdoIprocess();

                        nodeaffected.mycanvas.stacks[nodeaffected.nodeGUID.ToString()].update_inouts();
                        //  sss = destnode.mycanvas.updatemyPCStatus(sss);
                    }
                };

                setFromModule = new MenuItem();
                this.Items.Add(setFromModule);
                setFromModule.Header = "Set PUPPIModule";
                setFromModule.ToolTip = "Lets the user pick a module which will generate a node and an output will be connected to this input.";
                setFromModule.Click += delegate
                {

                    PUPPI.inputModulePicker pi = new PUPPI.inputModulePicker();
                    foreach (PUPPIModule p in nodeaffected.mycanvas.cvavailablePUPPIModules.Values)
                    {

                        pi.modNames.Add(p.name);


                        pi.modest.Add(p.description);
                    }
                    pi.ShowDialog();
                    if (pi.selectedModule != "")
                    {

                        //destination node

                        ModViz3DNode destnode = nodeaffected;
                        PUPPIModule pl = null;

                        foreach (PUPPIModule ppi in nodeaffected.mycanvas.cvavailablePUPPIModules.Values)
                        {
                            if (ppi.name == pi.selectedModule)
                            {
                                pl = ppi;
                                break;
                            }
                        }
                        if (pl != null)
                        {

                            if (pl.outputs != null)
                            {
                                if (pl.outputs.Count > 0)
                                {
                                    int oc = 0;
                                    if (pl.outputs.Count > 1)
                                    {
                                        string dn = "";
                                        formutils.InputBox("Enter valid output index", "Module has " + pl.outputs.Count.ToString() + " outputs. Please enter 0 based output index", ref dn);
                                        try
                                        {
                                            oc = Convert.ToInt16(dn);
                                        }
                                        catch
                                        {
                                            oc = -1;
                                        }
                                        if (oc < 0 || oc >= pl.outputs.Count)
                                        {
                                            MessageBox.Show("Invalid output");
                                            return;
                                        }
                                    }

                                    try
                                    {
                                        nodeaffected.mycanvas.canvasabouttochange();
                                        nodeaffected.setinputvaluefrommodule(inputaffected, pl, oc);
                                    }
                                    catch
                                    {
                                        MessageBox.Show("Failed to set input");
                                        nodeaffected.mycanvas.undome();
                                    }

                                }
                            }

                        }
                    }


                };


                suggestModule = new MenuItem();
                this.Items.Add(suggestModule);
                suggestModule.Header = "Suggest Compatible PUPPIModule";
                suggestModule.ToolTip = "Presents the user with a list of modules to create nodes from to connect to this input. Said modules have outputs matching the variable type required by this input.";
                suggestModule.Click += delegate
                {
                    PUPPIModule pm = nodeaffected.logical_representation;
                    if (pm != null)
                    {
                        List<Type> rl = pm.getInputTypes();
                        if (rl != null && rl.Count == pm.inputs.Count)
                        {
                            Type ti = rl[inputaffected];
                            //no primitive types, takes too long
                            if (ti != null && !ti.IsPrimitive)
                            {
                                List<PUPPIModule> matchesN = new List<PUPPIModule>();
                                List<int> matchesO = new List<int>();
                                //go through indexed modules to see if any have ouputs of matching type
                                foreach (PUPPIModule p in nodeaffected.mycanvas.cvavailablePUPPIModules.Values)
                                {
                                    List<Type> ll = p.getOutputTypes();
                                    if (ll != null && ll.Count > 0)
                                    {
                                        bool fou = false;
                                        int oii = 0;
                                        foreach (Type ttt in ll)
                                        {
                                            if (ttt != null && ti != null && (ttt == ti || ti == ttt.BaseType))
                                            {
                                                //get the first matching output for now
                                                fou = true;
                                                break;
                                            }
                                            oii++;
                                        }
                                        if (fou)
                                        {
                                            matchesN.Add(p);
                                            matchesO.Add(oii);
                                        }
                                    }
                                }
                                if (matchesN.Count == 0)
                                {
                                    MessageBox.Show("No matching type module outputs found");
                                    return;
                                }
                                PUPPI.inputModulePicker pi = new PUPPI.inputModulePicker();
                                foreach (PUPPIModule p in matchesN)
                                {

                                    pi.modNames.Add(p.name);


                                    pi.modest.Add(p.description);
                                }
                                pi.ShowDialog();
                                if (pi.selectedModule != "")
                                {

                                    //destination node

                                    ModViz3DNode destnode = nodeaffected;
                                    PUPPIModule pl = null;
                                    int picko = -1;
                                    foreach (PUPPIModule ppi in matchesN)
                                    {
                                        if (ppi.name == pi.selectedModule)
                                        {
                                            pl = ppi;
                                            picko = matchesO[matchesN.IndexOf(ppi)];
                                            break;
                                        }
                                    }
                                    if (pl != null)
                                    {

                                        if (pl.outputs != null)
                                        {
                                            if (pl.outputs.Count > picko && picko != -1)
                                            {
                                                try
                                                {
                                                    nodeaffected.mycanvas.canvasabouttochange();
                                                    nodeaffected.setinputvaluefrommodule(inputaffected, pl, picko);
                                                }
                                                catch
                                                {
                                                    MessageBox.Show("Failed to set input");
                                                    nodeaffected.mycanvas.undome();
                                                }
                                            }
                                        }

                                    }
                                }
                            }
                            else
                            {
                                MessageBox.Show("Could not determine input type!");
                            }
                        }
                        else
                        {
                            MessageBox.Show("Could not determine input type!");
                        }
                    }

                };
                discItem = new MenuItem();
                this.Items.Add(discItem);
                discItem.Header = "Disconnect";

                discItem.Click += delegate
                {
                    nodeaffected.mycanvas.canvasabouttochange();
                    nodeaffected.disconnectinput(inputaffected);
                };


                goToSource = new MenuItem();
                this.Items.Add(goToSource);
                goToSource.Header = "Find Source";
                goToSource.ToolTip = "Navigates camera to the source node connected to this input.";
                goToSource.Click += delegate
                {
                    ModViz3DNode m = nodeaffected.getNodeUpstreamByInput(inputaffected);
                    if (m != null) m.focuscameraon();

                };


                //useItem = new MenuItem();
                // this.Items.Add(useItem);
                // useItem.Header = "Use";

                // useItem.Click += delegate
                // {
                //     nodeaffected.mycanvas.canvasabouttochange();

                // };

                autoListMode = new MenuItem();
                this.Items.Add(autoListMode);
                //if (nodeaffected.getAutoLStatus(inputaffected)==true  )
                autoListMode.Header = "Auto-List Enabled";
                autoListMode.ToolTip = "Toggles if input value is automatically arrayed based on number of items the node processes in list mode.At least one input of the node has to be an actual list type. Auto-List mode resets to disabled when a new node is connected. ";
                //else autoListMode.Header = "Auto-List Disabledd";

                autoListMode.Click += delegate
                {
                    nodeaffected.mycanvas.canvasabouttochange();
                    if (nodeaffected.getAutoLStatus(inputaffected) == true)
                    {
                        autoListMode.Header = "Auto-List Disabled";
                        nodeaffected.settAutoLStatus(inputaffected, false);
                    }
                    else
                    {
                        autoListMode.Header = "Auto-List Enabled";
                        nodeaffected.settAutoLStatus(inputaffected, true);
                    }
                    if (nodeaffected.logical_representation != null)
                        nodeaffected.logical_representation.doIprocess();

                };

                this.IsOpen = false;



            }
        }


    }
    //better definition of line segments and operations
    internal class linesegment
    {
        Point3D start;
        Point3D end;
        //keep original z
        double orz;
        internal linesegment()
        {
            start = new Point3D();
            end = new Point3D();
            orz = 0;
        }
        internal linesegment(Point3D p1, Point3D p2)
        {
            start = new Point3D(p1.X, p1.Y, 0);
            end = new Point3D(p2.X, p2.Y, 0);
            orz = p1.Z;
        }
        internal bool intersects(linesegment otherseg, out Point3D pointofintersection)
        {
            pointofintersection = new Point3D(-999, -999, -999);
            double x = -999;
            double y = -999;
            bool sintersect = lineSegmentIntersection(start.X, start.Y, end.X, end.Y, otherseg.start.X, otherseg.start.Y, otherseg.end.X, otherseg.end.Y, out x, out y);
            if (sintersect == false)
            {
                return false;
            }
            pointofintersection.X = x;
            pointofintersection.Y = y;
            pointofintersection.Z = orz;

            return true;
            //pointofintersection = new Point3D(-999, -999, -999);  
            //bool itintersects = false;
            ////Line1
            //double A1 = end.Y - start.Y;
            //double B1 = end.X -start.X;
            //double C1 = A1 * start.X + B1 * start.Y;

            ////Line2
            //double A2 = otherseg.end.Y - otherseg.start.Y;
            //double B2 = otherseg.end.X - otherseg.start.X;
            //double C2 = A2 * otherseg.start.X + B2 * otherseg.start.Y;

            //double det = A1 * B2 - A2 * B1;
            //if (Math.Abs(det) <PUPPIGUISettings.collinearToler  )
            //{
            //    return false;//parallel lines
            //}
            //else
            //{
            //    double x = (B2 * C1 - B1 * C2) / det;
            //    double y = (A1 * C2 - A2 * C1) / det;


            //        //Point d = Point((B2 * C1 - B1 * C2) / det, -(A1 * C2 - A2 * C1) / det);
            //    Point3D ipoint = new Point3D(x, y, 0);
            //    if (pointonsegment(ipoint ) && otherseg.pointonsegment(ipoint)   )
            //    {
            //        ipoint.Z = orz;
            //        pointofintersection = ipoint; 
            //        return true;
            //    }
            //    else
            //    {
            //        return false;
            //    }
            //}
            //return itintersects;
        }
        internal double length()
        {
            return start.DistanceTo(end);
        }


        //  internal domain function by Darel Rex Finley, 2006
        //modified 2014 by Mihai Pruna
        //  Determines the intersection point of the line segment defined by points A and B
        //  with the line segment defined by points C and D.
        //
        //  Returns YES if the intersection point was found, and stores that point in X,Y.
        //  Returns NO if there is no determinable intersection point, in which case X,Y will
        //  be unmodified.

        bool lineSegmentIntersection(
        double Ax, double Ay,
        double Bx, double By,
        double Cx, double Cy,
        double Dx, double Dy,
        out double X, out double Y)
        {
            X = -999;
            Y = -999;

            double distAB, theCos, theSin, newX, ABpos;

            //  Fail if either line segment is zero-length.
            if (Ax == Bx && Ay == By || Cx == Dx && Cy == Dy) return false;

            //  Fail if the segments share an end-point.
            if (Ax == Cx && Ay == Cy)
            {
                X = Ax;
                Y = Ay;
                return true;
            }
            if (Bx == Cx && By == Cy)
            {
                X = Bx;
                Y = By;
                return true;
            }
            if (Ax == Dx && Ay == Dy)
            {
                X = Ax;
                Y = Ay;
                return true;
            }
            if (Bx == Dx && By == Dy)
            {
                X = Bx;
                Y = By;
                return false;
            }

            //  (1) Translate the system so that point A is on the origin.
            Bx -= Ax; By -= Ay;
            Cx -= Ax; Cy -= Ay;
            Dx -= Ax; Dy -= Ay;

            //  Discover the length of segment A-B.
            distAB = Math.Sqrt(Bx * Bx + By * By);

            //  (2) Rotate the system so that point B is on the positive X axis.
            theCos = Bx / distAB;
            theSin = By / distAB;
            newX = Cx * theCos + Cy * theSin;
            Cy = Cy * theCos - Cx * theSin; Cx = newX;
            newX = Dx * theCos + Dy * theSin;
            Dy = Dy * theCos - Dx * theSin; Dx = newX;

            //  Fail if segment C-D doesn't cross line A-B.
            if (Cy < 0 && Dy < 0 || Cy >= 0 && Dy >= 0) return false;

            //  (3) Discover the position of the intersection point along line A-B.
            ABpos = Dx + (Cx - Dx) * Dy / (Dy - Cy);

            //  Fail if segment C-D crosses line A-B outside of segment A-B.
            if (ABpos < 0 || ABpos > distAB) return false;

            //  (4) Apply the discovered position to line A-B in the original coordinate system.
            X = Ax + ABpos * theCos;
            Y = Ay + ABpos * theSin;

            //  Success.
            return true;
        }

        internal bool pointonsegment(Point3D testpoint)
        {

            Point3D tpoint = new Point3D(testpoint.X, testpoint.Y, 0);
            Vector3D v1 = Vector3D.Subtract(tpoint.ToVector3D(), start.ToVector3D());
            Vector3D v2 = Vector3D.Subtract(end.ToVector3D(), tpoint.ToVector3D());
            if (v1.Length == 0) return true;
            if (v2.Length == 0) return true;
            v1.Z = 0;
            v2.Z = 0;
            //not colinear
            if (Vector3D.CrossProduct(v1, v2).Length / (v1.Length * v2.Length) >= PUPPIGUISettings.collinearToler)
            {
                return false;
            }
            //check if between points
            Point3D midpoint = new Point3D((start.X + end.X) * 0.5, (start.Y + end.Y) * 0.5, 0);
            if (midpoint.DistanceTo(tpoint) <= length() * 0.5) return true;
            return false;
        }

    }
    internal static class Visual3DExtensions
    {



        //makes a box
        internal static GeometryModel3D makeBoxFromRectangle(Rect3D bounds, Material bMat)
        {
            var meshBuilder = new MeshBuilder(false, false);
            meshBuilder.AddBox(bounds);
            var mesh = meshBuilder.ToMesh(true);
            GeometryModel3D newModel = new GeometryModel3D();
            newModel.Geometry = mesh;
            newModel.Material = bMat;
            return newModel;
        }
        //makes a box visual
        internal static ModelVisual3D makeMeaVizBoxFromRectangle(Rect3D bounds, Material bMat)
        {
            var meshBuilder = new MeshBuilder(false, false);
            meshBuilder.AddBox(bounds);
            var mesh = meshBuilder.ToMesh(true);
            GeometryModel3D newModel = new GeometryModel3D();
            newModel.Geometry = mesh;
            newModel.Material = bMat;
            ModelVisual3D m = new ModelVisual3D();
            m.Content = newModel;
            return m;
        }



        //moves a visual by moving all the points
        internal static GeometryModel3D moveMyVisual(this ModelVisual3D m, Vector3D tranV)
        {
            //VerletIntegrator vava = new VerletIntegrator();

            GeometryModel3D newModel = m.Content as GeometryModel3D;
            System.Windows.Media.Media3D.MeshGeometry3D modelmesh = newModel.Geometry.Clone() as System.Windows.Media.Media3D.MeshGeometry3D;
            newModel = new GeometryModel3D();
            // vava.Init(modelmesh);

            //for (int i = 0; i < vava.Positions.Length; i++)
            //{

            //    Point3D p = new Point3D(vava.Positions[i].X, vava.Positions[i].Y, vava.Positions[i].Z);
            //    p.Offset(tranV.X, tranV.Y, tranV.Z);
            //    vava.Positions[i] = p;
            //}
            //vava.TransferPositions(modelmesh);

            //newModel.Geometry = modelmesh;

            //return newModel;

            if (modelmesh != null)
            {
                for (int i = 0; i < modelmesh.Positions.Count; i++)
                {

                    Point3D p = new Point3D(modelmesh.Positions[i].X, modelmesh.Positions[i].Y, modelmesh.Positions[i].Z);
                    p.Offset(tranV.X, tranV.Y, tranV.Z);
                    modelmesh.Positions[i] = p;
                }

                newModel.Geometry = modelmesh;
            }
            return newModel;
        }
        //gets points
        internal static List<Point3D> getMy3DVisualModelPositionsAsPoints(this ModelVisual3D m)
        {

            List<Point3D> gp = new List<Point3D>();
            GeometryModel3D newModel = m.Content as GeometryModel3D;
            if (newModel == null) return gp;
            System.Windows.Media.Media3D.MeshGeometry3D modelmesh = newModel.Geometry as MeshGeometry3D;
            if (modelmesh != null)
                for (int i = 0; i < modelmesh.Positions.Count; i++)
                {

                    Point3D p = new Point3D(modelmesh.Positions[i].X, modelmesh.Positions[i].Y, modelmesh.Positions[i].Z);
                    gp.Add(p);
                }
            return gp;
        }

        //moves a visual by moving all the points
        internal static ModelVisual3D setMy3DVisualModelPositionsAsPoints(this ModelVisual3D m, List<Point3D> myPts)
        {
            //VerletIntegrator vava = new VerletIntegrator();
            ModelVisual3D newm = m;
            GeometryModel3D newModel = m.Content as GeometryModel3D;
            if (newModel == null) return null;
            System.Windows.Media.Media3D.MeshGeometry3D modelmesh = newModel.Geometry.Clone() as System.Windows.Media.Media3D.MeshGeometry3D;
            // newModel = new GeometryModel3D();
            if (modelmesh == null) return null;
            if (modelmesh.Positions.Count != myPts.Count) return null;

            for (int i = 0; i < modelmesh.Positions.Count; i++)
            {

                Point3D p = new Point3D(myPts[i].X, myPts[i].Y, myPts[i].Z);

                modelmesh.Positions[i] = p;
            }

            newModel.Geometry = modelmesh;
            newm.Content = newModel;

            return newm;
        }

        internal static void RecalVisNo(this ModelVisual3D mv)
        {


            if (mv.Content != null)
            {
                Model3D mc = mv.Content;
                if (mc is GeometryModel3D)
                {
                    GeometryModel3D gm = mc as GeometryModel3D;
                    if (gm.Geometry is MeshGeometry3D)
                    {
                        MeshGeometry3D gmm = gm.Geometry as MeshGeometry3D;
                        MeshGeometry3D gmmc = gmm.Clone();
                        gmmc.Normals = MeshGeometryHelper.CalculateNormals(gmm);
                        gm.Geometry = gmmc;
                    }
                }
            }

            for (int i = 0; i < mv.Children.Count; i++)
            {

                ModelVisual3D om = mv.Children[i] as ModelVisual3D;
                om.RecalVisNo();
            }

        }
        internal static List<Point3D> getMy3DModelPositionsAsPoints(this Model3D m)
        {

            List<Point3D> gp = new List<Point3D>();
            GeometryModel3D newModel = m as GeometryModel3D;
            if (newModel == null) return gp;
            System.Windows.Media.Media3D.MeshGeometry3D modelmesh = newModel.Geometry as MeshGeometry3D;

            for (int i = 0; i < modelmesh.Positions.Count; i++)
            {

                Point3D p = new Point3D(modelmesh.Positions[i].X, modelmesh.Positions[i].Y, modelmesh.Positions[i].Z);
                gp.Add(p);
            }
            return gp;
        }

        //moves a visual by moving all the points
        internal static GeometryModel3D setMy3DModelPositionsAsPoints(this Model3D m, List<Point3D> myPts)
        {
            //VerletIntegrator vava = new VerletIntegrator();

            GeometryModel3D newModel = m as GeometryModel3D;
            if (newModel == null) return null;
            System.Windows.Media.Media3D.MeshGeometry3D modelmesh = newModel.Geometry.Clone() as System.Windows.Media.Media3D.MeshGeometry3D;
            //newModel = new GeometryModel3D();
            if (modelmesh.Positions.Count != myPts.Count) return null;

            for (int i = 0; i < modelmesh.Positions.Count; i++)
            {

                Point3D p = new Point3D(myPts[i].X, myPts[i].Y, myPts[i].Z);

                modelmesh.Positions[i] = p;
            }

            newModel.Geometry = modelmesh;

            return newModel;
        }
        //recursive gets all geometry children in one single list
        internal static void getAllGeometryChildren(this ModelVisual3D m, List<GeometryModel3D> listobjects)
        {
            if (m.Content != null)
            {
                GeometryModel3D g = m.Content as GeometryModel3D;
                if (g != null)
                    listobjects.Add(g);
            }
            foreach (ModelVisual3D mg in m.Children)
            {
                getAllGeometryChildren(mg, listobjects);
            }


        }

        internal static GeometryModel3D scaleMyVisual(this ModelVisual3D m, double xf, double yf, double zf)
        {
            //VerletIntegrator vava = new VerletIntegrator();

            GeometryModel3D newModel = m.Content as GeometryModel3D;
            System.Windows.Media.Media3D.MeshGeometry3D modelmesh = newModel.Geometry.Clone() as System.Windows.Media.Media3D.MeshGeometry3D;
            newModel = new GeometryModel3D();
            // vava.Init(modelmesh);

            //for (int i = 0; i < vava.Positions.Length; i++)
            //{

            //    Point3D p = new Point3D(vava.Positions[i].X, vava.Positions[i].Y, vava.Positions[i].Z);
            //    p.Offset(tranV.X, tranV.Y, tranV.Z);
            //    vava.Positions[i] = p;
            //}
            //vava.TransferPositions(modelmesh);

            //newModel.Geometry = modelmesh;

            //return newModel;

            for (int i = 0; i < modelmesh.Positions.Count; i++)
            {

                Point3D p = new Point3D(modelmesh.Positions[i].X, modelmesh.Positions[i].Y, modelmesh.Positions[i].Z);
                p.X = p.X * xf;
                p.Y = p.Y * yf;
                p.Z = p.Z * zf;

                modelmesh.Positions[i] = p;
            }

            newModel.Geometry = modelmesh;

            return newModel;
        }

        //moves a visual made only of children
        internal static ModelVisual3D moveVisualChildren(this ModelVisual3D m, Vector3D tranv, Rect3D newBoundingBox = new Rect3D(), Material bboxMat = null)
        {
            ModelVisual3D replacer = new ModelVisual3D();
            if (newBoundingBox.getDiagonal() != 0 && bboxMat != null)
            {
                GeometryModel3D gm = makeBoxFromRectangle(newBoundingBox, bboxMat);
                replacer.Content = gm;
            }

            for (int i = 0; i < m.Children.Count; i++)
            {
                ModelVisual3D nm = new ModelVisual3D();
                ModelVisual3D om = m.Children[i] as ModelVisual3D;
                if (om.Content != null)
                {
                    nm.Content = om.Content.Clone();
                    GeometryModel3D gg = nm.moveMyVisual(tranv);
                    gg.Material = (om.Content as GeometryModel3D).Material;
                    nm.Content = gg;

                    nm.SetName(m.GetName() + "_CustomChild");
                    replacer.Children.Add(nm);
                }
            }


            replacer.SetName(m.GetName());
            return replacer;
        }



        //not for canvas operations
        internal static ModelVisual3D cloneMyVisual(this ModelVisual3D m)
        {

            object ml = null;
            //some we clone explicitly or else justa add the original
            if (m is RenderingModelVisual3D)
            {
                if (m is LinesVisual3D)
                {
                    LinesVisual3D mala = m as LinesVisual3D;
                    LinesVisual3D lala = new LinesVisual3D();
                    lala.Points = new List<Point3D>(mala.Points);
                    lala.Color = mala.Color;
                    lala.Thickness = mala.Thickness;
                    lala.DepthOffset = mala.DepthOffset;
                    if (mala.Transform != null)
                        lala.Transform = mala.Transform.Clone();
                    if (mala.GetName() != null)
                        lala.SetName(mala.GetName());
                    ml = lala;
                }
                else if (m is PointsVisual3D)
                {
                    PointsVisual3D mapa = m as PointsVisual3D;
                    PointsVisual3D lapa = new PointsVisual3D();
                    lapa.Points = new List<Point3D>(mapa.Points);
                    lapa.Color = mapa.Color;
                    lapa.Size = mapa.Size;
                    lapa.DepthOffset = mapa.DepthOffset;
                    if (mapa.Transform != null)
                        lapa.Transform = mapa.Transform.Clone();
                    if (mapa.GetName() != null)
                        lapa.SetName(mapa.GetName());
                    ml = lapa;
                }
                //just take the original
                else
                {
                    return m;
                }
            }
            //else if (m is ExtrudedVisual3D )
            //{
            //    ExtrudedVisual3D mao=m as ExtrudedVisual3D;
            //      ExtrudedVisual3D lao=new ExtrudedVisual3D();
            //    if (mao.GetName() != null)
            //        lao.SetName(mao.GetName()); 
            //    if (mao.Angles!=null )
            //        lao.Angles=new DoubleCollection(mao.Angles );  
            //    if (mao.Diameters!=null )
            //        lao.Diameters=new DoubleCollection(mao.Diameters );  
            //    lao.IsPathClosed=mao.IsPathClosed;  
            //    lao.IsSectionClosed=mao.IsSectionClosed;  
            //     if (mao.Path!=null )
            //        lao.Path=new Point3DCollection(mao.Path );
            //     if (mao.Section != null)
            //         lao.Section = new PointCollection(mao.Section);  
            //     lao.SectionXAxis=mao.SectionXAxis;    
            //     if (mao.TextureCoordinates!=null )
            //        lao.TextureCoordinates=new List<double>(mao.TextureCoordinates );  
            //     lao.UpVector=mao.UpVector;
            //     lao.Material = mao.Material;
            //     lao.BackMaterial = mao.BackMaterial;
            //     if (mao.Transform != null)
            //         lao.Transform = mao.Transform.Clone();   
            //    ml = lao;

            //}

            //else if (m is MeshVisual3D) 
            //{
            //    MeshVisual3D mao = m as MeshVisual3D;
            //    MeshVisual3D lao = new MeshVisual3D();

            //    if (mao.GetName() != null)
            //        lao.SetName(mao.GetName()); 
            //    lao.EdgeDiameter=mao.EdgeDiameter;
            //    lao.EdgeMaterial=mao.EdgeMaterial;
            //    lao.FaceBackMaterial=mao.FaceBackMaterial; 
            //    lao.FaceMaterial=mao.FaceMaterial;
            //    Mesh3D myMesh=mao.Mesh;
            //    if (myMesh!=null )
            //    lao.Mesh=myMesh.Clone() as Mesh3D ;  
            //    lao.SharedVertices=mao.SharedVertices;  
            //    lao.ShrinkFactor=mao.ShrinkFactor;  
            //    if (mao.TriangleIndexToFaceIndex!=null )
            //    {
            //        lao.TriangleIndexToFaceIndex=new List<int>(mao.TriangleIndexToFaceIndex ); 
            //    }
            //    lao.VertexMaterial=mao.VertexMaterial;  
            //    lao.VertexRadius=mao.VertexRadius;  
            //    lao.VertexResolution=mao.VertexResolution;
            //    if (mao.Transform != null)
            //        lao.Transform = mao.Transform.Clone();   
            //    ml = lao;


            //}
            else
            {

                ml = System.Activator.CreateInstance(m.GetType());

                if (m.GetName() != null)
                    (ml as ModelVisual3D).SetName(m.GetName());
                if (m.Content != null)
                {

                    (ml as ModelVisual3D).Content = m.Content.Clone();

                }
                if (m.Transform != null)
                    (ml as ModelVisual3D).Transform = m.Transform.Clone();
            }

            foreach (object mc in (m as ModelVisual3D).Children)
            {
                if (mc is ModelVisual3D)
                {
                    (ml as ModelVisual3D).Children.Add((mc as ModelVisual3D).cloneMyVisual());
                }
                else
                {

                }
            }
            return (ml as ModelVisual3D);
        }



        internal static void cloneMyVisualFreezable(this ModelVisual3D hardcoded, List<Model3D> theList)
        {

            if (hardcoded.Content != null && hardcoded.Content is Model3D)
            {
                Model3D frozen = hardcoded.Content.Clone();
                frozen.Freeze();
                theList.Add(frozen);
            }



            foreach (object mc in (hardcoded as ModelVisual3D).Children)
            {
                if (mc is ModelVisual3D)
                {
                    (mc as ModelVisual3D).cloneMyVisualFreezable(theList);
                }

            }

        }
        //can work from different thread
        //internal static ModelVisual3D cloneMyVisualTS(this ModelVisual3D m)
        //{

        //    object ml = null;
        //    //some we clone explicitly or else justa add the original
        //    if (m is RenderingModelVisual3D)
        //    {
        //        if (m is LinesVisual3D)
        //        {
        //            LinesVisual3D mala = m as LinesVisual3D;

        //            LinesVisual3D lala = new LinesVisual3D();
        //            lala.Points = new List<Point3D>(mala.Points);
        //            lala.Color = mala.Color;
        //            lala.Thickness = mala.Thickness;
        //            lala.DepthOffset = mala.DepthOffset;

        //            if (mala.Transform != null)
        //                lala.Transform = mala.Transform.Clone();

        //            ml = lala;
        //        }
        //        else if (m is PointsVisual3D)
        //        {
        //            PointsVisual3D mapa = m as PointsVisual3D;
        //            PointsVisual3D lapa = new PointsVisual3D();
        //            lapa.Points = new List<Point3D>(mapa.Points);
        //            lapa.Color = mapa.Color;
        //            lapa.Size = mapa.Size;
        //            lapa.DepthOffset = mapa.DepthOffset;
        //            if (mapa.Transform != null)
        //                lapa.Transform = mapa.Transform.Clone();

        //            ml = lapa;
        //        }
        //        //just take the original
        //        else
        //        {
        //            return m;
        //        }
        //    }

        //    else
        //    {

        //        ml = System.Activator.CreateInstance(m.GetType());
        //        Model3D m3f = null;
        //        if (m.Content != null)
        //            m3f = m.Content.GetAsFrozen() as Model3D;
        //        if (m3f != null)
        //        {

        //            (ml as ModelVisual3D).Content = m3f.Clone();

        //        }

        //        Transform3D otf = null;
        //        if (m.Transform != null)
        //            otf = m.Transform.GetAsFrozen() as Transform3D;
        //        if (otf != null)
        //            (ml as ModelVisual3D).Transform = otf.Clone();

        //    }

        //    foreach (object mc in (m as ModelVisual3D).Children)
        //    {
        //        if (mc is ModelVisual3D)
        //        {
        //            (ml as ModelVisual3D).Children.Add((mc as ModelVisual3D).cloneMyVisualTS());
        //        }
        //        else
        //        {

        //        }
        //    }
        //    return (ml as ModelVisual3D);
        //}


        internal static void colorVisualAndChildren(this ModelVisual3D m, Color coco)
        {

            Material mao = new DiffuseMaterial(new SolidColorBrush(coco));
            if (m.Content != null)
            {
                GeometryModel3D gg = m.Content as GeometryModel3D;
                if (gg != null)
                {
                    gg.Material = mao;
                    gg.BackMaterial = mao;
                }
            }

            for (int i = 0; i < m.Children.Count; i++)
            {

                ModelVisual3D om = m.Children[i] as ModelVisual3D;
                om.colorVisualAndChildren(coco);
            }

        }

        internal static void materialVisualAndChildren(this ModelVisual3D m, Material mat)
        {


            if (m.Content != null)
            {
                GeometryModel3D gg = m.Content as GeometryModel3D;
                if (gg != null)
                {
                    gg.Material = mat;
                    gg.BackMaterial = mat;
                    // MeshGeometry3D mg = gg.Geometry as MeshGeometry3D;
                    //generate texture coords
                    if ((gg.Geometry as MeshGeometry3D).TextureCoordinates == null || (gg.Geometry as MeshGeometry3D).TextureCoordinates.Count == 0)
                    {
                        PointCollection pc = new PointCollection();
                        for (int i = 0; i < (gg.Geometry as MeshGeometry3D).TriangleIndices.Count; i++)
                        {
                            pc.Add(new Point(0, 0));
                            pc.Add(new Point(1, 0));
                            pc.Add(new Point(1, 1));
                            pc.Add(new Point(0, 1));


                        }
                       (gg.Geometry as MeshGeometry3D).TextureCoordinates = pc;
                    }
                }
            }

            for (int i = 0; i < m.Children.Count; i++)
            {

                ModelVisual3D om = m.Children[i] as ModelVisual3D;
                om.materialVisualAndChildren(mat);
            }

        }

        internal static ModelVisual3D cloneVisualAndChildren(this ModelVisual3D m)
        {
            ModelVisual3D replacer = new ModelVisual3D();

            if (m.Content != null)
            {
                replacer.Content = m.Content.Clone();
                GeometryModel3D ggo = replacer.moveMyVisual(new Vector3D(0, 0, 0));
                ggo.Material = (m.Content as GeometryModel3D).Material;
                replacer.Content = ggo;
            }
            replacer.SetName(m.GetName() + "_Clone");

            for (int i = 0; i < m.Children.Count; i++)
            {
                ModelVisual3D nm = new ModelVisual3D();
                ModelVisual3D om = m.Children[i] as ModelVisual3D;
                if (om.Content != null)
                {
                    nm.Content = om.Content.Clone();
                    GeometryModel3D gg = nm.moveMyVisual(new Vector3D(0, 0, 0));
                    gg.Material = (om.Content as GeometryModel3D).Material;
                    nm.Content = gg;
                    nm.SetName(m.GetName() + "_CustomChildClone");
                    replacer.Children.Add(nm);
                }
            }


            //replacer.SetName(m.GetName());
            return replacer;
        }

        internal static void addFlatVisualAndChildren(this ModelVisual3D m, ModelVisual3D toAdd)
        {
            ModelVisual3D replacer = new ModelVisual3D();

            if (toAdd.Content != null)
            {
                replacer.Content = toAdd.Content.Clone();
                GeometryModel3D ggo = replacer.moveMyVisual(new Vector3D(0, 0, 0));
                ggo.Material = (toAdd.Content as GeometryModel3D).Material;
                replacer.Content = ggo;
            }
            replacer.SetName(toAdd.GetName() + "_Add");
            m.Children.Add(replacer);

            for (int i = 0; i < toAdd.Children.Count; i++)
            {
                ModelVisual3D nm = new ModelVisual3D();
                ModelVisual3D om = toAdd.Children[i] as ModelVisual3D;
                if (om.Content != null)
                {
                    nm.Content = om.Content.Clone();
                    GeometryModel3D gg = nm.moveMyVisual(new Vector3D(0, 0, 0));
                    gg.Material = (om.Content as GeometryModel3D).Material;
                    nm.Content = gg;
                    nm.SetName(m.GetName() + "_CustomChildAdd");
                    m.Children.Add(nm);
                }
            }



        }

        internal static ModelVisual3D fitVisualAndChildren(this ModelVisual3D m, Rect3D newBox)
        {


            double newscale = 1;

            Vector3D tomove = new Vector3D(0, 0, 0);
            if (newBox.IsEmpty == false)
            {
                Rect3D oldbb = m.getBBRecursive();

                tomove = Point3D.Subtract(newBox.rectcenter(), oldbb.rectcenter());
                double fx = newBox.SizeX / oldbb.SizeX;
                double fy = newBox.SizeY / oldbb.SizeY;
                double fz = newBox.SizeZ / oldbb.SizeZ;
                newscale = Math.Min(Math.Min(fx, fy), fz);


            }
            ModelVisual3D replacer = new ModelVisual3D();

            if (m.Content != null)
            {
                replacer.Content = m.Content.Clone();
                GeometryModel3D ggo = replacer.moveMyVisual(tomove);
                replacer.Content = ggo;
                ggo = replacer.scaleMyVisual(newscale, newscale, newscale);
                ggo.Material = (m.Content as GeometryModel3D).Material;
                replacer.Content = ggo;
            }
            replacer.SetName(m.GetName() + "_CloneFit");

            for (int i = 0; i < m.Children.Count; i++)
            {
                ModelVisual3D nm = new ModelVisual3D();
                ModelVisual3D om = m.Children[i] as ModelVisual3D;
                if (om.Content != null)
                {
                    nm.Content = om.Content.Clone();
                    GeometryModel3D gg = nm.moveMyVisual(tomove);
                    nm.Content = gg;
                    gg = nm.scaleMyVisual(newscale, newscale, newscale);
                    gg.Material = (om.Content as GeometryModel3D).Material;
                    nm.Content = gg;
                    nm.SetName(m.GetName() + "_CustomChildCloneFit");
                    replacer.Children.Add(nm);
                }
            }


            //replacer.SetName(m.GetName());
            return replacer;
        }
        internal static void addAllChildrenFlatRecursive(this ModelVisual3D m, List<ModelVisual3D> ch)
        {
            ch.Add(m);
            foreach (ModelVisual3D mm in m.Children)
            {
                mm.addAllChildrenFlatRecursive(ch);
            }
        }

        internal static ModelVisual3D translateVisualAndChildren(this ModelVisual3D m, double deltaX, double deltaY, double deltaZ)
        {




            Vector3D tomove = new Vector3D(deltaX, deltaY, deltaZ);

            ModelVisual3D replacer = new ModelVisual3D();

            if (m.Content != null)
            {
                replacer.Content = m.Content.Clone();
                GeometryModel3D ggo = replacer.moveMyVisual(tomove);
                ggo.Material = (m.Content as GeometryModel3D).Material;
                replacer.Content = ggo;
            }
            replacer.SetName(m.GetName() + "_CloneMove");

            for (int i = 0; i < m.Children.Count; i++)
            {
                ModelVisual3D nm = new ModelVisual3D();
                ModelVisual3D om = m.Children[i] as ModelVisual3D;
                if (om.Content != null)
                {
                    nm.Content = om.Content.Clone();
                    GeometryModel3D gg = nm.moveMyVisual(tomove);
                    gg.Material = (om.Content as GeometryModel3D).Material;
                    nm.Content = gg;
                    nm.SetName(m.GetName() + "_CustomChildCloneMove");
                    replacer.Children.Add(nm);
                }
            }


            //replacer.SetName(m.GetName());
            return replacer;
        }

        internal static ModelVisual3D fitToBaseVisualAndChildren(this ModelVisual3D m, Rect3D newBox)
        {


            double newscale = 1;

            Vector3D tomove = new Vector3D(0, 0, 0);
            if (newBox.IsEmpty == false)
            {
                Rect3D oldbb = m.getBBRecursive();

                tomove = Point3D.Subtract(newBox.rectcenter(), oldbb.rectcenter());
                double fx = newBox.SizeX / oldbb.SizeX;
                double fy = newBox.SizeY / oldbb.SizeY;
                newscale = Math.Min(fx, fy);


            }
            ModelVisual3D replacer = new ModelVisual3D();

            if (m.Content != null)
            {
                replacer.Content = m.Content.Clone();
                GeometryModel3D ggo = replacer.moveMyVisual(tomove);
                replacer.Content = ggo;
                ggo = replacer.scaleMyVisual(newscale, newscale, newscale);
                ggo.Material = (m.Content as GeometryModel3D).Material;
                replacer.Content = ggo;
            }
            replacer.SetName(m.GetName() + "_CloneFit");

            for (int i = 0; i < m.Children.Count; i++)
            {
                ModelVisual3D nm = new ModelVisual3D();
                ModelVisual3D om = m.Children[i] as ModelVisual3D;
                if (om.Content != null)
                {
                    nm.Content = om.Content.Clone();
                    GeometryModel3D gg = nm.moveMyVisual(tomove);
                    nm.Content = gg;
                    gg = nm.scaleMyVisual(newscale, newscale, newscale);
                    gg.Material = (om.Content as GeometryModel3D).Material;
                    nm.Content = gg;
                    nm.SetName(m.GetName() + "_CustomChildCloneFit");
                    replacer.Children.Add(nm);
                }
            }


            //need to move up
            double moveZ = 0;
            if (newBox.IsEmpty == false)
            {
                Rect3D oldbb = replacer.getBBRecursive();
                moveZ = oldbb.SizeZ * 0.5 - newBox.SizeZ * 0.5;




            }

            return replacer.translateVisualAndChildren(0, 0, moveZ);
        }


        internal static ModelVisual3D scaleVisualAndChildren(this ModelVisual3D m, double xf, double yf, double zf)
        {

            ModelVisual3D replacer = new ModelVisual3D();

            if (m.Content != null)
            {
                replacer.Content = m.Content.Clone();
                GeometryModel3D ggo = replacer.scaleMyVisual(xf, yf, zf);
                ggo.Material = (m.Content as GeometryModel3D).Material;
                replacer.Content = ggo;
            }
            replacer.SetName(m.GetName() + "_CloneScale");

            for (int i = 0; i < m.Children.Count; i++)
            {
                ModelVisual3D nm = new ModelVisual3D();
                ModelVisual3D om = m.Children[i] as ModelVisual3D;
                if (om.Content != null)
                {
                    nm.Content = om.Content.Clone();
                    GeometryModel3D gg = nm.scaleMyVisual(xf, yf, zf);
                    gg.Material = (om.Content as GeometryModel3D).Material;
                    nm.Content = gg;
                    nm.SetName(m.GetName() + "_CustomChildCloneScale");
                    replacer.Children.Add(nm);
                }
            }


            //replacer.SetName(m.GetName());
            return replacer;
        }

        //gets bounding box
        internal static Rect3D getBBRecursive(this ModelVisual3D m)
        {
            Rect3D bb = Rect3D.Empty; ;// = new Rect3D();
            if (m.Content != null) bb.Union(m.Content.Bounds);
            for (int i = 0; i < m.Children.Count; i++)
            {

                bb.Union((m.Children[i] as ModelVisual3D).getBBRecursive());
            }
            return bb;
        }

        internal static Point3D getboxcenter(this Model3D m)
        {
            Point3D gbc = new Point3D();
            gbc.X = m.Bounds.Location.X + m.Bounds.SizeX * 0.5;
            gbc.Y = m.Bounds.Location.Y + m.Bounds.SizeY * 0.5;
            gbc.Z = m.Bounds.Location.Z + m.Bounds.SizeZ * 0.5;
            return gbc;
        }

        //by center

        internal static Rect3D makedefaultbox(this Point3D locpoint)
        {
            return new Rect3D(locpoint.X.nodespaceconvert() - PUPPIGUISettings.nodeSide * 0.5, locpoint.Y.nodespaceconvert() - PUPPIGUISettings.nodeSide * 0.5, 0, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeHeight);
        }
        //in 3d
        internal static Rect3D makedefaultboxD3(this Point3D locpoint)
        {
            return new Rect3D(locpoint.X.nodespaceconvert() - PUPPIGUISettings.nodeSide * 0.5, locpoint.Y.nodespaceconvert() - PUPPIGUISettings.nodeSide * 0.5, locpoint.Z - PUPPIGUISettings.nodeHeight / 2, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeSide, PUPPIGUISettings.nodeHeight);
        }
        //fit inside node
        internal static Rect3D makedefaultfitinnodebox(this Point3D locpoint)
        {
            return new Rect3D(locpoint.X.nodespaceconvert() - (PUPPIGUISettings.nodeSide - PUPPIGUISettings.ioWidth) * 0.5, locpoint.Y.nodespaceconvert() - (PUPPIGUISettings.nodeSide + PUPPIGUISettings.solidConnectionSize) * 0.5, PUPPIGUISettings.solidConnectionSize * 0.5, PUPPIGUISettings.nodeSide - PUPPIGUISettings.ioWidth, PUPPIGUISettings.nodeSide - PUPPIGUISettings.solidConnectionSize, PUPPIGUISettings.nodeHeight - PUPPIGUISettings.solidConnectionSize);
        }

        internal static Rect3D makeSizeBox(this Point3D locpoint, double sizeX, double sizeY, double sizeZ)
        {
            return new Rect3D(locpoint.X - sizeX * 0.5, locpoint.Y - sizeY * 0.5, locpoint.Z - sizeZ * 0.5, sizeX, sizeY, sizeZ);
        }

        //converts location and size to exact node spacing
        internal static Rect3D locationnodeSpacing(this Rect3D myrect)
        {
            double xnew = myrect.Location.X;
            xnew = xnew.nodespaceconvert();


            double ynew = myrect.Location.Y;
            ynew = ynew.nodespaceconvert();

            double xsnew = myrect.SizeX;
            xsnew = xsnew.nodespaceconvert();
            //make sure at least as big
            if (xnew + xsnew < myrect.X + myrect.SizeX) xsnew += PUPPIGUISettings.nodeSpacing;

            double ysnew = myrect.SizeY;
            ysnew = ysnew.nodespaceconvert();
            if (ynew + ysnew < myrect.Y + myrect.SizeY) ysnew += PUPPIGUISettings.nodeSpacing;


            Rect3D newrect = new Rect3D(xnew, ynew, myrect.Location.Z, xsnew, ysnew, myrect.SizeZ);
            return newrect;
        }


        //projects vector onto other vector
        internal static Vector3D project(this Vector3D myself, Vector3D otherv)
        {

            Vector3D newproj = new Vector3D();
            if (otherv.Length == 0) return newproj;

            newproj = Vector3D.Multiply(Vector3D.DotProduct(myself, otherv) / otherv.LengthSquared, otherv);
            return newproj;
        }
        //internal static Vector3D myVectorRotate(this Vector3D myself,Vector3D ax, double ar)
        //{

        //    Vector3D newproj = new Vector3D();
        //    if (otherv.Length == 0) return newproj;

        //    newproj = Vector3D.Multiply(Vector3D.DotProduct(myself, otherv) / otherv.LengthSquared, otherv);
        //    return newproj;
        //}
        //converts evctor into rectangle

        internal static Rect3D v2rect(this Vector3D myself, Point3D vorigin, double pad)
        {

            Rect3D newrect = new Rect3D();
            if (myself.Length == 0 || pad == 0) return newrect;
            Point3D vend = Point3D.Add(vorigin, myself);
            Point3D rloc = new Point3D(Math.Min(vorigin.X, vend.X), Math.Min(vorigin.Y, vend.Y), Math.Min(vorigin.Z, vend.Z));
            Point3D rend = new Point3D(Math.Max(vorigin.X, vend.X), Math.Max(vorigin.Y, vend.Y), Math.Max(vorigin.Z, vend.Z));
            rloc.Offset(-pad, -pad, -pad);
            rend.Offset(pad, pad, pad);
            Vector3D newdiag = Vector3D.Subtract(rend.ToVector3D(), rloc.ToVector3D());
            newrect.Location = rloc;
            newrect.Size = new Size3D(newdiag.X, newdiag.Y, newdiag.Z);

            //newproj = Vector3D.Multiply(Vector3D.DotProduct(myself, otherv) / otherv.LengthSquared, otherv);
            return newrect;
        }

        internal static bool isinsiderectangle(this Point3D testpoint, Rect3D tangle)
        {
            bool isinside = false;
            if (testpoint == null || tangle == null) return false;
            if (testpoint.X >= tangle.Location.X && testpoint.X <= tangle.Location.X + tangle.SizeX && testpoint.Y >= tangle.Location.Y && testpoint.Y <= tangle.Location.Y + tangle.SizeY)
            {
                isinside = true;
            }
            return isinside;
        }
        //gets the closest point that intersects a rectangle 
        //internal static Point3D findentrypoint(this Rect3D myself, Point3D position)
        //{
        //    Point3D entryp = new Point3D(position.X, position.Y, position.Z);
        //    if (position.isinsiderectangle(myself) == true)
        //    {
        //        return entryp;
        //    }
        //    //makes direction big enough to ensure it intersects the nearest segments
        //    Vector3D direction = Point3D.Subtract(new Point3D(myself.Location.X + myself.SizeX *0.5, myself.Location.Y + myself.SizeY *0.5, 0), new Point3D(position.X, position.Y, 0));

        //    if (direction.Length == 0) return entryp;
        //    //check against foru sides
        //    Point3D ep1 = new Point3D(-999, -999, -999);
        //    Point3D ep2 = new Point3D(-999, -999, -999);
        //    Point3D ep3 = new Point3D(-999, -999, -999);
        //    Point3D ep4 = new Point3D(-999, -999, -999);
        //    bool foundone = false;

        //    if (position.segmentintersects2d(direction, myself.Location, new Vector3D(myself.SizeX, 0, 0), out ep1) == true)  //,out entryp ) )
        //    {
        //        foundone = true;
        //        //return entryp; 
        //    }
        //    if (position.segmentintersects2d(direction, Point3D.Add(myself.Location, new Vector3D(0, myself.SizeY, 0)), new Vector3D(myself.SizeX, 0, 0), out ep2))  //,out entryp ) )
        //    {
        //        foundone = true;
        //        //return entryp;
        //    }

        //    if (position.segmentintersects2d(direction, myself.Location, new Vector3D(0, myself.SizeY, 0), out ep3))  //,out entryp ) )
        //    {
        //        foundone = true;
        //        //return entryp;
        //    }
        //    if (position.segmentintersects2d(direction, Point3D.Add(myself.Location, new Vector3D(myself.SizeX, 0, 0)), new Vector3D(0, myself.SizeY, 0), out ep4))  //,out entryp ) )
        //    {
        //        foundone = true;
        //        //return entryp;
        //    }
        //    if (foundone == true)
        //    {
        //        double dist1 = position.DistanceTo(ep1);
        //        double dist2 = position.DistanceTo(ep2);
        //        double dist3 = position.DistanceTo(ep3);
        //        double dist4 = position.DistanceTo(ep4);

        //        if (dist1 <= dist2 && dist1 <= dist3 && dist1 <= dist4)
        //        {
        //            entryp = ep1;
        //        }
        //        else if (dist2 <= dist1 && dist2 <= dist3 && dist2 <= dist4)
        //        {
        //            entryp = ep2;

        //        }
        //        else if (dist3 <= dist1 && dist3 <= dist2 && dist3 <= dist4)
        //        {
        //            entryp = ep3;
        //        }
        //        else
        //        {
        //            if (ep4.Z != -999)
        //            {
        //                entryp = ep4;
        //            }
        //            else
        //            {
        //                entryp = new Point3D(position.X, position.Y, position.Z);
        //            }
        //        }

        //    }
        //    else
        //    {

        //        entryp = new Point3D(position.X, position.Y, position.Z);
        //    }
        //    return entryp;
        //}


        //adds padding around a rectangle

        //3-17-14
        //new version for now just bottom
        internal static Point3D findentrypointsimple(this Rect3D myself)
        {
            double nonodiv = 1.0 / (double)(PUPPIGUISettings.maxConnPerSpace + 1);
            return new Point3D((myself.Location.X + myself.SizeX * 0.5).nodespacecenterconvert(PUPPIGUISettings.nodeSpacing * nonodiv), (myself.Location.Y - PUPPIGUISettings.nodeSpacing * nonodiv).nodespacecenterconvert(PUPPIGUISettings.nodeSpacing * nonodiv), myself.Location.Z);
        }


        internal static Rect3D padme(this Rect3D myself, double padval)
        {
            if (padval > 0)
            {
                return new Rect3D(myself.Location.X - padval, myself.Location.Y - padval, myself.Location.Z, myself.SizeX + padval * 2, myself.SizeY + padval * 2, myself.SizeZ);
            }
            else
            {
                return myself;
            }

        }
        //makes rect very wide
        internal static Rect3D extendx(this Rect3D myself, Rect3D bbox)
        {
            if (!bbox.IsEmpty)
            {
                return new Rect3D(bbox.Location.X - bbox.SizeX, myself.Location.Y, myself.Location.Z, 2 * bbox.SizeX, myself.SizeY, myself.SizeZ);
            }
            else
            {
                return myself;
            }

        }
        //gets the diagonal
        internal static double getDiagonal(this Rect3D myself)
        {
            return Math.Sqrt(myself.SizeX * myself.SizeX + myself.SizeY * myself.SizeY + myself.SizeZ * myself.SizeZ);
        }
        //checks they are equal within toloerance
        //gets the diagonal
        internal static bool isEqualToler(this Rect3D myself, Rect3D otherR)
        {
            if (Math.Abs(myself.X - otherR.X) < PUPPIGUISettings.intersectToler && Math.Abs(myself.Y - otherR.Y) < PUPPIGUISettings.intersectToler && Math.Abs(myself.Z - otherR.Z) < PUPPIGUISettings.intersectToler && Math.Abs(myself.SizeX - otherR.SizeX) < PUPPIGUISettings.intersectToler && Math.Abs(myself.SizeY - otherR.SizeY) < PUPPIGUISettings.intersectToler && Math.Abs(myself.SizeZ - otherR.SizeZ) < PUPPIGUISettings.intersectToler)
                return true;
            else return false;
        }


        //gets the distance to exit a rectangle based on point and direction
        internal static double findexitdistance(this Rect3D myself, Point3D position, Vector3D direction)
        {

            if (position.isinsiderectangle(myself) == false) return 0;
            //makes direction big enough to ensure it intersects at least one segment
            direction.Normalize();
            direction = Vector3D.Multiply(Math.Sqrt(myself.SizeX * myself.SizeX + myself.SizeY * myself.SizeY) + 1, direction);
            if (direction.Length == 0) return 0;
            //check against foru sides
            Point3D op = new Point3D();
            if (position.segmentintersects2d(direction, myself.Location, new Vector3D(myself.SizeX, 0, 0), out op))
            {
                if (direction.Y != 0)
                {
                    return Math.Abs(position.Y - myself.Location.Y) / Math.Abs(direction.Y) * direction.Length;
                }
                else
                {
                    return 0;
                }
            }
            if (position.segmentintersects2d(direction, Point3D.Add(myself.Location, new Vector3D(0, myself.SizeY, 0)), new Vector3D(myself.SizeX, 0, 0), out op))
            {
                if (direction.Y != 0)
                {
                    return Math.Abs(position.Y - (myself.Location.Y + myself.SizeY)) / Math.Abs(direction.Y) * direction.Length;
                }
                else
                {
                    return 0;
                }
            }

            if (position.segmentintersects2d(direction, myself.Location, new Vector3D(0, myself.SizeY, 0), out op))
            {
                if (direction.X != 0)
                {
                    return Math.Abs(position.X - myself.Location.X) / Math.Abs(direction.X) * direction.Length;
                }
                else
                {
                    return 0;
                }
            }
            if (position.segmentintersects2d(direction, Point3D.Add(myself.Location, new Vector3D(myself.SizeX, 0, 0)), new Vector3D(0, myself.SizeY, 0), out op))
            {
                if (direction.X != 0)
                {
                    return Math.Abs(position.X - (myself.Location.X + myself.SizeX)) / Math.Abs(direction.X) * direction.Length;
                }
                else
                {
                    return 0;
                }
            }

            return 0;
        }

        internal static bool segmentintersects2d(this Point3D myself, Vector3D mydirection, Point3D otherorigin, Vector3D otherdirection, out Point3D ipoint)
        {

            linesegment l1 = new linesegment(myself, Point3D.Add(myself, mydirection));
            linesegment l2 = new linesegment(otherorigin, Point3D.Add(otherorigin, otherdirection));

            ipoint = new Point3D(-999, -999, -999);
            return l1.intersects(l2, out ipoint);

            // //solve systme of two equations to get line intersection
            // //y=ax+b
            // //for this segment
            // double x11, x12, y11, y12, a1, b1, x21, x22, y21, y22, a2, b2, int_x, int_y;
            // y12 = Point3D.Add(myself, mydirection).Y;
            // y11 = myself.Y;
            // x11 = myself.X;
            // x12 = Point3D.Add(myself, mydirection).X;
            // //for the other segment
            // y22 = Point3D.Add(otherorigin, otherdirection).Y;
            // y21 = otherorigin.Y;
            // x21 = otherorigin.X;
            // x22 = Point3D.Add(otherorigin, otherdirection).X;
            // //check if they are the same line
            // if (x11 == x21 && y11 == y21 && x12 == x22 && y12 == y22)
            // {

            //     //returns the mid point if segemnts are the same
            //     ipoint = new Point3D((x11+x12)/2, (y11+y12)/2, 0);
            //     return true;

            // }


            // if (y11 == y12 && x11 == x12)
            // {
            //     return false;
            // }

            //if (y21 == y22 && x21 == x22)
            // {
            //     return false;
            // }

            // //cheat a bit to use the same eqn for hor and vert lines
            // if (y11 == y12)
            // {
            //     y12 += y12 * 0.0001;
            // }
            // else if (x11 == x12)
            // {
            //     x12 += x12 * 0.0001;
            // }
            // //slope components
            // a1 = (y12 - y11) / (x12 - x11);
            // b1 = y11 - x11 * (y12 - y11) / (x12 - x11);


            // //cheat a bit to use the same eqn for hor and vert lines
            //if (y21 == y22)
            // {
            //     y22 -= y22 * 0.0001;
            // }
            // else if (x21 == x22)
            // {
            //     x22 -= x22 * 0.0001;
            // }
            // //slope components
            // a2 = (y22 - y21) / (x22 - x21);
            // b2 = y21 - x21 * (y22 - y21) / (x22 - x21);
            // if (a1 != a2)
            // {
            //     int_x = (b2 - b1) / (a1 - a2);
            // }
            // else
            // {
            //     return false;
            // }
            //     int_y = a1 * int_x + b1;

            //     bool on_seg1 = false;
            // bool on_seg2 = false;
            // if (Math.Abs(int_x - x11) <= Math.Abs(x12 - x11) && Math.Abs(int_x - x12) <= Math.Abs(x12 - x11) && Math.Abs(int_y - y11) <= Math.Abs(y12 - y11) && Math.Abs(int_y - y12) <= Math.Abs(y12 - y11)) on_seg1 = true;
            // if (Math.Abs(int_x - x21) <= Math.Abs(x22 - x21) && Math.Abs(int_x - x22) <= Math.Abs(x22 - x21) && Math.Abs(int_y - y21) <= Math.Abs(y22 - y21) && Math.Abs(int_y - y22) <= Math.Abs(y22 - y21)) on_seg2 = true;
            // if (on_seg1 == true && on_seg2 == true)
            // {
            //     ipoint.X=int_x;
            //     ipoint.Y=int_y;
            //     ipoint.Z = myself.Z; 
            //     return true;
            // }
            // else
            // {
            //     return false;
            // }
        }
        //gets the angle with another vector +/- radians
        internal static double anglewithrad(this Vector3D myv, Vector3D otherv)
        {

            double ang = 0;
            if (myv.Length == 0 || otherv.Length == 0) return ang;
            double thecosine = Vector3D.DotProduct(myv, otherv) / myv.Length / otherv.Length;
            Vector3D cp = Vector3D.CrossProduct(myv, otherv);
            double thesine = cp.Length * Math.Sign(cp.Z) / myv.Length / otherv.Length;
            if (thesine == 0)
            {
                if (thecosine > 0)
                {
                    ang = 0;
                }
                else
                {
                    ang = Math.PI;
                }
            }
            else if (thecosine == 0)
            {
                if (thesine > 0)
                {
                    ang = Math.PI * 0.5;
                }
                else
                {
                    ang = Math.PI * 1.5;
                }

            }
            else
            {
                if (thesine > 0)
                {
                    ang = Math.Acos(thecosine);
                }
                else
                {
                    ang = 2 * Math.PI - Math.Acos(thecosine);
                }
            }
            return ang;
        }
        //gets the angle with another vector +/- radians
        //in 3d
        internal static double anglewithradNormal(this Vector3D myv, Vector3D otherv, Vector3D normal)
        {

            double ang = 0;
            if (myv.Length == 0 || otherv.Length == 0) return ang;
            double thecosine = Vector3D.DotProduct(myv, otherv) / myv.Length / otherv.Length;
            Vector3D cp = Vector3D.CrossProduct(myv, otherv);
            double thesine = cp.Length * Math.Sign(Vector3D.DotProduct(cp, normal)) / myv.Length / otherv.Length;
            if (thesine == 0)
            {
                if (thecosine > 0)
                {
                    ang = 0;
                }
                else
                {
                    ang = Math.PI;
                }
            }
            else if (thecosine == 0)
            {
                if (thesine > 0)
                {
                    ang = Math.PI * 0.5;
                }
                else
                {
                    ang = Math.PI * 1.5;
                }

            }
            else
            {
                if (thesine > 0)
                {
                    ang = Math.Acos(thecosine);
                }
                else
                {
                    ang = 2 * Math.PI - Math.Acos(thecosine);
                }
            }
            return ang;
        }
        internal static Point3D rectcenter(this Rect3D tangle)
        {
            Point3D p3d = new Point3D(-999, -999, -999);
            if (tangle == null) return p3d;
            p3d = new Point3D(tangle.Location.X + tangle.SizeX * 0.5, tangle.Location.Y + tangle.SizeY * 0.5, tangle.Location.Z + tangle.SizeZ * 0.5);
            return p3d;
        }



        //draws a rectangle as screen lines
        //test draw
        internal static void testdraw(this Rect3D tangle, HelixViewport3D v2draw)
        {
            LinesVisual3D lins = new LinesVisual3D();
            Point3DCollection testpts = new Point3DCollection();
            testpts.Add(tangle.Location);
            Point3D nextp = Point3D.Add(tangle.Location, new Vector3D(tangle.SizeX, 0, 0));
            testpts.Add(nextp);
            lins.Points = testpts;
            v2draw.Children.Add(lins);

            lins = new LinesVisual3D();
            testpts = new Point3DCollection();
            testpts.Add(nextp);

            nextp = Point3D.Add(nextp, new Vector3D(0, tangle.SizeY, 0));
            testpts.Add(nextp);
            lins.Points = testpts;
            v2draw.Children.Add(lins);

            lins = new LinesVisual3D();
            testpts = new Point3DCollection();
            testpts.Add(nextp);

            nextp = Point3D.Add(nextp, new Vector3D(-tangle.SizeX, 0, 0));
            testpts.Add(nextp);
            lins.Points = testpts;
            v2draw.Children.Add(lins);

            lins = new LinesVisual3D();
            testpts = new Point3DCollection();
            testpts.Add(nextp);

            nextp = Point3D.Add(nextp, new Vector3D(0, -tangle.SizeY, 0));
            testpts.Add(nextp);

            lins.Points = testpts;
            v2draw.Children.Add(lins);
        }
        //makes a ribbon from a point-dir. also retuurns the normal for extrusion upwards
        internal static IList<Point3D> makeribbon(this Point3D start, Vector3D direction, double width, Vector3D previousmove, out Vector3D struline)
        {
            IList<Point3D> mr = new List<Point3D>();
            struline = new Vector3D();
            //vertical move
            if (Vector3D.CrossProduct(direction, new Vector3D(0, 0, 1)).Length == 0 && previousmove.Length != 0)
            {
                Vector3D leftme = Vector3D.CrossProduct(previousmove, new Vector3D(0, 0, 1));
                leftme.Normalize();
                leftme = Vector3D.Multiply(leftme, width * 0.5);
                Point3D lstart = Point3D.Add(start, leftme);
                Vector3D rightme = leftme;
                rightme.Negate();
                Point3D rstart = Point3D.Add(start, rightme);
                Vector3D moveall = new Vector3D();
                moveall = direction;
                moveall.Normalize();
                moveall = Vector3D.Multiply(moveall, direction.Length);
                Point3D lend = Point3D.Add(lstart, moveall);
                Point3D rend = Point3D.Add(rstart, moveall);
                mr.Add(lstart);
                mr.Add(rstart);
                mr.Add(rend);
                //mr.Add(lend);
                mr.Add(lend);
                struline = Vector3D.CrossProduct(rightme, moveall);
                struline.Normalize();
                struline = Vector3D.Multiply(struline, PUPPIGUISettings.ribThick);

            }
            else
            {
                //offset start
                Vector3D backme = new Vector3D();
                backme = direction;
                backme.Negate();
                backme.Normalize();
                backme = Vector3D.Multiply(width * 0.5, backme);
                Vector3D leftme = Vector3D.CrossProduct(backme, new Vector3D(0, 0, 1));
                Point3D lstart = Point3D.Add(Point3D.Add(start, backme), leftme);
                Vector3D rightme = Vector3D.CrossProduct(backme, new Vector3D(0, 0, -1));
                Point3D rstart = Point3D.Add(Point3D.Add(start, backme), rightme);
                Vector3D moveall = new Vector3D();
                moveall = direction;
                moveall.Normalize();
                moveall = Vector3D.Multiply(moveall, direction.Length + width);
                Point3D lend = Point3D.Add(lstart, moveall);
                Point3D rend = Point3D.Add(rstart, moveall);
                //ad points
                mr.Add(lstart);
                mr.Add(rstart);
                mr.Add(rend);
                //mr.Add(lend);
                mr.Add(lend);
                // mr.Add(rstart);  
                struline = Vector3D.CrossProduct(rightme, moveall);
                struline.Normalize();
                struline = Vector3D.Multiply(struline, PUPPIGUISettings.ribThick);

            }
            return mr;

        }
        //makes a ribbon from a point-dir. also retuurns the normal for extrusion upwards
        internal static List<Point> makeroundedrect(double sizx, double sizy, double cutradius)
        {
            if (cutradius > Math.Min(sizx, sizy) * 0.5) cutradius = Math.Min(sizx, sizy) * 0.5;
            if (cutradius == 0) cutradius = Math.Min(sizx, sizy) * 0.01;

            List<Point> mr = new List<Point>();


            ////one rounded corner top right
            //mr.Add(new Point(sizx * 0.5 - cutradius, sizy * 0.5));
            //mr.Add(new Point(sizx * 0.5 - cutradius*0.866, sizy * 0.5-cutradius*0.5 ));
            //mr.Add(new Point(sizx * 0.5 - cutradius * 0.5, sizy * 0.5 - cutradius * 0.866));
            //mr.Add(new Point(sizx * 0.5 , sizy * 0.5 - cutradius ));
            ////one rounded corner bottom right
            //mr.Add(new Point(sizx * 0.5 , -sizy * 0.5+cutradius));
            //mr.Add(new Point(sizx * 0.5 - cutradius * 0.5, -sizy * 0.5 +cutradius * 0.866));
            //mr.Add(new Point(sizx * 0.5 - cutradius * 0.866, -sizy * 0.5 + cutradius * 0.5));
            //mr.Add(new Point(sizx * 0.5-cutradius, -sizy * 0.5 ));
            ////one rounded corner bottom left
            //mr.Add(new Point(-sizx * 0.5 + cutradius, -sizy * 0.5));
            //mr.Add(new Point(-sizx * 0.5 + cutradius * 0.866, -sizy * 0.5 + cutradius * 0.5));
            //mr.Add(new Point(-sizx * 0.5+ cutradius * 0.5, -sizy * 0.5 + cutradius * 0.866));
            //mr.Add(new Point(-sizx * 0.5, -sizy * 0.5 + cutradius));
            ////one rounded corner top left
            //mr.Add(new Point(-sizx * 0.5, sizy * 0.5 - cutradius));
            //mr.Add(new Point(-sizx * 0.5 + cutradius * 0.5, sizy * 0.5 - cutradius * 0.866));
            //mr.Add(new Point(-sizx * 0.5 + cutradius * 0.866, sizy * 0.5 - cutradius * 0.5));
            //mr.Add(new Point(-sizx * 0.5 + cutradius, sizy * 0.5));

            //make a rounded corner then flip around
            double cp1x = sizx * 0.5 - cutradius;
            double cp1y = sizy * 0.5;

            double cp2x = sizx * 0.5 - cutradius + cutradius * 0.5; ;
            double cp2y = sizy * 0.5 - cutradius + cutradius * 0.866;

            double cp3x = sizx * 0.5 - cutradius + cutradius * 0.866; ;
            double cp3y = sizy * 0.5 - cutradius + cutradius * 0.5;

            double cp4x = sizx * 0.5;
            double cp4y = sizy * 0.5 - cutradius;

            mr.Add(new Point(cp1x, cp1y));
            mr.Add(new Point(cp2x, cp2y));
            mr.Add(new Point(cp3x, cp3y));
            mr.Add(new Point(cp4x, cp4y));

            mr.Add(new Point(cp4x, -cp4y));
            mr.Add(new Point(cp3x, -cp3y));
            mr.Add(new Point(cp2x, -cp2y));
            mr.Add(new Point(cp1x, -cp1y));

            mr.Add(new Point(-cp1x, -cp1y));
            mr.Add(new Point(-cp2x, -cp2y));
            mr.Add(new Point(-cp3x, -cp3y));
            mr.Add(new Point(-cp4x, -cp4y));

            mr.Add(new Point(-cp4x, cp4y));
            mr.Add(new Point(-cp3x, cp3y));
            mr.Add(new Point(-cp2x, cp2y));
            mr.Add(new Point(-cp1x, cp1y));
            return mr;

        }
        //makes a connection trimmed
        internal static List<Point3D> roundmyconn1(Point3D p1, Point3D p2, Point3D p3, double p)
        {
            //default percentage
            if (p > 1 || p <= 0) p = 0.1;
            List<Point3D> l = new List<Point3D>();
            //make mid
            Point3D mp1 = Point3D.Add(p1, Point3D.Subtract(p2, p1) * (1 - p));
            Point3D mp2 = Point3D.Add(p2, Point3D.Subtract(p3, p2) * p);
            Point3D mp = Point3D.Add(mp1, Point3D.Subtract(mp2, mp1));
            Point3D mmp = Point3D.Add(mp, Point3D.Subtract(p2, mp) * 0.5);
            l.Add(p1);
            l.Add(mp1);
            l.Add(mmp);
            l.Add(mp2);
            l.Add(p3);
            return l;
        }

        //makes a connection trimmed
        internal static List<Point3D> roundmyconn(Point3D p1, Point3D p2, Point3D p3)
        {

            List<Point3D> l = new List<Point3D>();
            //make mid

            Point3D mp1 = Point3D.Add(p1, Point3D.Subtract(p2, p1) * 0.5);
            Point3D mp2 = Point3D.Add(p3, Point3D.Subtract(p2, p3) * 0.5);
            Point3D mp11 = Point3D.Add(mp1, Point3D.Subtract(mp2, mp1) * 0.33);
            Point3D mp12 = Point3D.Add(mp1, Point3D.Subtract(mp2, mp1) * 0.63);
            l.Add(p1);
            l.Add(mp11);
            l.Add(mp12);
            l.Add(p3);

            return l;
        }

        //makes a simple vertical extrusion
        internal static void makeverticalextrusion(MeshBuilder mymb, IList<Point> crosssection, Point3D p1, Point3D p2)
        {
            List<Point3D> toppoints = new List<Point3D>();
            List<Point3D> botpoints = new List<Point3D>();
            //make each vertical quad
            for (int pindex = 0; pindex < crosssection.Count; pindex++)
            {
                if (pindex < crosssection.Count - 1)
                {
                    Point3D ip0 = crosssection[pindex].makePoint3D(p1);
                    botpoints.Add(ip0);
                    Point3D ip1 = crosssection[pindex + 1].makePoint3D(p1);
                    Point3D ip2 = crosssection[pindex + 1].makePoint3D(p2);

                    Point3D ip3 = crosssection[pindex].makePoint3D(p2);
                    toppoints.Add(ip3);
                    mymb.AddTriangle(ip2, ip1, ip0);
                    mymb.AddTriangle(ip2, ip0, ip3);
                }
                else
                {
                    Point3D ip0 = crosssection[pindex].makePoint3D(p1);
                    botpoints.Add(ip0);
                    Point3D ip1 = crosssection[0].makePoint3D(p1);
                    Point3D ip2 = crosssection[0].makePoint3D(p2);

                    Point3D ip3 = crosssection[pindex].makePoint3D(p2);
                    toppoints.Add(ip3);
                    mymb.AddTriangle(ip2, ip1, ip0);
                    mymb.AddTriangle(ip2, ip0, ip3);

                }

            }
            //bottom and top
            //toppoints.Add(crosssection[0].makePoint3D(p2));
            //botpoints.Add(crosssection[0].makePoint3D(p1));
            toppoints.Reverse();
            mymb.AddPolygon(toppoints);
            mymb.AddPolygon(botpoints);

        }
        //converts a 2d point into a 3d point
        internal static Point3D makePoint3D(this Point po, Point3D porigin)
        {
            return new Point3D(porigin.X + po.X, porigin.Y + po.Y, porigin.Z);
        }

        //flips a normal
        internal static Vector3D Flip(this Vector3D orvec)
        {
            Vector3D flippa = new Vector3D(orvec.X, orvec.Y, orvec.Z);
            flippa.Negate();
            return flippa;
        }


        //converts a value in node increments
        internal static double nodespaceconvert(this double orgspacing)
        {
            if (PUPPIGUISettings.nodeSpacing <= 0)
            {

                throw new Exception("Invalid node spacing constant");
            }
            //try to get rounded to nodeSpacing
            //   double xnodes = Math.Round(orgspacing * fastconstants.oneverspacing);
            //try smallest number
            double xnodes = Math.Floor(orgspacing * fastconstants.oneverspacing);
            return xnodes * PUPPIGUISettings.nodeSpacing;

        }
        //converts a value in cell center increments
        internal static double nodespacecenterconvert(this double orgspacing, double divsize)
        {
            if (PUPPIGUISettings.nodeSpacing <= 0 || divsize <= 0)
            {

                throw new Exception("Invalid node spacing constant");
            }
            double nodiv = 1.0 / divsize;
            //try to get rounded to nodeSpacing
            //double xnodes = Math.Truncate(orgspacing * nodiv);
            // //handle negative
            // if (orgspacing < 0 && orgspacing * nodiv != xnodes) xnodes -= 1;
            double xnodes = Math.Floor(orgspacing * nodiv);
            return xnodes * divsize + divsize * 0.5;

        }
        //simply swap two items in a list
        internal static void Swap<T>(this IList<T> list, int indexA, int indexB)
        {
            try
            {
                T tmp = list[indexA];
                list[indexA] = list[indexB];
                list[indexB] = tmp;
            }
            catch
            {

            }

        }
        //gets the nearest rectangle corner
        internal static Point3D nearestcorner(this Point3D myp, Rect3D box)
        {

            double xx = (Math.Abs(myp.X - box.Location.X) < Math.Abs(myp.X - (box.Location.X + box.SizeX))) ? box.Location.X : box.Location.X + box.SizeX;
            double yy = (Math.Abs(myp.Y - box.Location.Y) < Math.Abs(myp.Y - (box.Location.Y + box.SizeY))) ? box.Location.Y : box.Location.Y + box.SizeY;
            double zz = (Math.Abs(myp.Z - box.Location.Z) < Math.Abs(myp.Z - (box.Location.Z + box.SizeZ))) ? box.Location.Z : box.Location.Z + box.SizeZ;
            return new Point3D(xx, yy, zz);
        }

        //splits a rectangle
        internal static List<Rect3D> splitme(this Rect3D splittee, int xdivs, int ydivs)
        {

            List<Rect3D> rectlist = new List<Rect3D>();
            if (xdivs == 0 || ydivs == 0 || splittee.IsEmpty) return rectlist;
            double deltax = splittee.SizeX / xdivs;
            double deltay = splittee.SizeY / ydivs;
            for (int xc = 0; xc < xdivs; xc++)
            {
                for (int yc = 0; yc < ydivs; yc++)
                {
                    rectlist.Add(new Rect3D(splittee.Location.X + xc * deltax, splittee.Location.Y + yc * deltay, splittee.Location.Z, deltax, deltay, splittee.SizeZ));
                }
            }
            return rectlist;

        }


    }
    internal static class Visual2DExtensions
    {
        internal static System.Drawing.Bitmap makeBitmapFromArray(int[,] a)
        {

            int h = a.GetLength(0);
            int w = a.GetLength(1);
            System.Drawing.Bitmap bae = new System.Drawing.Bitmap(w, h);
            for (int x = 0; x < w; x++)
            {
                for (int y = 0; y < h; y++)
                {
                    byte c = Convert.ToByte(Math.Min(a[y, x] * 255 / PUPPIGUISettings.maxConnPerSpace, 255));
                    var cc = System.Drawing.Color.FromArgb(c, c, c);
                    bae.SetPixel(x, y, cc);
                }
            }
            double factor = 1.0 / Math.Min(1, Math.Sqrt(h * h + w * w) / 1000);
            return new System.Drawing.Bitmap(bae, new System.Drawing.Size(Convert.ToInt16(bae.Width * factor), Convert.ToInt16(bae.Height * factor)));
        }
        internal static void saveHconn(System.Drawing.Bitmap bae)
        {
            string fn = @"C:\scratch\hconn\" + DateTime.Now.ToString("yyyyMMddHHmmssfff") + ".bmp";
            bae.Save(fn);
        }
        internal static void saveVconn(System.Drawing.Bitmap bae)
        {
            string fn = @"C:\scratch\vconn\" + DateTime.Now.ToString("yyyyMMddHHmmssfff") + ".bmp";
            bae.Save(fn);
        }
        internal static void saveHmaze(System.Drawing.Bitmap bae)
        {
            string fn = @"C:\scratch\hmaze\" + DateTime.Now.ToString("yyyyMMddHHmmssfff") + ".bmp";
            bae.Save(fn);
        }
        internal static void saveVmaze(System.Drawing.Bitmap bae)
        {
            string fn = @"C:\scratch\vmaze\" + DateTime.Now.ToString("yyyyMMddHHmmssfff") + ".bmp";
            bae.Save(fn);
        }
    }
    public class PUPPICustomRenderer
    {
        /// <summary>
        /// If true, when rendering, normals are recalculated. Might be slower;
        /// </summary>
        public bool recalcNormsOnRender = false;

        public enum PUPPIimageDirection { positiveXDirection, negativeXDirection, positiveYDirection, negativeYDirection };
        public enum PUPPIimageOrientation { horizontal, vertical };
        private static readonly PropertyInfo Visual3DModelPropertyInfo = typeof(Visual3D).GetProperty("Visual3DModel", BindingFlags.Instance | BindingFlags.NonPublic);


        /// <summary>
        /// Structure holding information on filled triangles in 2D mode. Stored in rectangles2D list.Can be created and edited with functions available in the PUPPICustomRenderer class.
        /// </summary>
        public struct CustomTriangle2D
        {
            public Point p1 { get; internal set; }
            public Point p2 { get; internal set; }
            public Point p3 { get; internal set; }
            public Color myTriangleColor { get; internal set; }
            public int layer { get; internal set; }
        }

        /// <summary>
        /// Structure holding information on filled triangles in 3D mode. Stored in rectangles3D list.Can be created and edited with functions available in the PUPPICustomRenderer class.
        /// </summary>
        public struct CustomTriangle3D
        {
            public Point3D p1 { get; internal set; }
            public Point3D p2 { get; internal set; }
            public Point3D p3 { get; internal set; }
            public Color myTriangleColor { get; internal set; }

        }



        /// <summary>
        /// Structure holding information about Custom Captions in 3D mode. Stored in captions3D list.Can be created and edited with functions available in the PUPPICustomRenderer class.
        /// </summary>
        public struct CustomCaption3D
        {
            public string myCaptionText { get; internal set; }
            public Point3D myCaptionPosition { get; internal set; }
            public double myCaptionTextHeight { get; internal set; }
            public PUPPIimageDirection myCaptionDir { get; internal set; }
            public PUPPIimageOrientation myCaptionOrient { get; internal set; }
            public Color myCaptionColor { get; internal set; }
        }
        /// <summary>
        /// Structure holding information about Custom Captions in 2D mode. Stored in captions3D list.Can be created and edited with functions available in the PUPPICustomRenderer class.
        /// </summary>
        public struct CustomCaption2D
        {
            public string myCaptionText { get; internal set; }
            public Point myCaptionPosition { get; internal set; }
            public double myCaptionTextHeight { get; internal set; }
            public PUPPIimageDirection myCaptionDir { get; internal set; }
            public Color myCaptionColor { get; internal set; }
            public int layer { get; internal set; }
        }

        /// <summary>
        /// Structure holding information about Custom Images in 3D mode. Stored in Images3D list.Can be created and edited with functions available in the PUPPICustomRenderer class.
        /// </summary>
        public struct CustomImage3D
        {
            public string myImageFilePath { get; internal set; }
            public Point3D myImagePosition { get; internal set; }
            public double myImageHeight { get; internal set; }
            public double myImageWidth { get; internal set; }
            public PUPPIimageDirection myImageDirection { get; internal set; }
            public PUPPIimageOrientation myImageOrient { get; internal set; }
        }
        /// <summary>
        /// Structure holding information about Custom Images in 2D mode. Stored in Images3D list.Can be created and edited with functions available in the PUPPICustomRenderer class.
        /// </summary>
        public struct CustomImage2D
        {
            public string myImageFilePath { get; internal set; }
            public Point myImagePosition { get; internal set; }
            public double myImageHeight { get; internal set; }
            public double myImageWidth { get; internal set; }
            public PUPPIimageDirection myImageDirection { get; internal set; }
            public int layer { get; internal set; }
        }

        /// <summary>
        /// Structure holding information about Custom Box Shapes in 3D mode. Stored in boxes3D list.Can be created and edited with functions available in the PUPPICustomRenderer class.
        /// </summary>
        public struct CustomBox3D
        {
            public Point3D myBoxStartPosition { get; internal set; }
            public Vector3D myBoxDiagonal { get; internal set; }
            public Color myBoxColor { get; internal set; }
        }

        /// <summary>
        /// Structure holding information about Custom Rounded Box Shapes in 3D mode. Stored in roundedboxes3D list.Can be created and edited with functions available in the PUPPICustomRenderer class.
        /// </summary>
        public struct CustomRoundedBox3D
        {
            public Point3D myBoxStartPosition { get; internal set; }
            public Vector3D myBoxDiagonal { get; internal set; }
            public Color myBoxColor { get; internal set; }
            public double myBoxCornerRadius
            { get; internal set; }
        }


        /// <summary>
        /// Structure holding information about Wireframe Custom Box Shapes in 3D mode. Stored in wireBoxes3D list.Can be created and edited with functions available in the PUPPICustomRenderer class.
        /// </summary>
        public struct WireCustomBox3D
        {
            public Point3D myBoxStartPosition { get; internal set; }
            public Vector3D myBoxDiagonal { get; internal set; }
            public Color myBoxColor { get; internal set; }
        }

        /// <summary>
        /// Structure holding information about rectangular borders in 2D mode. Stored in borders2D list.Can be created and edited with functions available in the PUPPICustomRenderer class.
        /// </summary>
        public struct CustomBorder2D
        {
            public Point myBorderStartPosition { get; internal set; }
            public Vector myBorderDiagonal { get; internal set; }
            public Color myBorderColor { get; internal set; }
            public int layer { get; internal set; }
        }


        /// <summary>
        /// Structure holding information about Custom Rectangle Shapes in 2D mode. Stored in rectangles2D list.Can be created and edited with functions available in the PUPPICustomRenderer class.
        /// </summary>
        public struct CustomRectangle2D
        {
            public Point myRectStartPosition { get; internal set; }
            public Vector myRectDiagonal { get; internal set; }
            public Color myRectColor { get; internal set; }
            public int layer { get; internal set; }
        }

        /// <summary>
        /// Structure holding information about Custom Rounded Rectangle Shapes in 2D mode. Stored in roundedrectangles2D list.Can be created and edited with functions available in the PUPPICustomRenderer class.
        /// </summary>
        public struct CustomRoundedRectangle2D
        {
            public Point myRectStartPosition { get; internal set; }
            public Vector myRectDiagonal { get; internal set; }
            public Color myRectColor { get; internal set; }
            public double myCornerRadius { get; internal set; }
            public int layer { get; internal set; }
        }


        /// <summary>
        /// Structure holding information about Custom Sphere Shapes in 3D mode. Stored in spheres3D list.Can be created and edited with functions available in the PUPPICustomRenderer class.
        /// </summary>
        public struct CustomSphere3D
        {
            public Point3D mySphereCenter { get; internal set; }
            public double mySphereRadius { get; internal set; }
            public Color mySphereColor { get; internal set; }
        }
        /// <summary>
        /// Structure holding information about Custom Circle Shapes in 2D mode. Stored in circles2D list.Can be created and edited with functions available in the PUPPICustomRenderer class.
        /// </summary>
        public struct CustomCircle2D
        {
            public Point myCircleCenter { get; internal set; }
            public double myCircleRadius { get; internal set; }
            public Color myCircleColor { get; internal set; }
            public int layer { get; internal set; }
        }
        /// <summary>
        /// Structure holding information about Custom Pipes in 3D mode. Stored in pipes3D list.Can be created and edited with functions available in the PUPPICustomRenderer class.
        /// </summary>
        public struct CustomPipe3D
        {
            public Point3D myPipeStartPoint { get; internal set; }
            public Point3D myPipeEndPoint { get; internal set; }
            public double myPipeDiameter { get; internal set; }
            public Color myPipeColor { get; internal set; }

        }

        /// <summary>
        /// If this is set to false, the developer should add a text object in the custom renderer to caption the node.
        /// </summary>
        public bool useDefaultCaption = true;
        //store the model for 3d rendering
        internal ModelVisual3D model3D;
        internal ModelVisual3D model2D;
        internal bool use3D = false;
        internal bool use2D = false;
        //after things are changed the model needs to be recreated
        internal bool needsRender = true;
        /// <summary>
        /// get 3D mode captions.
        /// </summary>
        public List<CustomCaption3D> captions3D { get; internal set; }
        /// <summary>
        /// get 2D mode captions.
        /// </summary>
        public List<CustomCaption2D> captions2D { get; internal set; }

        /// <summary>
        /// returns the ModelVisual3D object after rendering, for 2d or 3d mode
        /// </summary>
        /// <param name="for2D"></param>
        /// <returns>ModelVisual3D</returns>
        public ModelVisual3D getModel(bool for2D)
        {
            if (for2D) return model2D.cloneVisualAndChildren();
            else return model3D.cloneVisualAndChildren();
        }

        /// <summary>
        /// get 3D mode images.
        /// </summary>
        public List<CustomImage3D> images3D { get; internal set; }
        /// <summary>
        /// get 2D mode images.
        /// </summary>
        public List<CustomImage2D> images2D { get; internal set; }


        /// <summary>
        /// get 3D mode boxes.
        /// </summary>
        public List<CustomBox3D> boxes3D { get; internal set; }

        /// <summary>
        /// get 3D moderounded  boxes.
        /// </summary>
        public List<CustomRoundedBox3D> roundedboxes3D { get; internal set; }

        /// <summary>
        /// get 3D mode wireframe boxes.
        /// </summary>
        public List<WireCustomBox3D> wireBoxes3D { get; internal set; }

        /// <summary>
        /// get 2D mode wireframe borders.
        /// </summary>
        public List<CustomBorder2D> borders2D { get; internal set; }


        /// <summary>
        /// get 2D mode rectangles.
        /// </summary>
        public List<CustomRectangle2D> rectangles2D { get; internal set; }


        /// <summary>
        /// get 2D mode triangles.
        /// </summary>
        public List<CustomTriangle2D> triangles2D { get; internal set; }

        /// <summary>
        /// get 3D mode triangles.
        /// </summary>
        public List<CustomTriangle3D> triangles3D { get; internal set; }


        /// <summary>
        /// get 2D mode rounded rectangles.
        /// </summary>
        public List<CustomRoundedRectangle2D> roundedrectangles2D { get; internal set; }


        /// <summary>
        /// get 3D mode spheres
        /// </summary>
        public List<CustomSphere3D> spheres3D { get; internal set; }
        /// <summary>
        /// get 2D mode circles
        /// </summary>
        public List<CustomCircle2D> circles2D { get; internal set; }
        /// <summary>
        /// get 3D mode model visuals
        /// </summary>
        public List<ModelVisual3D> modelVisuals3D { get; internal set; }
        /// <summary>
        /// get 2D mode model visuals
        /// </summary>
        public List<ModelVisual3D> modelVisuals2D { get; internal set; }
        /// <summary>
        /// get the CAD model visuals
        /// </summary>
        public List<FileModelVisual3D> fileVisuals3D { get; internal set; }
        /// <summary>
        /// Get the 3D pipes
        /// </summary>
        public List<CustomPipe3D> pipes3D { get; internal set; }
        internal Rect3D bbox;
        //for manipulator
        internal Rect3D displacedBbox;
        /// <summary>
        /// Shows the bounding box as lines.
        /// </summary>
        internal bool renderWireframeBoundingBox;

        /// <summary>
        /// Constructor, please feed an unique identifier to retriev it. This will be specified in the Renderer Dictionary and your PUPPI Module.
        /// </summary>
        /// <param name="uniqueName"></param>
        public PUPPICustomRenderer()
        {

            model3D = new ModelVisual3D();
            model2D = new ModelVisual3D();
            use3D = false;
            use2D = false;
            renderWireframeBoundingBox = false;
            bbox = new Rect3D();
            displacedBbox = new Rect3D();
            captions3D = new List<CustomCaption3D>();
            captions2D = new List<CustomCaption2D>();
            wireBoxes3D = new List<WireCustomBox3D>();
            borders2D = new List<CustomBorder2D>();
            boxes3D = new List<CustomBox3D>();
            roundedboxes3D = new List<CustomRoundedBox3D>();
            roundedrectangles2D = new List<CustomRoundedRectangle2D>();
            rectangles2D = new List<CustomRectangle2D>();
            triangles2D = new List<CustomTriangle2D>();
            triangles3D = new List<CustomTriangle3D>();
            spheres3D = new List<CustomSphere3D>();
            circles2D = new List<CustomCircle2D>();
            modelVisuals2D = new List<ModelVisual3D>();
            modelVisuals3D = new List<ModelVisual3D>();
            fileVisuals3D = new List<FileModelVisual3D>();
            images2D = new List<CustomImage2D>();
            images3D = new List<CustomImage3D>();
            pipes3D = new List<CustomPipe3D>();
            needsRender = true;

        }

        internal void cloneMyPUPPICustomRenderer(ref PUPPICustomRenderer p)
        {
            //PUPPICustomRenderer p = new PUPPICustomRenderer();
            foreach (CustomBox3D cb3 in boxes3D)
            {
                CustomBox3D c = cb3;
                p.boxes3D.Add(c);
                p.use3D = true;
                p.needsRender = true;
            }

            foreach (CustomRoundedBox3D cb3 in roundedboxes3D)
            {
                CustomRoundedBox3D c = cb3;
                p.roundedboxes3D.Add(c);
                p.use3D = true;
                p.needsRender = true;
            }

            foreach (WireCustomBox3D cb3 in wireBoxes3D)
            {
                WireCustomBox3D c = cb3;
                p.wireBoxes3D.Add(c);
                p.use3D = true;
                p.needsRender = true;
            }
            foreach (CustomRectangle2D cb3 in rectangles2D)
            {
                CustomRectangle2D c = cb3;
                p.rectangles2D.Add(c);
                p.use2D = true;
                p.needsRender = true;
            }

            foreach (CustomTriangle2D cb3 in triangles2D)
            {
                CustomTriangle2D c = cb3;
                p.triangles2D.Add(c);
                p.use2D = true;
                p.needsRender = true;
            }
            foreach (CustomTriangle3D cb3 in triangles3D)
            {
                CustomTriangle3D c = cb3;
                p.triangles3D.Add(c);
                p.use3D = true;
                p.needsRender = true;
            }

            foreach (CustomRoundedRectangle2D cb3 in roundedrectangles2D)
            {
                CustomRoundedRectangle2D c = cb3;
                p.roundedrectangles2D.Add(c);
                p.use2D = true;
                p.needsRender = true;
            }
            foreach (CustomBorder2D cb2 in borders2D)
            {
                CustomBorder2D c = cb2;
                p.borders2D.Add(c);
                p.use2D = true;
                p.needsRender = true;
            }
            foreach (CustomCaption3D cb3 in captions3D)
            {
                CustomCaption3D c = cb3;
                p.captions3D.Add(c);
                p.use3D = true;
                p.needsRender = true;
            }
            foreach (CustomCaption2D cb3 in captions2D)
            {
                CustomCaption2D c = cb3;
                p.captions2D.Add(c);
                p.use2D = true;
                p.needsRender = true;
            }
            foreach (CustomSphere3D cb3 in spheres3D)
            {
                CustomSphere3D c = cb3;
                p.spheres3D.Add(c);
                p.use3D = true;
                p.needsRender = true;
            }
            foreach (CustomCircle2D cb3 in circles2D)
            {
                CustomCircle2D c = cb3;
                p.circles2D.Add(c);
                p.use2D = true;
                p.needsRender = true;
            }
            foreach (CustomPipe3D cb3 in pipes3D)
            {
                CustomPipe3D c = cb3;
                p.pipes3D.Add(c);
                p.use3D = true;
                p.needsRender = true;
            }
            foreach (FileModelVisual3D cb3 in fileVisuals3D)
            {
                FileModelVisual3D c = new FileModelVisual3D();
                c.Source = cb3.Source;
                p.fileVisuals3D.Add(c);
                p.use3D = true;
                p.needsRender = true;
            }
            foreach (CustomImage3D cb3 in images3D)
            {
                CustomImage3D c = cb3;
                p.images3D.Add(c);
                p.use3D = true;
                p.needsRender = true;
            }
            foreach (CustomImage2D cb2 in images2D)
            {
                CustomImage2D c = cb2;
                p.images2D.Add(c);
                p.use2D = true;
                p.needsRender = true;
            }
            p.useDefaultCaption = useDefaultCaption;
            // return p;


        }




        /// <summary>
        /// Adds a pipe object to the Custom Renderer 3Dmodel. 0,0,0 is considered the center of the 3D Model
        /// </summary>
        /// <param name="xStart">X of start point</param>
        /// <param name="yStart">Y of start point</param>
        /// <param name="zStart">Z of start point</param>
        /// <param name="xEnd">X of end point</param>
        /// <param name="yEnd">Y of end point</param>
        /// <param name="zEnd">Z of end point</param>
        /// <param name="diameter">pipe diameter </param>
        /// <param name="red">red color (0-255)</param>
        /// <param name="green">green color (0-255)</param>
        /// <param name="blue">blue color (0-255)</param>
        public void addPipe3D(double xStart, double yStart, double zStart, double xEnd, double yEnd, double zEnd, double diameter, byte red, byte green, byte blue)
        {
            CustomPipe3D cp = new CustomPipe3D();
            cp.myPipeColor = Color.FromRgb(red, green, blue);
            cp.myPipeStartPoint = new Point3D(xStart, yStart, zStart);
            cp.myPipeEndPoint = new Point3D(xEnd, yEnd, zEnd);
            cp.myPipeDiameter = Math.Max(Math.Abs(diameter), PUPPIGUISettings.collinearToler);
            pipes3D.Add(cp);
            needsRender = true;
            use3D = true;

        }
        /// <summary>
        /// Updates a pipe object from the Custom Renderer 3Dmodel. 0,0,0 is considered the center of the 3D Model
        /// </summary>
        /// <param name="myIndex">Valid 0-based index from the pipes3D list</param>
        /// <param name="xStart">X of start point</param>
        /// <param name="yStart">Y of start point</param>
        /// <param name="zStart">Z of start point</param>
        /// <param name="xEnd">X of end point</param>
        /// <param name="yEnd">Y of end point</param>
        /// <param name="zEnd">Z of end point</param>
        /// <param name="diameter">pipe diameter </param>
        /// <param name="red">red color (0-255)</param>
        /// <param name="green">green color (0-255)</param>
        /// <param name="blue">blue color (0-255)</param>
        /// <returns>if update successful</returns>
        public bool updatePipe3D(int myIndex, double xStart, double yStart, double zStart, double xEnd, double yEnd, double zEnd, double diameter, byte red, byte green, byte blue)
        {
            if (myIndex < 0 || myIndex >= pipes3D.Count)
            {
                return false;
            }
            CustomPipe3D cp = new CustomPipe3D();
            cp.myPipeColor = Color.FromRgb(red, green, blue);
            cp.myPipeStartPoint = new Point3D(xStart, yStart, zStart);
            cp.myPipeEndPoint = new Point3D(xEnd, yEnd, zEnd);
            cp.myPipeDiameter = Math.Max(Math.Abs(diameter), PUPPIGUISettings.collinearToler);
            pipes3D[myIndex] = cp;
            needsRender = true;
            return true;
        }
        /// <summary>
        /// Removes a pipe object from the Custom Renderer 3Dmodel.
        /// </summary>
        /// <param name="myIndex">Valid 0-based index from the pipes3D list</param>
        public void removePipe3D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= pipes3D.Count)
            {
                return;
            }
            pipes3D.RemoveAt(myIndex);
            needsRender = true;
        }

        /// <summary>
        /// Adds a box to the Custom Renderer 3Dmodel. 0,0,0 is considered the center of the 3D Model
        /// </summary>
        /// <param name="xStart">lower left corner X</param>
        /// <param name="yStart">lower left corner Y</param>
        /// <param name="zStart">lower left corner Z</param>
        /// <param name="xEnd">upper right corner X</param>
        /// <param name="yEnd">upper right corner Y</param>
        /// <param name="zEnd">upper right corner Z</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        public void addBox3D(double xStart, double yStart, double zStart, double xEnd, double yEnd, double zEnd, byte red, byte green, byte blue)
        {


            CustomBox3D cb = new CustomBox3D();
            cb.myBoxColor = Color.FromRgb(red, green, blue);
            cb.myBoxStartPosition = new Point3D(xStart, yStart, zStart);
            cb.myBoxDiagonal = new Vector3D(xEnd - xStart, yEnd - yStart, zEnd - zStart);
            boxes3D.Add(cb);
            //var meshBuilder = new MeshBuilder(false, false);
            //Color colo =  Color.FromRgb(red,green,blue); 
            //Point3D center=new Point3D((xStart+xEnd)/2,(yStart+yEnd)/2,(zStart+zEnd)/2) ;
            //meshBuilder.AddBox(center, Math.Abs(xEnd - xStart), Math.Abs(yEnd - yStart), Math.Abs(zEnd - zStart));

            //var mesh = meshBuilder.ToMesh(true);
            //GeometryModel3D newModel = new GeometryModel3D();
            //newModel.Geometry = mesh;

            //newModel.Material = new DiffuseMaterial(new SolidColorBrush(colo));

            ////bbox//.Union(newModel.Bounds);
            //ModelVisual3D bv=new ModelVisual3D();
            //bv.Content = newModel;
            //bbox.Union(newModel.Bounds);
            //model3D.Children.Add(bv);  

            ////if (model3D.Content.Bounds.SizeZ > PUPPIGUISettings.nodeHeight) PUPPIGUISettings.nodeHeight = model3D.Content.Bounds.SizeZ;      
            use3D = true;
            needsRender = true;
        }


        /// <summary>
        /// Adds a box to the Custom Renderer 3Dmodel. 0,0,0 is considered the center of the 3D Model
        /// </summary>
        /// <param name="xStart">lower left corner X</param>
        /// <param name="yStart">lower left corner Y</param>
        /// <param name="zStart">lower left corner Z</param>
        /// <param name="xEnd">upper right corner X</param>
        /// <param name="yEnd">upper right corner Y</param>
        /// <param name="zEnd">upper right corner Z</param>
        /// <param name="cornerRadius">corner radius, less than 1/3 of minimum side length</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        public void addRoundedBox3D(double xStart, double yStart, double zStart, double xEnd, double yEnd, double zEnd, double cornerRadius, byte red, byte green, byte blue)
        {


            CustomRoundedBox3D cb = new CustomRoundedBox3D();
            cb.myBoxColor = Color.FromRgb(red, green, blue);
            cb.myBoxStartPosition = new Point3D(xStart, yStart, zStart);
            cb.myBoxDiagonal = new Vector3D(xEnd - xStart, yEnd - yStart, zEnd - zStart);
            double ms = Math.Min(Math.Min(xEnd - xStart, yEnd - yStart), zEnd - zStart);
            if (cornerRadius > 0.33 * ms || cornerRadius < 0) cb.myBoxCornerRadius = 0.33 * ms; else cb.myBoxCornerRadius = cornerRadius;


            roundedboxes3D.Add(cb);

            use3D = true;
            needsRender = true;
        }


        /// <summary>
        /// Updates a box of the Custom Renderer 3Dmodel from the boxes3D list. 0,0,0 is considered the center of the 3D Model
        /// </summary>
        /// <param name="myIndex">boxes3D List Index (0 based)</param>
        /// <param name="xStart">lower left corner X</param>
        /// <param name="yStart">lower left corner Y</param>
        /// <param name="zStart">lower left corner Z</param>
        /// <param name="xEnd">upper right corner X</param>
        /// <param name="yEnd">upper right corner Y</param>
        /// <param name="zEnd">upper right corner Z</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        /// <returns>If the update was successful</returns>
        public bool updateBox3D(int myIndex, double xStart, double yStart, double zStart, double xEnd, double yEnd, double zEnd, byte red, byte green, byte blue)
        {
            if (myIndex < 0 || myIndex >= boxes3D.Count)
            {
                return false;
            }
            CustomBox3D cb = new CustomBox3D();
            cb.myBoxColor = Color.FromRgb(red, green, blue);
            cb.myBoxStartPosition = new Point3D(xStart, yStart, zStart);
            cb.myBoxDiagonal = new Vector3D(xEnd - xStart, yEnd - yStart, zEnd - zStart);
            boxes3D[myIndex] = cb;
            needsRender = true;
            return true;
        }


        /// <summary>
        /// Updates a rounded box of the Custom Renderer 3Dmodel from the roundedboxes3D list. 0,0,0 is considered the center of the 3D Model
        /// </summary>
        /// <param name="myIndex">boxes3D List Index (0 based)</param>
        /// <param name="xStart">lower left corner X</param>
        /// <param name="yStart">lower left corner Y</param>
        /// <param name="zStart">lower left corner Z</param>
        /// <param name="xEnd">upper right corner X</param>
        /// <param name="yEnd">upper right corner Y</param>
        /// <param name="zEnd">upper right corner Z</param>
        /// <param name="cornerRadius">corner radius, less than 1/3 of minimum side length</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        /// <returns>If the update was successful</returns>
        public bool updateRoundedBox3D(int myIndex, double xStart, double yStart, double zStart, double xEnd, double yEnd, double zEnd, double cornerRadius, byte red, byte green, byte blue)
        {
            if (myIndex < 0 || myIndex >= boxes3D.Count)
            {
                return false;
            }
            CustomRoundedBox3D cb = new CustomRoundedBox3D();
            cb.myBoxColor = Color.FromRgb(red, green, blue);
            cb.myBoxStartPosition = new Point3D(xStart, yStart, zStart);
            cb.myBoxDiagonal = new Vector3D(xEnd - xStart, yEnd - yStart, zEnd - zStart);
            double ms = Math.Min(Math.Min(xEnd - xStart, yEnd - yStart), zEnd - zStart);
            if (cornerRadius > 0.33 * ms || cornerRadius < 0) cb.myBoxCornerRadius = 0.33 * ms; else cb.myBoxCornerRadius = cornerRadius;

            roundedboxes3D[myIndex] = cb;
            needsRender = true;
            return true;
        }

        /// <summary>
        /// Removes a Custom Box from the boxes3D list
        /// </summary>
        /// <param name="myIndex">boxes3D List Index (0 based)</param>
        public void removeBox3D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= boxes3D.Count)
            {
                return;
            }
            boxes3D.RemoveAt(myIndex);
            needsRender = true;
        }


        /// <summary>
        /// Removes a Custom Rounded Box from the roundedboxes3D list
        /// </summary>
        /// <param name="myIndex">roundedboxes3D List Index (0 based)</param>
        public void removeRoundedBox3D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= roundedboxes3D.Count)
            {
                return;
            }
            roundedboxes3D.RemoveAt(myIndex);
            needsRender = true;
        }




        /// <summary>
        /// Adds a wireframe box to the Custom Renderer 3Dmodel. 0,0,0 is considered the center of the 3D Model
        /// </summary>
        /// <param name="xStart">lower left corner X</param>
        /// <param name="yStart">lower left corner Y</param>
        /// <param name="zStart">lower left corner Z</param>
        /// <param name="xEnd">upper right corner X</param>
        /// <param name="yEnd">upper right corner Y</param>
        /// <param name="zEnd">upper right corner Z</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        public void addWireBox3D(double xStart, double yStart, double zStart, double xEnd, double yEnd, double zEnd, byte red, byte green, byte blue)
        {


            WireCustomBox3D cb = new WireCustomBox3D();
            cb.myBoxColor = Color.FromRgb(red, green, blue);
            cb.myBoxStartPosition = new Point3D(xStart, yStart, zStart);
            cb.myBoxDiagonal = new Vector3D(xEnd - xStart, yEnd - yStart, zEnd - zStart);
            wireBoxes3D.Add(cb);
            use3D = true;
            needsRender = true;
        }
        /// <summary>
        /// Updates a wireframe box of the Custom Renderer 3Dmodel from the wireBoxes3D list. 0,0,0 is considered the center of the 3D Model
        /// </summary>
        /// <param name="myIndex">wireBoxes3D List Index (0 based)</param>
        /// <param name="xStart">lower left corner X</param>
        /// <param name="yStart">lower left corner Y</param>
        /// <param name="zStart">lower left corner Z</param>
        /// <param name="xEnd">upper right corner X</param>
        /// <param name="yEnd">upper right corner Y</param>
        /// <param name="zEnd">upper right corner Z</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        /// <returns>If the update was successful</returns>
        public bool updateWireBox3D(int myIndex, double xStart, double yStart, double zStart, double xEnd, double yEnd, double zEnd, byte red, byte green, byte blue)
        {
            if (myIndex < 0 || myIndex >= wireBoxes3D.Count)
            {
                return false;
            }
            WireCustomBox3D cb = new WireCustomBox3D();
            cb.myBoxColor = Color.FromRgb(red, green, blue);
            cb.myBoxStartPosition = new Point3D(xStart, yStart, zStart);
            cb.myBoxDiagonal = new Vector3D(xEnd - xStart, yEnd - yStart, zEnd - zStart);
            wireBoxes3D[myIndex] = cb;
            needsRender = true;
            return true;
        }
        /// <summary>
        /// Removes a Custom Box from the wireBoxes3D list
        /// </summary>
        /// <param name="myIndex">boxes3D List Index (0 based)</param>
        public void removeWireBox3D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= wireBoxes3D.Count)
            {
                return;
            }
            wireBoxes3D.RemoveAt(myIndex);
            needsRender = true;
        }




        /// <summary>
        /// Adds a border to the Custom Renderer 2D model. 0,0 is considered the center of the 2D Model
        /// </summary>
        /// <param name="xStart">lower left corner X</param>
        /// <param name="yStart">lower left corner Y</param>
        /// <param name="xEnd">upper right corner X</param>
        /// <param name="yEnd">upper right corner Y</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        /// <param name="layer">layer number. positive. lowest layers at the bottom</param>
        public void addBorder2D(double xStart, double yStart, double xEnd, double yEnd, byte red, byte green, byte blue, int layer)
        {

            CustomBorder2D cb = new CustomBorder2D();
            cb.myBorderColor = Color.FromRgb(red, green, blue);
            cb.myBorderStartPosition = new Point(xStart, yStart);
            cb.myBorderDiagonal = new Vector(xEnd - xStart, yEnd - yStart);
            cb.layer = layer;
            borders2D.Add(cb);
            use2D = true;
            needsRender = true;
        }
        /// <summary>
        /// Updates a wireframe box of the Custom Renderer 2Dmodel from the borders2D list. 0,0 is considered the center of the 2D Model
        /// </summary>
        /// <param name="myIndex">borders2D List Index (0 based)</param>
        /// <param name="xStart">lower left corner X</param>
        /// <param name="yStart">lower left corner Y</param>
        /// <param name="xEnd">upper right corner X</param>
        /// <param name="yEnd">upper right corner Y</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        /// <param name="layer">layer number. positive. lowest layers at the bottom</param>
        /// <returns>If the update was successful</returns>
        public bool updateBorder2D(int myIndex, double xStart, double yStart, double xEnd, double yEnd, byte red, byte green, byte blue, int layer)
        {
            if (myIndex < 0 || myIndex >= borders2D.Count)
            {
                return false;
            }
            CustomBorder2D cb = new CustomBorder2D();
            cb.myBorderColor = Color.FromRgb(red, green, blue);
            cb.myBorderStartPosition = new Point(xStart, yStart);
            cb.myBorderDiagonal = new Vector(xEnd - xStart, yEnd - yStart);
            borders2D[myIndex] = cb;
            needsRender = true;
            return true;
        }
        /// <summary>
        /// Removes a Custom Box from the borders2D list
        /// </summary>
        /// <param name="myIndex">boxes2D List Index (0 based)</param>
        public void removeBorder2D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= borders2D.Count)
            {
                return;
            }
            borders2D.RemoveAt(myIndex);
            needsRender = true;
        }






        /// <summary>
        /// Adds a sphere to the Custom Renderer 3Dmodel. 0,0,0 is considered the center of the 3D Model
        /// </summary>
        /// <param name="xCenter">x Center of sphere</param>
        /// <param name="yCenter">y Center of sphere</param>
        /// <param name="zCenter">z Center of sphere</param>
        /// <param name="radius">radius of th sphere</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        public void addSphere3D(double xCenter, double yCenter, double zCenter, double radius, byte red, byte green, byte blue)
        {
            CustomSphere3D cs = new CustomSphere3D();
            cs.mySphereCenter = new Point3D(xCenter, yCenter, zCenter);
            cs.mySphereRadius = radius;
            cs.mySphereColor = Color.FromRgb(red, green, blue);
            spheres3D.Add(cs);
            needsRender = true;
            //var meshBuilder = new MeshBuilder(false, false);
            //Color colo = Color.FromRgb(red, green, blue);
            //Point3D center = new Point3D(xCenter,yCenter,zCenter);
            //meshBuilder.AddSphere(center, radius);

            //var mesh = meshBuilder.ToMesh(true);
            //GeometryModel3D newModel = new GeometryModel3D();
            //newModel.Geometry = mesh;

            //newModel.Material = new DiffuseMaterial(new SolidColorBrush(colo));

            ////bbox//.Union(newModel.Bounds);
            //ModelVisual3D bv = new ModelVisual3D();
            //bv.Content = newModel;
            //bbox.Union(new Rect3D( );
            //model3D.Children.Add(bv);

            //if (model3D.Content.Bounds.SizeZ > PUPPIGUISettings.nodeHeight) PUPPIGUISettings.nodeHeight = model3D.Content.Bounds.SizeZ;      
            use3D = true;
        }
        /// <summary>
        /// Updates a sphere from the Custom Renderer 3Dmodel spheres3D list. 0,0,0 is considered the center of the 3D Model
        /// </summary>
        /// <param name="myIndex">spheres3D List Index (0 based)</param>
        /// <param name="xCenter">x Center of sphere</param>
        /// <param name="yCenter">y Center of sphere</param>
        /// <param name="zCenter">z Center of sphere</param>
        /// <param name="radius">radius of th sphere</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        /// <returns>If the update was successful</returns>
        public bool updateSphere3D(int myIndex, double xCenter, double yCenter, double zCenter, double radius, byte red, byte green, byte blue)
        {
            if (myIndex < 0 || myIndex >= spheres3D.Count)
            {
                return false;
            }
            CustomSphere3D cs = new CustomSphere3D();
            cs.mySphereCenter = new Point3D(xCenter, yCenter, zCenter);
            cs.mySphereRadius = radius;
            cs.mySphereColor = Color.FromRgb(red, green, blue);
            spheres3D[myIndex] = cs;
            needsRender = true;
            return true;
        }
        /// <summary>
        /// removes a sphere from the Custom Renderer 3Dmodel spheres3D list
        /// </summary>
        /// <param name="myIndex">spheres3D List Index (0 based)</param>
        public void removeSphere3D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= spheres3D.Count)
            {
                return;
            }
            spheres3D.RemoveAt(myIndex);
            needsRender = true;
        }

        /// <summary>
        /// Adds a filled circle to the 2D Renderer objects. 0,0 is considered the center of the 2D Model
        /// </summary>
        /// <param name="xCenter">x Center of circle</param>
        /// <param name="yCenter">y Center of circle</param>
        /// <param name="radius">radius of circle</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        /// <param name="layer">layer number.positive. lowest layers at the bottom</param>
        public void addCircle2D(double xCenter, double yCenter, double radius, byte red, byte green, byte blue, int layer)
        {
            CustomCircle2D cd = new CustomCircle2D();
            cd.myCircleCenter = new Point(xCenter, yCenter);
            cd.myCircleRadius = radius;
            cd.myCircleColor = Color.FromRgb(red, green, blue);
            cd.layer = Math.Abs(layer);
            circles2D.Add(cd);
            needsRender = true;
            use2D = true;
        }
        /// <summary>
        /// Updates a filled circle in the 2D Renderer circles2D list. 0,0 is considered the center of the 2D Model
        /// </summary>
        /// <param name="myIndex">circles2D List Index (0 based)</param>
        /// <param name="xCenter">x Center of circle</param>
        /// <param name="yCenter">y Center of circle</param>
        /// <param name="radius">radius of circle</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        /// <param name="layer">layer number. positive. lowest layers at the bottom</param>
        /// <returns>If the update was successful</returns>
        public bool updateCircle2D(int myIndex, double xCenter, double yCenter, double radius, byte red, byte green, byte blue, int layer)
        {
            if (myIndex < 0 || myIndex >= circles2D.Count)
            {
                return false;
            }
            CustomCircle2D cd = new CustomCircle2D();
            cd.myCircleCenter = new Point(xCenter, yCenter);
            cd.myCircleRadius = radius;
            cd.myCircleColor = Color.FromRgb(red, green, blue);
            cd.layer = Math.Abs(layer);
            circles2D[myIndex] = cd;
            needsRender = true;
            return true;

        }
        /// <summary>
        /// Removes a filled circle in the 2D Renderer circles2D list
        /// </summary>
        /// <param name="myIndex">circles2D List Index (0 based)</param>
        public void removeCircle2D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= circles2D.Count)
            {
                return;
            }
            circles2D.RemoveAt(myIndex);
            needsRender = true;
        }


        /// <summary>
        /// Adds a filled rectangle to the 2D Renderer objects. 0,0 is considered the center of the 2D Model
        /// </summary>
        /// <param name="xStart">lower left corner X</param>
        /// <param name="yStart">lower left corner Y</param>
        /// <param name="xEnd">upper right corner X</param>
        /// <param name="yEnd">upper right corner Y</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        /// <param name="layer">layer number.positive. lowest layers at the bottom</param>
        public void addRectangle2D(double xStart, double yStart, double xEnd, double yEnd, byte red, byte green, byte blue, int layer)
        {
            CustomRectangle2D cr = new CustomRectangle2D();
            cr.myRectColor = Color.FromRgb(red, green, blue);
            cr.myRectStartPosition = new Point(xStart, yStart);
            cr.myRectDiagonal = new Vector(xEnd - xStart, yEnd - yStart);
            cr.layer = Math.Abs(layer);
            rectangles2D.Add(cr);
            needsRender = true;
            use2D = true;
        }


        /// <summary>
        ///  Adds a filled triangle to the 2D Renderer objects. 0,0 is considered the center of the 2D Model
        /// </summary>
        /// <param name="x1">Point 1 x</param>
        /// <param name="y1">Point 1 y</param>
        /// <param name="x2">Point 2 x</param>
        /// <param name="y2">Point 2 y</param>
        /// <param name="x3">Point 3 x</param>
        /// <param name="y3">Point 3 y</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        /// <param name="layer">layer number.positive. lowest layers at the bottom</param>
        public void addTriangle2D(double x1, double y1, double x2, double y2, double x3, double y3, byte red, byte green, byte blue, int layer)
        {
            CustomTriangle2D cr = new CustomTriangle2D();
            cr.myTriangleColor = Color.FromRgb(red, green, blue);
            cr.p1 = new Point(x1, y1);
            cr.p2 = new Point(x2, y2);
            cr.p3 = new Point(x3, y3);
            cr.layer = Math.Abs(layer);
            triangles2D.Add(cr);

            needsRender = true;
            use2D = true;
        }


        /// <summary>
        ///  Adds a filled triangle to the 3D Renderer objects. 0,0 is considered the center of the 3D Model
        /// </summary>
        /// <param name="x1">Point 1 x</param>
        /// <param name="y1">Point 1 y</param>
        /// <param name="z1">Point 1 zy</param>
        /// <param name="x2">Point 2 x</param>
        /// <param name="y2">Point 2 y</param>
        /// <param name="z2">Point 2 z</param>
        /// <param name="x3">Point 3 x</param>
        /// <param name="y3">Point 3 y</param>
        /// <param name="z3">Point 3 z</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        public void addTriangle3D(double x1, double y1, double z1, double x2, double y2, double z2, double x3, double y3, double z3, byte red, byte green, byte blue)
        {
            CustomTriangle3D cr = new CustomTriangle3D();
            cr.myTriangleColor = Color.FromRgb(red, green, blue);
            cr.p1 = new Point3D(x1, y1, z1);
            cr.p2 = new Point3D(x2, y2, z2);
            cr.p3 = new Point3D(x3, y3, z3);

            triangles3D.Add(cr);

            needsRender = true;
            use3D = true;
        }


        /// <summary>
        /// Adds a filled rounded rectangle to the 2D Renderer objects. 0,0 is considered the center of the 2D Model
        /// </summary>
        /// <param name="xStart">lower left corner X</param>
        /// <param name="yStart">lower left corner Y</param>
        /// <param name="xEnd">upper right corner X</param>
        /// <param name="yEnd">upper right corner Y</param>
        /// <param name="cornerRadius">side ratio of corner radius, between 0 to 0.33</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        /// <param name="layer">layer number.positive. lowest layers at the bottom</param>
        public void addRoundedRectangle2D(double xStart, double yStart, double xEnd, double yEnd, double cornerRadius, byte red, byte green, byte blue, int layer)
        {
            CustomRoundedRectangle2D cr = new CustomRoundedRectangle2D();
            cr.myRectColor = Color.FromRgb(red, green, blue);
            cr.myRectStartPosition = new Point(xStart, yStart);
            cr.myRectDiagonal = new Vector(xEnd - xStart, yEnd - yStart);
            double ncr = cornerRadius;
            if (ncr < 0 || ncr > 0.33) ncr = 0.33;
            cr.myCornerRadius = ncr;
            cr.layer = Math.Abs(layer);
            roundedrectangles2D.Add(cr);
            needsRender = true;
            use2D = true;
        }


        /// <summary>
        /// Updates a filled rectangle from the 2D Renderer objects rectangles2D list. 0,0 is considered the center of the 2D Model
        /// </summary>
        /// <param name="myIndex">rectangles2D List Index (0 based)</param>
        /// <param name="xStart">lower left corner X</param>
        /// <param name="yStart">lower left corner Y</param>
        /// <param name="xEnd">upper right corner X</param>
        /// <param name="yEnd">upper right corner Y</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        /// <param name="layer">layer number.positive. lowest layers at the bottom</param>
        /// <returns>If the update was successful</returns>
        public bool updateRectangle2D(int myIndex, double xStart, double yStart, double xEnd, double yEnd, byte red, byte green, byte blue, int layer)
        {
            if (myIndex < 0 || myIndex >= rectangles2D.Count)
            {
                return false;
            }
            CustomRectangle2D cr = new CustomRectangle2D();
            cr.myRectColor = Color.FromRgb(red, green, blue);
            cr.myRectStartPosition = new Point(xStart, yStart);
            cr.myRectDiagonal = new Vector(xEnd - xStart, yEnd - yStart);
            cr.layer = Math.Abs(layer);
            rectangles2D[myIndex] = cr;
            needsRender = true;
            return true;
        }

        /// <summary>
        /// Updates a filled triangle from the 2D Renderer objects rectangles2D list. 0,0 is considered the center of the 2D Model
        /// </summary>
        /// <param name="myIndex">triangles2D List Index (0 based)</param>
        /// <param name="x1">Point 1 x</param>
        /// <param name="y1">Point 1 y</param>
        /// <param name="x2">Point 2 x</param>
        /// <param name="y2">Point 2 y</param>
        /// <param name="x3">Point 3 x</param>
        /// <param name="y3">Point 3 y</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        /// <param name="layer">layer number.positive. lowest layers at the bottom</param>
        /// <returns>If the update was successful</returns>
        public bool updateTriangle2D(int myIndex, double x1, double y1, double x2, double y2, double x3, double y3, byte red, byte green, byte blue, int layer)
        {
            if (myIndex < 0 || myIndex >= triangles2D.Count)
            {
                return false;
            }
            CustomTriangle2D cr = new CustomTriangle2D();
            cr.myTriangleColor = Color.FromRgb(red, green, blue);
            cr.p1 = new Point(x1, y1);
            cr.p2 = new Point(x2, y2);
            cr.p3 = new Point(x3, y3);
            cr.layer = Math.Abs(layer);
            triangles2D[myIndex] = cr;
            needsRender = true;
            return true;
        }



        /// <summary>
        /// Updates a filled triangle from the 3D Renderer objects rectangles3D list. 0,0 is considered the center of the 3D Model
        /// </summary>
        /// <param name="myIndex">triangles3D List Index (0 based)</param>
        /// <param name="x1">Point 1 x</param>
        /// <param name="y1">Point 1 y</param>
        /// <param name="z1">Point 1 z</param>
        /// <param name="x2">Point 2 x</param>
        /// <param name="y2">Point 2 y</param>
        /// <param name="z2">Point 2 z</param>
        /// <param name="x3">Point 3 x</param>
        /// <param name="y3">Point 3 y</param>
        /// <param name="z3">Point 3 z</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        /// <returns>If the update was successful</returns>
        public bool updateTriangle3D(int myIndex, double x1, double y1, double z1, double x2, double y2, double z2, double x3, double y3, double z3, byte red, byte green, byte blue)
        {
            if (myIndex < 0 || myIndex >= triangles3D.Count)
            {
                return false;
            }
            CustomTriangle3D cr = new CustomTriangle3D();
            cr.myTriangleColor = Color.FromRgb(red, green, blue);
            cr.p1 = new Point3D(x1, y1, z1);
            cr.p2 = new Point3D(x2, y2, z2);
            cr.p3 = new Point3D(x3, y3, z3);

            triangles3D[myIndex] = cr;
            needsRender = true;
            return true;
        }

        /// <summary>
        /// Updates a filled rounded rectangle from the 2D Renderer objects roundedrectangles2D list. 0,0 is considered the center of the 2D Model
        /// </summary>
        /// <param name="myIndex">roundedrectangles2D List Index (0 based)</param>
        /// <param name="xStart">lower left corner X</param>
        /// <param name="yStart">lower left corner Y</param>
        /// <param name="xEnd">upper right corner X</param>
        /// <param name="yEnd">upper right corner Y</param>
        /// <param name="cornerRadius">side ratio of corner radius, between 0 to 0.33</param>
        /// <param name="red">red color 0-255</param>
        /// <param name="green">green color 0-255</param>
        /// <param name="blue">blue color 0-255</param>
        /// <param name="layer">layer number.positive. lowest layers at the bottom</param>
        /// <returns>If the update was successful</returns>
        public bool updateRoundedRectangle2D(int myIndex, double xStart, double yStart, double xEnd, double yEnd, double cornerRadius, byte red, byte green, byte blue, int layer)
        {
            if (myIndex < 0 || myIndex >= roundedrectangles2D.Count)
            {
                return false;
            }
            CustomRoundedRectangle2D cr = new CustomRoundedRectangle2D();
            cr.myRectColor = Color.FromRgb(red, green, blue);
            cr.myRectStartPosition = new Point(xStart, yStart);
            cr.myRectDiagonal = new Vector(xEnd - xStart, yEnd - yStart);
            double ncr = cornerRadius;
            if (ncr < 0 || ncr > 0.33) ncr = 0.33;
            cr.myCornerRadius = ncr;
            cr.layer = Math.Abs(layer);
            roundedrectangles2D[myIndex] = cr;
            needsRender = true;
            return true;
        }

        /// <summary>
        /// Removes a filled rectangle from the 2D Renderer objects rectangles2D list
        /// </summary>
        /// <param name="myIndex">rectangles2D List Index (0 based)</param>
        public void removeRectangle2D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= rectangles2D.Count)
            {
                return;
            }
            rectangles2D.RemoveAt(myIndex);
            needsRender = true;
        }


        /// <summary>
        /// Removes a filled triangle from the 2D Renderer objects triangles2D list
        /// </summary>
        /// <param name="myIndex">triangles2D List Index (0 based)</param>
        public void removeTriangle2D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= triangles2D.Count)
            {
                return;
            }
            triangles2D.RemoveAt(myIndex);
            needsRender = true;
        }


        /// <summary>
        /// Removes a filled triangle from the 3D Renderer objects triangles3D list
        /// </summary>
        /// <param name="myIndex">triangles3D List Index (0 based)</param>
        public void removeTriangle3D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= triangles3D.Count)
            {
                return;
            }
            triangles3D.RemoveAt(myIndex);
            needsRender = true;
        }

        /// <summary>
        /// Removes a filled rounded rectangle from the 2D Renderer objects roundedrectangles2D list
        /// </summary>
        /// <param name="myIndex">rounded rectangles2D List Index (0 based)</param>
        public void removeRoundedRectangle2D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= roundedrectangles2D.Count)
            {
                return;
            }
            roundedrectangles2D.RemoveAt(myIndex);
            needsRender = true;
        }

        /// <summary>
        /// Adds a 3D CAD file to the Custom Renderer 3Dmodel. 0,0,0 is considered the center of the 3D Model
        /// </summary>
        /// <param name="filePath">Relative or absolute path to file of type: 3ds,lwo,obj,stl</param>
        public void addFile3D(string filePath)
        {


            FileModelVisual3D fv = new FileModelVisual3D();
            if (File.Exists(filePath)) fv.Source = filePath;
            else
            { //MessageBox.Show("Could not find 3D file " + filePath); 
                return;
            }
            //for now default bounding box


            //bbox.Union(fv.);

            needsRender = true;
            //if (model3D.Content.Bounds.SizeZ > PUPPIGUISettings.nodeHeight) PUPPIGUISettings.nodeHeight = model3D.Content.Bounds.SizeZ;  
            fileVisuals3D.Add(fv);

            use3D = true;
        }
        /// <summary>
        /// Updates 3D CAD file of the Custom Renderer 3Dmodel. 0,0,0 is considered the center of the 3D Model
        /// </summary>
        /// <param name="myIndex">Index of 3D object to update in list fileVisuals3D (0 based)</param>
        /// <param name="filePath">Relative or absolute path to file of type: 3ds,lwo,obj,stl</param>
        /// <returns>If update was successful</returns>
        public bool updateFile3D(int myIndex, string filePath)
        {
            if (myIndex < 0 || myIndex >= fileVisuals3D.Count)
            {
                return false;
            }
            FileModelVisual3D fv = new FileModelVisual3D();
            if (File.Exists(filePath)) fv.Source = filePath;
            else { MessageBox.Show("Could not find 3D file " + filePath); return false; }
            needsRender = true;
            fileVisuals3D[myIndex] = fv;
            return true;
        }
        /// <summary>
        /// Removes a 3D CAD file of the Custom Renderer 3Dmodel
        /// </summary>
        /// <param name="myIndex">Index of 3D object to remove in list fileVisuals3D (0 based)</param>
        public void removeFile3D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= fileVisuals3D.Count)
            {
                return;
            }
            fileVisuals3D.RemoveAt(myIndex);
            needsRender = true;
        }


        /// <summary>
        /// Adds a custom caption to the 3D model of the custom renderer.
        /// </summary>
        /// <param name="captionText">The caption text (can be changed programmatically)</param>
        /// <param name="xCenter">Caption x center</param>
        /// <param name="yCenter">Caption y center</param>
        /// <param name="zCenter">Caption z center</param>
        /// <param name="textHeight">Height of the text in same units as the 3D model</param>
        /// <param name="red">Red Color component (0-255)</param>
        /// <param name="green">Green Color component (0-255)</param>
        /// <param name="blue">Blue Color component (0-255)</param>
        /// <param name="captionDirection">Direction in XY plane</param>
        /// <param name="textOrientation">Flat text (on XY plane) or vertical</param>
        public void addCaption3D(string captionText, double xCenter, double yCenter, double zCenter, double textHeight, byte red, byte green, byte blue, PUPPIimageDirection captionDirection, PUPPIimageOrientation textOrientation)
        {
            CustomCaption3D cc = new CustomCaption3D();
            cc.myCaptionDir = captionDirection;
            cc.myCaptionOrient = textOrientation;
            cc.myCaptionPosition = new Point3D(xCenter, yCenter, zCenter);
            cc.myCaptionColor = Color.FromRgb(red, green, blue);
            cc.myCaptionText = captionText;
            cc.myCaptionTextHeight = textHeight;
            //bbox.Union(cc.myCaptionPosition.makeSizeBox(textHeight,textHeight,textHeight));  
            needsRender = true;
            captions3D.Add(cc);
            use3D = true;
        }
        /// <summary>
        /// Updates a custom caption of the 3D model of the custom renderer in the captions3D list.
        /// </summary>
        /// <param name="myIndex">captions3D List Index (0 based)</param>
        /// <param name="captionText">The caption text (can be changed programmatically)</param>
        /// <param name="xCenter">Caption x center</param>
        /// <param name="yCenter">Caption y center</param>
        /// <param name="zCenter">Caption z center</param>
        /// <param name="textHeight">Height of the text in same units as the 3D model</param>
        /// <param name="red">Red Color component (0-255)</param>
        /// <param name="green">Green Color component (0-255)</param>
        /// <param name="blue">Blue Color component (0-255)</param>
        /// <param name="captionDirection">Direction in XY plane</param>
        /// <param name="textOrientation">Flat text (on XY plane) or vertical</param>
        /// <returns>If the update was successful</returns>
        public bool updateCaption3D(int myIndex, string captionText, double xCenter, double yCenter, double zCenter, double textHeight, byte red, byte green, byte blue, PUPPIimageDirection captionDirection, PUPPIimageOrientation textOrientation)
        {
            if (myIndex < 0 || myIndex >= captions3D.Count)
            {
                return false;
            }
            CustomCaption3D cc = new CustomCaption3D();
            cc.myCaptionDir = captionDirection;
            cc.myCaptionOrient = textOrientation;
            cc.myCaptionPosition = new Point3D(xCenter, yCenter, zCenter);
            cc.myCaptionColor = Color.FromRgb(red, green, blue);
            cc.myCaptionText = captionText;
            cc.myCaptionTextHeight = textHeight;
            captions3D[myIndex] = cc;
            needsRender = true;
            return true;
        }
        /// <summary>
        ///  Removes a custom caption of the 3D model of the custom renderer in the captions3D list.
        /// </summary>
        /// <param name="myIndex">captions3D List Index (0 based)</param>
        public void removeCaption3D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= captions3D.Count)
            {
                return;
            }
            captions3D.RemoveAt(myIndex);
            needsRender = true;

        }


        /// <summary>
        /// Adds a custom caption to the 2D model of the custom renderer.
        /// </summary>
        /// <param name="captionText">The caption text (can be changed programmatically)</param>
        /// <param name="xCenter">Caption x center</param>
        /// <param name="yCenter">Caption y center</param>
        /// <param name="textHeight">Height of the text in same units as the 3D model</param>
        /// <param name="red">Red Color component (0-255)</param>
        /// <param name="green">Green Color component (0-255)</param>
        /// <param name="blue">Blue Color component (0-255)</param>
        /// <param name="captionDirection">Direction in XY plane</param>
        /// <param name="layer">layer number. positive. lowest layers at the bottom</param>
        public void addCaption2D(string captionText, double xCenter, double yCenter, double textHeight, byte red, byte green, byte blue, PUPPIimageDirection captionDirection, int layer)
        {
            CustomCaption2D cc = new CustomCaption2D();
            cc.myCaptionDir = captionDirection;

            cc.myCaptionPosition = new Point(xCenter, yCenter);
            cc.myCaptionText = captionText;
            cc.myCaptionTextHeight = textHeight;
            cc.myCaptionColor = Color.FromRgb(red, green, blue);
            cc.layer = Math.Abs(layer);
            needsRender = true;
            captions2D.Add(cc);
            use2D = true;
        }
        /// <summary>
        /// Updates a custom caption of the 2D model of the custom renderer in the captions2D list.
        /// </summary>
        /// <param name="myIndex">captions2D List Index (0 based)</param>
        /// <param name="captionText">The caption text (can be changed programmatically)</param>
        /// <param name="xCenter">Caption x center</param>
        /// <param name="yCenter">Caption y center</param>
        /// <param name="textHeight">Height of the text in same units as the 3D model</param>
        /// <param name="red">Red Color component (0-255)</param>
        /// <param name="green">Green Color component (0-255)</param>
        /// <param name="blue">Blue Color component (0-255)</param>
        /// <param name="captionDirection">Direction in XY plane</param>
        /// <param name="layer">layer number. positive. lowest layers at the bottom</param>
        /// <returns>If the update was successful</returns>
        public bool updateCaption2D(int myIndex, string captionText, double xCenter, double yCenter, double textHeight, byte red, byte green, byte blue, PUPPIimageDirection captionDirection, int layer)
        {
            if (myIndex < 0 || myIndex >= captions2D.Count)
            {
                return false;
            }
            CustomCaption2D cc = new CustomCaption2D();
            cc.myCaptionDir = captionDirection;

            cc.myCaptionPosition = new Point(xCenter, yCenter);
            cc.myCaptionText = captionText;
            cc.myCaptionTextHeight = textHeight;
            cc.myCaptionColor = Color.FromRgb(red, green, blue);
            cc.layer = Math.Abs(layer);
            captions2D[myIndex] = cc;
            needsRender = true;
            return true;
        }
        /// <summary>
        ///  Removes a custom caption of the 2D model of the custom renderer in the captions2D list.
        /// </summary>
        /// <param name="myIndex">captions2D List Index (0 based)</param>
        public void removeCaption2D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= captions2D.Count)
            {
                return;
            }
            captions2D.RemoveAt(myIndex);
            needsRender = true;

        }

        /// <summary>
        /// Adds a custom Image to the 3D model of the custom renderer.
        /// </summary>
        /// <param name="imageFile">The name of the file storing the image (can be changed programmatically)</param>
        /// <param name="xCenter">Image x center</param>
        /// <param name="yCenter">Image y center</param>
        /// <param name="zCenter">Image z center</param>
        /// <param name="imageHeight">Height of the Image in same units as the 3D model</param>
        /// <param name="imageDirection">Direction in XY plane</param>
        /// <param name="imageOrientation">Flat Image (on XY plane) or vertical</param>
        public void addImage3D(string imageFile, double xCenter, double yCenter, double zCenter, double imageHeight, double imageWidth, PUPPIimageDirection imageDirection, PUPPIimageOrientation imageOrientation)
        {
            if (File.Exists(imageFile) == false) return;
            CustomImage3D cc = new CustomImage3D();
            cc.myImageDirection = imageDirection;
            cc.myImageOrient = imageOrientation;
            cc.myImagePosition = new Point3D(xCenter, yCenter, zCenter);
            cc.myImageFilePath = imageFile;
            cc.myImageHeight = imageHeight;
            cc.myImageWidth = imageWidth;

            needsRender = true;
            images3D.Add(cc);
            use3D = true;
        }
        /// <summary>
        /// Updates a custom Image of the 3D model of the custom renderer in the images3D list.
        /// </summary>
        /// <param name="myIndex">images3D List Index (0 based)</param>
        /// <param name="imageFile">The Image file path (can be changed programmatically)</param>
        /// <param name="xCenter">Image x center</param>
        /// <param name="yCenter">Image y center</param>
        /// <param name="zCenter">Image z center</param>
        /// <param name="ImageHeight">Height of the Image in same units as the 3D model</param>
        /// <param name="ImageDirection">Direction in XY plane</param>
        /// <param name="ImageOrientation">Flat Image (on XY plane) or vertical</param>
        /// <returns>If the update was successful</returns>
        public bool updateImage3D(int myIndex, string imageFile, double xCenter, double yCenter, double zCenter, double imageHeight, double imageWidth, PUPPIimageDirection ImageDirection, PUPPIimageOrientation ImageOrientation)
        {
            if (myIndex < 0 || myIndex >= images3D.Count)
            {
                return false;
            }
            if (File.Exists(imageFile) == false) return false;
            CustomImage3D cc = new CustomImage3D();
            cc.myImageDirection = ImageDirection;
            cc.myImageOrient = ImageOrientation;
            cc.myImagePosition = new Point3D(xCenter, yCenter, zCenter);
            cc.myImageHeight = imageHeight;
            cc.myImageWidth = imageWidth;
            cc.myImageFilePath = imageFile;
            images3D[myIndex] = cc;
            needsRender = true;
            return true;
        }
        /// <summary>
        /// Removes a custom Image of the 3D model of the custom renderer in the images3D list
        /// </summary>
        /// <param name="myIndex">images3D List Index (0 based)</param>
        public void removeImage3D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= images3D.Count)
            {
                return;
            }
            images3D.RemoveAt(myIndex);
            needsRender = true;
        }

        /// <summary>
        /// Adds a custom Image to the 2D model of the custom renderer.
        /// </summary>
        /// <param name="imageFile">The name of the file storing the image (can be changed programmatically)</param>
        /// <param name="xCenter">Image x center</param>
        /// <param name="yCenter">Image y center</param>
        /// <param name="imageHeight">Height of the Image in same units as the 2D model</param>
        /// <param name="imageDirection">Direction in XY plane</param>
        public void addImage2D(string imageFile, double xCenter, double yCenter, double imageWidth, double imageHeight, PUPPIimageDirection imageDirection, int layer)
        {
            if (File.Exists(imageFile) == false) return;
            CustomImage2D cc = new CustomImage2D();
            cc.myImageDirection = imageDirection;
            cc.myImagePosition = new Point(xCenter, yCenter);
            cc.myImageFilePath = imageFile;
            cc.myImageHeight = imageHeight;
            cc.myImageWidth = imageWidth;
            cc.layer = layer;
            needsRender = true;
            images2D.Add(cc);
            use2D = true;
        }
        /// <summary>
        /// Updates a custom Image of the 2D model of the custom renderer in the images2D list.
        /// </summary>
        /// <param name="myIndex">images2D List Index (0 based)</param>
        /// <param name="imageFile">The Image file path (can be changed programmatically)</param>
        /// <param name="xCenter">Image x center</param>
        /// <param name="yCenter">Image y center</param>
        /// <param name="ImageHeight">Height of the Image in same units as the 2D model</param>
        /// <param name="ImageDirection">Direction in XY plane</param>
        /// <returns>If the update was successful</returns>
        public bool updateImage2D(int myIndex, string imageFile, double xCenter, double yCenter, double imageWidth, double imageHeight, PUPPIimageDirection ImageDirection, int layer)
        {
            if (myIndex < 0 || myIndex >= images2D.Count)
            {
                return false;
            }
            if (File.Exists(imageFile) == false) return false;
            CustomImage2D cc = new CustomImage2D();
            cc.myImageDirection = ImageDirection;
            cc.myImagePosition = new Point(xCenter, yCenter);
            cc.myImageHeight = imageHeight;
            cc.myImageWidth = imageWidth;
            cc.myImageFilePath = imageFile;
            cc.layer = layer;
            images2D[myIndex] = cc;
            needsRender = true;
            return true;
        }
        /// <summary>
        /// Removes a custom Image of the 2D model of the custom renderer in the images2D list
        /// </summary>
        /// <param name="myIndex">images2D List Index (0 based)</param>
        public void removeImage2D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= images2D.Count)
            {
                return;
            }
            images2D.RemoveAt(myIndex);
            needsRender = true;
        }
        /// <summary>
        /// Returns the bounding box of a default node as specified by PUPPIGUISettings values. Useful for scaling primitives to ensure fit. 
        /// </summary>
        /// <returns>Rect3D structure for a bounding box of default node dimensions centered at 0,0,0 (node relative space)</returns>
        public Rect3D getDefaultNodeBoundingBox()
        {
            Rect3D r = new Rect3D();
            Point3D ppp = new Point3D(0, 0, 0);
            r = ppp.makedefaultfitinnodebox();
            return r;
        }

        /// <summary>
        /// Adds a Visual element build by the programmer to the 3D rendered objects.
        /// Recommended to first hardcode transforms of model and children: PUPPICAD.HelperClasses.utilities.hardcodeTransforms
        /// </summary>
        /// <param name="myModel">a System.Windows.Media.Media3D.ModelVisual3D object</param>
        /// <param name="fitToNode">Fits model within a default node size box by scaling and translating. Default is OriginalSize.</param>
        public void addModelVisual3D(ModelVisual3D myModel, PUPPIGUISettings.ModelFitInNodeMode fitToNode = PUPPIGUISettings.ModelFitInNodeMode.OriginalSize)
        {
            Point3D ppp = new Point3D(0, 0, 0);
            Rect3D newbox = ppp.makedefaultfitinnodebox();
            if (fitToNode == PUPPIGUISettings.ModelFitInNodeMode.Fit)
            {

                modelVisuals3D.Add(myModel.fitVisualAndChildren(newbox));
            }
            else if (fitToNode == PUPPIGUISettings.ModelFitInNodeMode.FitOnlyBase)
            {
                modelVisuals3D.Add(myModel.fitToBaseVisualAndChildren(newbox));
            }
            else
            {
                modelVisuals3D.Add(myModel.cloneVisualAndChildren());
            }

            needsRender = true;
            use3D = true;
        }


        ///// <summary>
        ///// Adds a Visual element buuilt by the programmer to the 3D rendered objects, keeping the transforms.
        ///// </summary>
        ///// <param name="myModel">a System.Windows.Media.Media3D.ModelVisual3D object</param>
        //public void addModelVisual3DKeepTransforms(ModelVisual3D myModel)
        //{
        //    modelVisuals3D.Add(myModel.cloneMyVisual());
        //    needsRender = true;
        //    use3D = true;
        //}


        /// <summary>
        /// Adds a Visual element built by the programmer to the 2D rendered objects.
        /// Recommended to first hardcode transforms of model and children: PUPPICAD.HelperClasses.utilities.hardcodeTransforms
        /// </summary>
        /// <param name="myModel">a System.Windows.Media.Media3D.ModelVisual3D object</param>
        /// <param name="fitToNode">Fits model within a default node size box by scaling and translating. Default is OriginalSize.</param>
        public void addModelVisual2D(ModelVisual3D myModel, PUPPIGUISettings.ModelFitInNodeMode fitToNode = PUPPIGUISettings.ModelFitInNodeMode.OriginalSize)
        {
            Point3D ppp = new Point3D(0, 0, 0);
            Rect3D newbox = ppp.makedefaultfitinnodebox();
            if (fitToNode == PUPPIGUISettings.ModelFitInNodeMode.Fit)
            {

                modelVisuals2D.Add(myModel.fitVisualAndChildren(newbox));
            }
            else if (fitToNode == PUPPIGUISettings.ModelFitInNodeMode.FitOnlyBase)
            {
                modelVisuals2D.Add(myModel.fitToBaseVisualAndChildren(newbox));
            }
            else
            {

                modelVisuals2D.Add(myModel.cloneVisualAndChildren());
            }
            needsRender = true;
            use2D = true;
        }

        ///// <summary>
        ///// Adds a Visual element buuilt by the programmer to the 2D rendered objects, keeping the transforms.
        ///// </summary>
        ///// <param name="myModel">a System.Windows.Media.Media3D.ModelVisual3D object</param>
        //public void addModelVisual2DKeepTransforms(ModelVisual3D myModel)
        //{
        //    modelVisuals2D.Add(myModel.cloneMyVisual());  
        //    needsRender = true;
        //    use2D = true;
        //}


        /// <summary>
        /// Updates a Visual element build by the programmer from the 3D rendered objects.
        /// </summary>
        /// <param name="myIndex">modelVisuals3D List Index (0 based)</param>
        /// <param name="myModel">a System.Windows.Media.Media3D.ModelVisual3D object</param>
        /// <param name="fitToNode">Fits model within a default node size box by scaling and translating. Default is OriginalSize.</param>
        public bool updateModelVisual3D(int myIndex, ModelVisual3D myModel, PUPPIGUISettings.ModelFitInNodeMode fitToNode = PUPPIGUISettings.ModelFitInNodeMode.OriginalSize)
        {
            if (myIndex < 0 || myIndex >= modelVisuals3D.Count)
            {
                return false;
            }
            Point3D ppp = new Point3D(0, 0, 0);
            Rect3D newbox = ppp.makedefaultfitinnodebox();
            if (fitToNode == PUPPIGUISettings.ModelFitInNodeMode.Fit)
            {

                modelVisuals3D[myIndex] = myModel.fitVisualAndChildren(newbox);
            }
            else if (fitToNode == PUPPIGUISettings.ModelFitInNodeMode.FitOnlyBase)
            {
                modelVisuals3D[myIndex] = myModel.fitToBaseVisualAndChildren(newbox);
            }
            else
            {

                modelVisuals3D[myIndex] = myModel.cloneVisualAndChildren();
            }
            needsRender = true;
            return true;
        }
        /// <summary>
        /// Updates a Visual element build by the programmer from the 2D rendered objects.
        /// </summary>
        /// <param name="myIndex">modelVisuals2D List Index (0 based)</param>
        /// <param name="myModel">a System.Windows.Media.Media2D.ModelVisual2D object</param>
        /// <param name="fitToNode">Fits model within a default node size box by scaling and translating. Default is OriginalSize.</param>
        public bool updateModelVisual2D(int myIndex, ModelVisual3D myModel, PUPPIGUISettings.ModelFitInNodeMode fitToNode = PUPPIGUISettings.ModelFitInNodeMode.OriginalSize)
        {
            if (myIndex < 0 || myIndex >= modelVisuals2D.Count)
            {
                return false;
            }
            Point3D ppp = new Point3D(0, 0, 0);
            Rect3D newbox = ppp.makedefaultfitinnodebox();
            if (fitToNode == PUPPIGUISettings.ModelFitInNodeMode.Fit)
            {

                modelVisuals2D[myIndex] = myModel.fitVisualAndChildren(newbox);
            }
            else if (fitToNode == PUPPIGUISettings.ModelFitInNodeMode.FitOnlyBase)
            {
                modelVisuals2D[myIndex] = myModel.fitToBaseVisualAndChildren(newbox);
            }
            else
            {
                modelVisuals2D[myIndex] = myModel.cloneVisualAndChildren();
            }
            needsRender = true;
            return true;
        }
        /// <summary>
        /// removes a Visual element build by the programmer from the 3D rendered objects.
        /// </summary>
        /// <param name="myIndex">>modelVisual3D List Index (0 based)</param>
        public void removeModelVisual3D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= modelVisuals3D.Count)
            {
                return;
            }
            modelVisuals3D.RemoveAt(myIndex);
            needsRender = true;
        }

        /// <summary>
        /// removes a Visual element build by the programmer from the 2D rendered objects.
        /// </summary>
        /// <param name="myIndex">>modelVisual2D List Index (0 based)</param>
        public void removeModelVisual2D(int myIndex)
        {
            if (myIndex < 0 || myIndex >= modelVisuals2D.Count)
            {
                return;
            }
            modelVisuals2D.RemoveAt(myIndex);
            needsRender = true;
        }

        /// <summary>
        /// Convenience method for 3D, stacking models on top of each other with wireframe borders and number captions, within the footprint of a node.
        /// Useful for displaying multiple models in one node. The models and borders are added as a single ModelVisual3D to the modelVisuals3D collection
        /// 
        /// </summary>
        /// <param name="modelVisuals"></param>
        public void addStacked3DModels(List<ModelVisual3D> modelVisuals)
        {
            ModelVisual3D toAdd = new ModelVisual3D();
            List<Rect3D> bbxes = new List<Rect3D>();
            for (int i = 0; i < modelVisuals.Count; i++)
            {
                bbxes.Add(modelVisuals[i].getBBRecursive());
            }
            Rect3D largestBB = new Rect3D(0, 0, 0, 0, 0, 0);
            for (int i = 0; i < bbxes.Count; i++)
            {
                if (bbxes[i].getDiagonal() > largestBB.getDiagonal())
                {
                    largestBB = bbxes[i];
                }
            }
            if (largestBB.IsEmpty) return;
            double curheight = 0;
            for (int i = 0; i < modelVisuals.Count; i++)
            {
                Rect3D currentBB = new Rect3D(-largestBB.SizeX / 2, -largestBB.SizeY / 2, curheight, largestBB.SizeX, largestBB.SizeY, largestBB.SizeZ);
                ModelVisual3D bv = new ModelVisual3D();
                var meshBuilder = new MeshBuilder(false, false);

                meshBuilder.AddBoundingBox(currentBB, PUPPIGUISettings.solidConnectionSize);
                var mesh = meshBuilder.ToMesh(true);
                GeometryModel3D newModel = new GeometryModel3D();
                newModel.Geometry = mesh;
                newModel.Material = new DiffuseMaterial(new SolidColorBrush(Colors.DarkBlue));

                bv.Content = newModel;
                toAdd.addFlatVisualAndChildren(bv);

                Rect3D mbb = bbxes[i];
                //zero center
                ModelVisual3D mc = modelVisuals[i].translateVisualAndChildren(-mbb.rectcenter().X, -mbb.rectcenter().Y, -mbb.rectcenter().Z);
                double scaleX = mbb.SizeX / (currentBB.SizeX + PUPPIGUISettings.solidConnectionSize);
                double scaleY = mbb.SizeY / (currentBB.SizeY + PUPPIGUISettings.solidConnectionSize);
                double scaleZ = mbb.SizeZ / (currentBB.SizeZ + PUPPIGUISettings.solidConnectionSize);

                //ensure fit
                double scaleme = Math.Min(scaleX, Math.Min(scaleY, scaleZ));
                mc = mc.scaleVisualAndChildren(scaleme, scaleme, scaleme);
                Point3D newpos = currentBB.rectcenter();
                mc = mc.translateVisualAndChildren(newpos.X, newpos.Y, newpos.Z);
                toAdd.addFlatVisualAndChildren(mc);
                curheight += currentBB.SizeZ;

            }
            addModelVisual3D(toAdd, PUPPIGUISettings.ModelFitInNodeMode.FitOnlyBase);

        }



        /// <summary>
        /// Convenience method for 3D display of object fitting within footptint surrounded by box
        /// Recommended to first hardcode transforms of model and children: PUPPICAD.HelperClasses.utilities.hardcodeTransforms  
        /// </summary>
        /// <param name="modelVisuals"></param>
        public void add3DModelFitBox(ModelVisual3D modelVisual, double xB, double yB, double zB)
        {
            ModelVisual3D toAdd = new ModelVisual3D();
            Rect3D bbx = new Rect3D();
            bbx = modelVisual.getBBRecursive();


            if (bbx.IsEmpty) return;

            //for (int i = 0; i < modelVisuals.Count; i++)
            //{
            //    Rect3D currentBB = new Rect3D(-largestBB.SizeX / 2, -largestBB.SizeY / 2, curheight, largestBB.SizeX, largestBB.SizeY, largestBB.SizeZ);






            ModelVisual3D mc = modelVisual.translateVisualAndChildren(-bbx.rectcenter().X, -bbx.rectcenter().Y, -bbx.rectcenter().Z);
            double scaleX = xB / (bbx.SizeX + PUPPIGUISettings.solidConnectionSize);
            double scaleY = yB / (bbx.SizeY + PUPPIGUISettings.solidConnectionSize);
            double scaleZ = zB / (bbx.SizeZ + PUPPIGUISettings.solidConnectionSize);

            //ensure fit
            double scaleme = Math.Min(scaleX, Math.Min(scaleY, scaleZ));
            mc = mc.scaleVisualAndChildren(scaleme, scaleme, scaleme);
            //move back up to lie on canvas
            Rect3D mcbb = mc.getBBRecursive();
            mc = mc.translateVisualAndChildren(0, 0, -mcbb.Location.Z);

            ModelVisual3D bv = new ModelVisual3D();
            var meshBuilder = new MeshBuilder(false, false);
            meshBuilder.AddBoundingBox(mc.getBBRecursive(), PUPPIGUISettings.solidConnectionSize);
            var mesh = meshBuilder.ToMesh(true);
            GeometryModel3D newModel = new GeometryModel3D();
            newModel.Geometry = mesh;
            newModel.Material = new DiffuseMaterial(new SolidColorBrush(Colors.DarkBlue));

            bv.Content = newModel;
            toAdd.addFlatVisualAndChildren(bv);
            toAdd.addFlatVisualAndChildren(mc);
            addModelVisual3D(toAdd);


        }

        /// <summary>
        /// Convenience method for 3D display of object within specified bounds, without showing bounds
        /// Recommended to first hardcode transforms of model and children: PUPPICAD.HelperClasses.utilities.hardcodeTransforms  
        /// </summary>
        /// <param name="modelVisual">ModelVisual3D object</param>
        /// <param name="xB">box x size</param>
        /// <param name="yB">box y size</param>
        /// <param name="zB">box z size</param>
        /// <param name="bottomZ">(optional) z displacement</param>
        public void add3DModelFitRectBounds(ModelVisual3D modelVisual, double xB, double yB, double zB, double bottomZ = 0.0)
        {
            ModelVisual3D toAdd = new ModelVisual3D();
            Rect3D bbx = new Rect3D();
            bbx = modelVisual.getBBRecursive();


            if (bbx.IsEmpty) return;

            //for (int i = 0; i < modelVisuals.Count; i++)
            //{
            //    Rect3D currentBB = new Rect3D(-largestBB.SizeX / 2, -largestBB.SizeY / 2, curheight, largestBB.SizeX, largestBB.SizeY, largestBB.SizeZ);






            ModelVisual3D mc = modelVisual.translateVisualAndChildren(-bbx.rectcenter().X, -bbx.rectcenter().Y, -bbx.rectcenter().Z);
            double scaleX = xB / (bbx.SizeX + PUPPIGUISettings.solidConnectionSize);
            double scaleY = yB / (bbx.SizeY + PUPPIGUISettings.solidConnectionSize);
            double scaleZ = zB / (bbx.SizeZ + PUPPIGUISettings.solidConnectionSize);

            //ensure fit
            double scaleme = Math.Min(scaleX, Math.Min(scaleY, scaleZ));
            mc = mc.scaleVisualAndChildren(scaleme, scaleme, scaleme);
            //move back up to lie on canvas
            Rect3D mcbb = mc.getBBRecursive();
            mc = mc.translateVisualAndChildren(0, 0, -mcbb.Location.Z + bottomZ);


            toAdd.addFlatVisualAndChildren(mc);
            addModelVisual3D(toAdd);


        }





        /// <summary>
        /// Removes all components and signals the visual should be updated.
        /// </summary>
        public void clearAll()
        {
            captions3D.Clear();
            captions2D.Clear();


            images3D.Clear();
            images2D.Clear();

            roundedboxes3D.Clear();
            roundedrectangles2D.Clear();
            boxes3D.Clear();
            wireBoxes3D.Clear();

            borders2D.Clear();
            triangles2D.Clear();
            triangles3D.Clear();

            rectangles2D.Clear();
            spheres3D.Clear();
            circles2D.Clear();
            modelVisuals3D.Clear();
            modelVisuals2D.Clear();
            fileVisuals3D.Clear();
            pipes3D.Clear();
            needsRender = true;
        }


        /// <summary>
        /// Convenience method adding a text inside a rectangle with a black border. Adds a thin CustomBox3D, a thin CustomWireBox3D, and a CustomCaption3D which are all editable as separate elements of the CustomRenderer
        /// </summary>
        /// <param name="text">The text</param>
        /// <param name="xCenter">Box and text X center</param>
        /// <param name="yCenter">Box and text Y center</param>
        /// <param name="zCenter">Box and text Z center</param>
        /// <param name="textRed">Text red color 0-255</param>
        /// <param name="textGreen">Text green color 0-255</param>
        /// <param name="textBlue">Text blue color 0-255</param>
        /// <param name="cellWidth">Cell width</param>
        /// <param name="cellHeight">Cell height</param>
        /// <param name="cellRed">Background red color 0-255</param>
        /// <param name="cellGreen">Background green color 0-255</param>
        /// <param name="cellBlue">Background blue color 0-255</param>
        /// <param name="captionDirection">Direction in XY plane</param>
        /// <param name="textOrientation">Flat text (on XY plane) or vertical</param>
        public void addTextCell3D(string text, double xCenter, double yCenter, double zCenter, byte textRed, byte textGreen, byte textBlue, double cellWidth, double cellHeight, byte cellRed = 255, byte cellGreen = 255, byte cellBlue = 255, PUPPIimageDirection captionDirection = PUPPIimageDirection.positiveXDirection, PUPPIimageOrientation textOrientation = PUPPIimageOrientation.vertical)
        {
            //figure out size to fit in cell
            TextVisual3D tl = new TextVisual3D();
            tl.Text = text;
            tl.TextDirection = new Vector3D(1, 0, 0);
            tl.UpDirection = new Vector3D(0, 1, 0);
            tl.Height = 10;
            Rect3D mySize = tl.getBBRecursive();
            double scaleFactor = Math.Max(mySize.SizeY / cellHeight, mySize.SizeX / cellWidth);
            double textheight = 10 / scaleFactor;
            //need to make sure text in front of cell when looking at it from comming direction
            if (textOrientation == PUPPIimageOrientation.horizontal)
            {
                if (captionDirection == PUPPIimageDirection.positiveXDirection)
                {
                    addBox3D(xCenter - cellWidth * 0.5, yCenter - cellHeight * 0.5, zCenter - PUPPIGUISettings.textRaise * 0.5, xCenter + cellWidth * 0.5, yCenter + cellHeight * 0.5, zCenter + PUPPIGUISettings.textRaise * 0.5, cellRed, cellGreen, cellBlue);
                    addWireBox3D(xCenter - cellWidth * 0.5, yCenter - cellHeight * 0.5, zCenter - PUPPIGUISettings.textRaise * 0.5, xCenter + cellWidth * 0.5, yCenter + cellHeight * 0.5, zCenter + PUPPIGUISettings.textRaise * 0.5, 0, 0, 0);
                    addCaption3D(text, xCenter, yCenter, zCenter + PUPPIGUISettings.textRaise, textheight, textRed, textGreen, textBlue, captionDirection, textOrientation);
                }
                if (captionDirection == PUPPIimageDirection.negativeXDirection)
                {
                    addBox3D(xCenter - cellWidth * 0.5, yCenter - cellHeight * 0.5, zCenter - PUPPIGUISettings.textRaise * 0.5, xCenter + cellWidth * 0.5, yCenter + cellHeight * 0.5, zCenter + PUPPIGUISettings.textRaise * 0.5, cellRed, cellGreen, cellBlue);
                    addWireBox3D(xCenter - cellWidth * 0.5, yCenter - cellHeight * 0.5, zCenter - PUPPIGUISettings.textRaise * 0.5, xCenter + cellWidth * 0.5, yCenter + cellHeight * 0.5, zCenter + PUPPIGUISettings.textRaise * 0.5, 0, 0, 0);
                    addCaption3D(text, xCenter, yCenter, zCenter + PUPPIGUISettings.textRaise, textheight, textRed, textGreen, textBlue, captionDirection, textOrientation);

                }
                if (captionDirection == PUPPIimageDirection.positiveYDirection)
                {
                    addBox3D(xCenter - cellHeight * 0.5, yCenter - cellWidth * 0.5, zCenter - PUPPIGUISettings.textRaise * 0.5, xCenter + cellHeight * 0.5, yCenter + cellWidth * 0.5, zCenter + PUPPIGUISettings.textRaise * 0.5, cellRed, cellGreen, cellBlue);
                    addWireBox3D(xCenter - cellHeight * 0.5, yCenter - cellWidth * 0.5, zCenter - PUPPIGUISettings.textRaise * 0.5, xCenter + cellHeight * 0.5, yCenter + cellWidth * 0.5, zCenter + PUPPIGUISettings.textRaise * 0.5, 0, 0, 0);
                    addCaption3D(text, xCenter, yCenter, zCenter + PUPPIGUISettings.textRaise, textheight, textRed, textGreen, textBlue, captionDirection, textOrientation);

                }
                if (captionDirection == PUPPIimageDirection.negativeYDirection)
                {
                    addBox3D(xCenter - cellHeight * 0.5, yCenter - cellWidth * 0.5, zCenter - PUPPIGUISettings.textRaise * 0.5, xCenter + cellHeight * 0.5, yCenter + cellWidth * 0.5, zCenter + PUPPIGUISettings.textRaise * 0.5, cellRed, cellGreen, cellBlue);
                    addWireBox3D(xCenter - cellHeight * 0.5, yCenter - cellWidth * 0.5, zCenter - PUPPIGUISettings.textRaise * 0.5, xCenter + cellHeight * 0.5, yCenter + cellWidth * 0.5, zCenter + PUPPIGUISettings.textRaise * 0.5, 0, 0, 0);
                    addCaption3D(text, xCenter, yCenter, zCenter + PUPPIGUISettings.textRaise, textheight, textRed, textGreen, textBlue, captionDirection, textOrientation);

                }
            }
            else
            {
                if (captionDirection == PUPPIimageDirection.positiveXDirection)
                {
                    addBox3D(xCenter - cellWidth * 0.5, yCenter - PUPPIGUISettings.textRaise * 0.5, zCenter - cellHeight * 0.5, xCenter + cellWidth * 0.5, yCenter + PUPPIGUISettings.textRaise * 0.5, zCenter + cellHeight * 0.5, cellRed, cellGreen, cellBlue);
                    addWireBox3D(xCenter - cellWidth * 0.5, yCenter - PUPPIGUISettings.textRaise * 0.5, zCenter - cellHeight * 0.5, xCenter + cellWidth * 0.5, yCenter + PUPPIGUISettings.textRaise * 0.5, zCenter + cellHeight * 0.5, 0, 0, 0);
                    addCaption3D(text, xCenter, yCenter - PUPPIGUISettings.textRaise, zCenter, textheight, textRed, textGreen, textBlue, captionDirection, textOrientation);
                }
                if (captionDirection == PUPPIimageDirection.negativeXDirection)
                {
                    addBox3D(xCenter - cellWidth * 0.5, yCenter - PUPPIGUISettings.textRaise * 0.5, zCenter - cellHeight * 0.5, xCenter + cellWidth * 0.5, yCenter + PUPPIGUISettings.textRaise * 0.5, zCenter + cellHeight * 0.5, cellRed, cellGreen, cellBlue);
                    addWireBox3D(xCenter - cellWidth * 0.5, yCenter - PUPPIGUISettings.textRaise * 0.5, zCenter - cellHeight * 0.5, xCenter + cellWidth * 0.5, yCenter + PUPPIGUISettings.textRaise * 0.5, zCenter + cellHeight * 0.5, 0, 0, 0);
                    addCaption3D(text, xCenter, yCenter + PUPPIGUISettings.textRaise, zCenter, textheight, textRed, textGreen, textBlue, captionDirection, textOrientation);

                }
                if (captionDirection == PUPPIimageDirection.positiveYDirection)
                {
                    addBox3D(xCenter - cellHeight * 0.5, yCenter - PUPPIGUISettings.textRaise * 0.5, zCenter - cellWidth * 0.5, xCenter + cellHeight * 0.5, yCenter + PUPPIGUISettings.textRaise * 0.5, zCenter + cellWidth * 0.5, cellRed, cellGreen, cellBlue);
                    addWireBox3D(xCenter - cellHeight * 0.5, yCenter - PUPPIGUISettings.textRaise * 0.5, zCenter - cellWidth * 0.5, xCenter + cellHeight * 0.5, yCenter + PUPPIGUISettings.textRaise * 0.5, zCenter + cellWidth * 0.5, 0, 0, 0);
                    addCaption3D(text, xCenter, yCenter - PUPPIGUISettings.textRaise, zCenter, textheight, textRed, textGreen, textBlue, captionDirection, textOrientation);

                }
                if (captionDirection == PUPPIimageDirection.negativeYDirection)
                {
                    addBox3D(xCenter - cellHeight * 0.5, yCenter - PUPPIGUISettings.textRaise * 0.5, zCenter - cellWidth * 0.5, xCenter + cellHeight * 0.5, yCenter + PUPPIGUISettings.textRaise * 0.5, zCenter + cellWidth * 0.5, cellRed, cellGreen, cellBlue);
                    addWireBox3D(xCenter - cellHeight * 0.5, yCenter - PUPPIGUISettings.textRaise * 0.5, zCenter - cellWidth * 0.5, xCenter + cellHeight * 0.5, yCenter + PUPPIGUISettings.textRaise * 0.5, zCenter + cellWidth * 0.5, 0, 0, 0);
                    addCaption3D(text, xCenter, yCenter - PUPPIGUISettings.textRaise, zCenter, textheight, textRed, textGreen, textBlue, captionDirection, textOrientation);

                }
            }

        }

        /// <summary>
        ///  Convenience method adding a text inside a rectangle with a black border. Adds a thin CustomBox3D, a thin CustomWireBox3D, and a CustomCaption3D which are all editable as separate elements of the CustomRenderer
        /// </summary>
        /// <param name="text"></param>
        /// <param name="layer"></param>
        /// <param name="xCenter"></param>
        /// <param name="yCenter"></param>
        /// <param name="textRed"></param>
        /// <param name="textGreen"></param>
        /// <param name="textBlue"></param>
        /// <param name="cellWidth"></param>
        /// <param name="cellHeight"></param>
        /// <param name="cellRed"></param>
        /// <param name="cellGreen"></param>
        /// <param name="cellBlue"></param>
        /// <param name="captionDirection"></param>
        public void addTextCell2D(string text, int layer, double xCenter, double yCenter, byte textRed, byte textGreen, byte textBlue, double cellWidth, double cellHeight, byte cellRed = 255, byte cellGreen = 255, byte cellBlue = 255, PUPPIimageDirection captionDirection = PUPPIimageDirection.positiveXDirection)
        {
            //figure out size to fit in cell
            TextVisual3D tl = new TextVisual3D();
            tl.Text = text;
            tl.TextDirection = new Vector3D(1, 0, 0);
            tl.UpDirection = new Vector3D(0, 1, 0);
            tl.Height = 10;
            Rect3D mySize = tl.getBBRecursive();
            double scaleFactor = Math.Max(mySize.SizeY / cellHeight, mySize.SizeX / cellWidth);
            double textheight = 10 / scaleFactor;
            if (captionDirection == PUPPIimageDirection.positiveXDirection)
            {
                addRectangle2D(xCenter - cellWidth * 0.5, yCenter - cellHeight * 0.5, xCenter + cellWidth * 0.5, yCenter + cellHeight * 0.5, cellRed, cellGreen, cellBlue, layer);
                addBorder2D(xCenter - cellWidth * 0.5, yCenter - cellHeight * 0.5, xCenter + cellWidth * 0.5, yCenter + cellHeight * 0.5, 0, 0, 0, layer);
                addCaption2D(text, xCenter, yCenter, textheight, textRed, textGreen, textBlue, captionDirection, layer);
            }
            if (captionDirection == PUPPIimageDirection.negativeXDirection)
            {
                addRectangle2D(xCenter - cellWidth * 0.5, yCenter - cellHeight * 0.5, xCenter + cellWidth * 0.5, yCenter + cellHeight * 0.5, cellRed, cellGreen, cellBlue, layer);
                addBorder2D(xCenter - cellWidth * 0.5, yCenter - cellHeight * 0.5, xCenter + cellWidth * 0.5, yCenter + cellHeight * 0.5, 0, 0, 0, layer);
                addCaption2D(text, xCenter, yCenter, textheight, textRed, textGreen, textBlue, captionDirection, layer);

            }
            if (captionDirection == PUPPIimageDirection.positiveYDirection)
            {
                addRectangle2D(xCenter - cellHeight * 0.5, yCenter - cellWidth * 0.5, xCenter + cellHeight * 0.5, yCenter + cellWidth * 0.5, cellRed, cellGreen, cellBlue, layer);
                addBorder2D(xCenter - cellHeight * 0.5, yCenter - cellWidth * 0.5, xCenter + cellHeight * 0.5, yCenter + cellWidth * 0.5, cellRed, cellGreen, cellBlue, layer);
                addCaption2D(text, xCenter, yCenter, textheight, textRed, textGreen, textBlue, captionDirection, layer);
            }
            if (captionDirection == PUPPIimageDirection.negativeYDirection)
            {
                addRectangle2D(xCenter - cellHeight * 0.5, yCenter - cellWidth * 0.5, xCenter + cellHeight * 0.5, yCenter + cellWidth * 0.5, cellRed, cellGreen, cellBlue, layer);
                addBorder2D(xCenter - cellHeight * 0.5, yCenter - cellWidth * 0.5, xCenter + cellHeight * 0.5, yCenter + cellWidth * 0.5, cellRed, cellGreen, cellBlue, layer);
                addCaption2D(text, xCenter, yCenter, textheight, textRed, textGreen, textBlue, captionDirection, layer);

            }


        }
        /// <summary>
        /// Loads the custom renderer state from a saved state.
        /// </summary>
        /// <param name="savedRenderer">Saved state (XML)</param>
        public void loadCustomRendererStateFromXML(string savedRenderer)
        {
            int Box3Dcount = 0;
            int WireBox3Dcount = 0;
            int Rectangle2Dcount = 0;
            int RoundedRectangle2DCount = 0;
            int Sphere3Dcount = 0;
            int Circle2Dcount = 0;
            int Caption3Dcount = 0;
            int Caption2Dcount = 0;
            int Image3Dcount = 0;
            int Image2Dcount = 0;
            int Pipe3Dcount = 0;
            int FileVisual3Dcount = 0;
            int RoundedBox3DCount = 0;
            int Triangle2Dcount = 0;
            int Triangle3Dcount = 0;
            if (savedRenderer != "")
            {
                XmlDocument doc = new XmlDocument();
                try
                {
                    doc.LoadXml(savedRenderer);


                    XmlNode sasc = doc.SelectSingleNode("/savedRendererState");
                    for (int i = 0; i < sasc.ChildNodes.Count; i++)
                    {
                        XmlNode chi = sasc.ChildNodes[i];
                        if (chi.Name == "CustomBox3D")
                        {
                            byte al = 0;
                            byte re = 0;
                            byte gr = 0;
                            byte bl = 0;
                            double sx = 0;
                            double sy = 0;
                            double sz = 0;
                            double dx = 0;
                            double dy = 0;
                            double dz = 0;
                            string[] sep = { "_" };
                            string[] vs;
                            for (int j = 0; j < chi.ChildNodes.Count; j++)
                            {
                                XmlNode chichi = chi.ChildNodes[j];
                                if (chichi.Name == "ColorARGB")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    al = Convert.ToByte(vs[0]);
                                    re = Convert.ToByte(vs[1]);
                                    gr = Convert.ToByte(vs[2]);
                                    bl = Convert.ToByte(vs[3]);
                                }
                                if (chichi.Name == "StartPosition")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    sx = Convert.ToDouble(vs[0]);
                                    sy = Convert.ToDouble(vs[1]);
                                    sz = Convert.ToDouble(vs[2]);

                                }
                                if (chichi.Name == "Diagonal")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    dx = Convert.ToDouble(vs[0]);
                                    dy = Convert.ToDouble(vs[1]);
                                    dz = Convert.ToDouble(vs[2]);

                                }

                            }
                            if (Box3Dcount < boxes3D.Count)
                            {
                                updateBox3D(Box3Dcount, sx, sy, sz, sx + dx, sy + dy, sz + dz, re, gr, bl);

                            }
                            Box3Dcount++;
                        }


                        if (chi.Name == "RoundedCustomBox3D")
                        {
                            byte al = 0;
                            byte re = 0;
                            byte gr = 0;
                            byte bl = 0;
                            double sx = 0;
                            double sy = 0;
                            double sz = 0;
                            double dx = 0;
                            double dy = 0;
                            double dz = 0;
                            double cr = 0;
                            string[] sep = { "_" };
                            string[] vs;
                            for (int j = 0; j < chi.ChildNodes.Count; j++)
                            {
                                XmlNode chichi = chi.ChildNodes[j];
                                if (chichi.Name == "ColorARGB")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    al = Convert.ToByte(vs[0]);
                                    re = Convert.ToByte(vs[1]);
                                    gr = Convert.ToByte(vs[2]);
                                    bl = Convert.ToByte(vs[3]);
                                }
                                if (chichi.Name == "StartPosition")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    sx = Convert.ToDouble(vs[0]);
                                    sy = Convert.ToDouble(vs[1]);
                                    sz = Convert.ToDouble(vs[2]);

                                }
                                if (chichi.Name == "Diagonal")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    dx = Convert.ToDouble(vs[0]);
                                    dy = Convert.ToDouble(vs[1]);
                                    dz = Convert.ToDouble(vs[2]);

                                }
                                if (chichi.Name == "CornerRadius")
                                {

                                    cr = Convert.ToDouble(chichi.InnerText);

                                }
                            }
                            if (RoundedBox3DCount < roundedboxes3D.Count)
                            {
                                updateRoundedBox3D(RoundedBox3DCount, sx, sy, sz, sx + dx, sy + dy, sz + dz, cr, re, gr, bl);

                            }
                            RoundedBox3DCount++;
                        }


                        if (chi.Name == "WireCustomBox3D")
                        {
                            byte al = 0;
                            byte re = 0;
                            byte gr = 0;
                            byte bl = 0;
                            double sx = 0;
                            double sy = 0;
                            double sz = 0;
                            double dx = 0;
                            double dy = 0;
                            double dz = 0;
                            string[] sep = { "_" };
                            string[] vs;
                            for (int j = 0; j < chi.ChildNodes.Count; j++)
                            {
                                XmlNode chichi = chi.ChildNodes[j];
                                if (chichi.Name == "ColorARGB")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    al = Convert.ToByte(vs[0]);
                                    re = Convert.ToByte(vs[1]);
                                    gr = Convert.ToByte(vs[2]);
                                    bl = Convert.ToByte(vs[3]);
                                }
                                if (chichi.Name == "StartPosition")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    sx = Convert.ToDouble(vs[0]);
                                    sy = Convert.ToDouble(vs[1]);
                                    sz = Convert.ToDouble(vs[2]);

                                }
                                if (chichi.Name == "Diagonal")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    dx = Convert.ToDouble(vs[0]);
                                    dy = Convert.ToDouble(vs[1]);
                                    dz = Convert.ToDouble(vs[2]);

                                }

                            }
                            if (WireBox3Dcount < wireBoxes3D.Count)
                            {
                                updateWireBox3D(WireBox3Dcount, sx, sy, sz, sx + dx, sy + dy, sz + dz, re, gr, bl);

                            }
                            Box3Dcount++;
                        }


                        if (chi.Name == "CustomRectangle2D")
                        {
                            byte al = 0;
                            byte re = 0;
                            byte gr = 0;
                            byte bl = 0;
                            double sx = 0;
                            double sy = 0;
                            double dx = 0;
                            double dy = 0;
                            int layer = 0;
                            string[] sep = { "_" };
                            string[] vs;
                            for (int j = 0; j < chi.ChildNodes.Count; j++)
                            {
                                XmlNode chichi = chi.ChildNodes[j];
                                if (chichi.Name == "ColorARGB")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    al = Convert.ToByte(vs[0]);
                                    re = Convert.ToByte(vs[1]);
                                    gr = Convert.ToByte(vs[2]);
                                    bl = Convert.ToByte(vs[3]);
                                }
                                if (chichi.Name == "StartPosition")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    sx = Convert.ToDouble(vs[0]);
                                    sy = Convert.ToDouble(vs[1]);


                                }
                                if (chichi.Name == "Diagonal")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    dx = Convert.ToDouble(vs[0]);
                                    dy = Convert.ToDouble(vs[1]);


                                }
                                if (chichi.Name == "Layer")
                                {

                                    layer = Convert.ToInt16(chichi.InnerText);

                                }

                            }
                            if (Rectangle2Dcount < rectangles2D.Count)
                            {
                                updateRectangle2D(Rectangle2Dcount, sx, sy, sx + dx, sy + dy, re, gr, bl, layer);

                            }
                            Rectangle2Dcount++;
                        }


                        if (chi.Name == "CustomTriangle2D")
                        {
                            byte al = 0;
                            byte re = 0;
                            byte gr = 0;
                            byte bl = 0;
                            double p1x = 0;
                            double p1y = 0;
                            double p2x = 0;
                            double p2y = 0;
                            double p3x = 0;
                            double p3y = 0;
                            int layer = 0;
                            string[] sep = { "_" };
                            string[] vs;
                            for (int j = 0; j < chi.ChildNodes.Count; j++)
                            {
                                XmlNode chichi = chi.ChildNodes[j];
                                if (chichi.Name == "ColorARGB")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    al = Convert.ToByte(vs[0]);
                                    re = Convert.ToByte(vs[1]);
                                    gr = Convert.ToByte(vs[2]);
                                    bl = Convert.ToByte(vs[3]);
                                }
                                if (chichi.Name == "P1")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    p1x = Convert.ToDouble(vs[0]);
                                    p1y = Convert.ToDouble(vs[1]);


                                }
                                if (chichi.Name == "P2")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    p2x = Convert.ToDouble(vs[0]);
                                    p2y = Convert.ToDouble(vs[1]);


                                }
                                if (chichi.Name == "P3")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    p3x = Convert.ToDouble(vs[0]);
                                    p3y = Convert.ToDouble(vs[1]);


                                }
                                if (chichi.Name == "Layer")
                                {

                                    layer = Convert.ToInt16(chichi.InnerText);

                                }

                            }
                            if (Triangle2Dcount < triangles2D.Count)
                            {
                                updateTriangle2D(Triangle2Dcount, p1x, p1y, p2x, p2y, p3x, p3y, re, gr, bl, layer);

                            }
                            Triangle2Dcount++;
                        }



                        if (chi.Name == "CustomTriangle2D")
                        {
                            byte al = 0;
                            byte re = 0;
                            byte gr = 0;
                            byte bl = 0;
                            double p1x = 0;
                            double p1y = 0;
                            double p2x = 0;
                            double p2y = 0;
                            double p3x = 0;
                            double p3y = 0;
                            int layer = 0;
                            string[] sep = { "_" };
                            string[] vs;
                            for (int j = 0; j < chi.ChildNodes.Count; j++)
                            {
                                XmlNode chichi = chi.ChildNodes[j];
                                if (chichi.Name == "ColorARGB")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    al = Convert.ToByte(vs[0]);
                                    re = Convert.ToByte(vs[1]);
                                    gr = Convert.ToByte(vs[2]);
                                    bl = Convert.ToByte(vs[3]);
                                }
                                if (chichi.Name == "P1")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    p1x = Convert.ToDouble(vs[0]);
                                    p1y = Convert.ToDouble(vs[1]);


                                }
                                if (chichi.Name == "P2")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    p2x = Convert.ToDouble(vs[0]);
                                    p2y = Convert.ToDouble(vs[1]);


                                }
                                if (chichi.Name == "P3")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    p3x = Convert.ToDouble(vs[0]);
                                    p3y = Convert.ToDouble(vs[1]);


                                }
                                if (chichi.Name == "Layer")
                                {

                                    layer = Convert.ToInt16(chichi.InnerText);

                                }

                            }
                            if (Triangle2Dcount < triangles2D.Count)
                            {
                                updateTriangle2D(Triangle2Dcount, p1x, p1y, p2x, p2y, p3x, p3y, re, gr, bl, layer);

                            }
                            Triangle2Dcount++;
                        }


                        if (chi.Name == "CustomTriangle3D")
                        {
                            byte al = 0;
                            byte re = 0;
                            byte gr = 0;
                            byte bl = 0;
                            double p1x = 0;
                            double p1y = 0;
                            double p1z = 0;
                            double p2x = 0;
                            double p2y = 0;
                            double p2z = 0;
                            double p3x = 0;
                            double p3y = 0;
                            double p3z = 0;
                            int layer = 0;
                            string[] sep = { "_" };
                            string[] vs;
                            for (int j = 0; j < chi.ChildNodes.Count; j++)
                            {
                                XmlNode chichi = chi.ChildNodes[j];
                                if (chichi.Name == "ColorARGB")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    al = Convert.ToByte(vs[0]);
                                    re = Convert.ToByte(vs[1]);
                                    gr = Convert.ToByte(vs[2]);
                                    bl = Convert.ToByte(vs[3]);
                                }
                                if (chichi.Name == "P1")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    p1x = Convert.ToDouble(vs[0]);
                                    p1y = Convert.ToDouble(vs[1]);
                                    p1z = Convert.ToDouble(vs[2]);


                                }
                                if (chichi.Name == "P2")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    p2x = Convert.ToDouble(vs[0]);
                                    p2y = Convert.ToDouble(vs[1]);
                                    p2z = Convert.ToDouble(vs[2]);


                                }
                                if (chichi.Name == "P3")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    p3x = Convert.ToDouble(vs[0]);
                                    p3y = Convert.ToDouble(vs[1]);
                                    p3z = Convert.ToDouble(vs[2]);


                                }


                            }
                            if (Triangle3Dcount < triangles3D.Count)
                            {
                                updateTriangle3D(Triangle3Dcount, p1x, p1y, p1z, p2x, p2y, p2z, p3x, p3y, p3z, re, gr, bl);

                            }
                            Triangle3Dcount++;
                        }


                        if (chi.Name == "CustomRoundedRectangle2D")
                        {
                            byte al = 0;
                            byte re = 0;
                            byte gr = 0;
                            byte bl = 0;
                            double sx = 0;
                            double sy = 0;
                            double dx = 0;
                            double dy = 0;
                            double ncr = 0;
                            int layer = 0;
                            string[] sep = { "_" };
                            string[] vs;
                            for (int j = 0; j < chi.ChildNodes.Count; j++)
                            {
                                XmlNode chichi = chi.ChildNodes[j];
                                if (chichi.Name == "ColorARGB")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    al = Convert.ToByte(vs[0]);
                                    re = Convert.ToByte(vs[1]);
                                    gr = Convert.ToByte(vs[2]);
                                    bl = Convert.ToByte(vs[3]);
                                }
                                if (chichi.Name == "StartPosition")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    sx = Convert.ToDouble(vs[0]);
                                    sy = Convert.ToDouble(vs[1]);


                                }
                                if (chichi.Name == "Diagonal")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    dx = Convert.ToDouble(vs[0]);
                                    dy = Convert.ToDouble(vs[1]);


                                }
                                if (chichi.Name == "CornerRadius")
                                {

                                    ncr = Convert.ToDouble(chichi.InnerText);

                                }
                                if (chichi.Name == "Layer")
                                {

                                    layer = Convert.ToInt16(chichi.InnerText);

                                }

                            }
                            if (RoundedRectangle2DCount < roundedrectangles2D.Count)
                            {
                                updateRoundedRectangle2D(RoundedRectangle2DCount, sx, sy, sx + dx, sy + dy, ncr, re, gr, bl, layer);

                            }
                            RoundedRectangle2DCount++;
                        }


                        if (chi.Name == "CustomSphere3D")
                        {
                            byte al = 0;
                            byte re = 0;
                            byte gr = 0;
                            byte bl = 0;
                            double sx = 0;
                            double sy = 0;
                            double sz = 0;
                            double radius = 0;
                            string[] sep = { "_" };
                            string[] vs;
                            for (int j = 0; j < chi.ChildNodes.Count; j++)
                            {
                                XmlNode chichi = chi.ChildNodes[j];
                                if (chichi.Name == "ColorARGB")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    al = Convert.ToByte(vs[0]);
                                    re = Convert.ToByte(vs[1]);
                                    gr = Convert.ToByte(vs[2]);
                                    bl = Convert.ToByte(vs[3]);
                                }
                                if (chichi.Name == "Center")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    sx = Convert.ToDouble(vs[0]);
                                    sy = Convert.ToDouble(vs[1]);
                                    sz = Convert.ToDouble(vs[2]);

                                }
                                if (chichi.Name == "Radius")
                                {

                                    radius = Convert.ToDouble(chichi.InnerText);


                                }

                            }
                            if (Sphere3Dcount < spheres3D.Count)
                            {
                                updateSphere3D(Sphere3Dcount, sx, sy, sz, radius, re, gr, bl);

                            }
                            Sphere3Dcount++;
                        }


                        if (chi.Name == "CustomCircle2D")
                        {
                            byte al = 0;
                            byte re = 0;
                            byte gr = 0;
                            byte bl = 0;
                            double sx = 0;
                            double sy = 0;

                            double radius = 0;
                            string[] sep = { "_" };
                            string[] vs;
                            int layer = 0;
                            for (int j = 0; j < chi.ChildNodes.Count; j++)
                            {
                                XmlNode chichi = chi.ChildNodes[j];
                                if (chichi.Name == "ColorARGB")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    al = Convert.ToByte(vs[0]);
                                    re = Convert.ToByte(vs[1]);
                                    gr = Convert.ToByte(vs[2]);
                                    bl = Convert.ToByte(vs[3]);
                                }
                                if (chichi.Name == "Center")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    sx = Convert.ToDouble(vs[0]);
                                    sy = Convert.ToDouble(vs[1]);


                                }
                                if (chichi.Name == "Radius")
                                {

                                    radius = Convert.ToDouble(chichi.InnerText);
                                }
                                if (chichi.Name == "Layer")
                                {

                                    layer = Convert.ToInt16(chichi.InnerText);

                                }

                            }
                            if (Circle2Dcount < circles2D.Count)
                            {
                                updateCircle2D(Circle2Dcount, sx, sy, radius, re, gr, bl, layer);

                            }
                            Circle2Dcount++;
                        }

                        if (chi.Name == "CustomCaption3D")
                        {
                            byte al = 0;
                            byte re = 0;
                            byte gr = 0;
                            byte bl = 0;
                            double sx = 0;
                            double sy = 0;
                            double sz = 0;
                            string text = "";
                            double textHeight = 0;
                            PUPPICustomRenderer.PUPPIimageDirection dir = 0;
                            PUPPICustomRenderer.PUPPIimageOrientation orient = 0;


                            string[] sep = { "_" };
                            string[] vs;
                            for (int j = 0; j < chi.ChildNodes.Count; j++)
                            {
                                XmlNode chichi = chi.ChildNodes[j];
                                if (chichi.Name == "ColorARGB")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    al = Convert.ToByte(vs[0]);
                                    re = Convert.ToByte(vs[1]);
                                    gr = Convert.ToByte(vs[2]);
                                    bl = Convert.ToByte(vs[3]);
                                }
                                if (chichi.Name == "Position")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    sx = Convert.ToDouble(vs[0]);
                                    sy = Convert.ToDouble(vs[1]);
                                    sz = Convert.ToDouble(vs[2]);

                                }
                                if (chichi.Name == "Direction")
                                {

                                    dir = (PUPPIimageDirection)Enum.Parse(typeof(PUPPIimageDirection), chichi.InnerText);

                                }
                                if (chichi.Name == "Orientation")
                                {

                                    orient = (PUPPIimageOrientation)Enum.Parse(typeof(PUPPIimageOrientation), chichi.InnerText);

                                }
                                if (chichi.Name == "Text")
                                {

                                    text = chichi.InnerText;

                                }
                                if (chichi.Name == "TextHeight")
                                {

                                    textHeight = Convert.ToDouble(chichi.InnerText);

                                }


                            }
                            if (Caption3Dcount < captions3D.Count)
                            {
                                updateCaption3D(Caption3Dcount, text, sx, sy, sz, textHeight, re, gr, bl, dir, orient);

                            }
                            Caption3Dcount++;
                        }
                        if (chi.Name == "CustomCaption2D")
                        {
                            byte al = 0;
                            byte re = 0;
                            byte gr = 0;
                            byte bl = 0;
                            double sx = 0;
                            double sy = 0;
                            string text = "";
                            double textHeight = 0;

                            PUPPICustomRenderer.PUPPIimageDirection dir = 0;
                            int layer = 0;

                            string[] sep = { "_" };
                            string[] vs;
                            for (int j = 0; j < chi.ChildNodes.Count; j++)
                            {
                                XmlNode chichi = chi.ChildNodes[j];
                                if (chichi.Name == "ColorARGB")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    al = Convert.ToByte(vs[0]);
                                    re = Convert.ToByte(vs[1]);
                                    gr = Convert.ToByte(vs[2]);
                                    bl = Convert.ToByte(vs[3]);
                                }
                                if (chichi.Name == "Position")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    sx = Convert.ToDouble(vs[0]);
                                    sy = Convert.ToDouble(vs[1]);


                                }

                                if (chichi.Name == "Direction")
                                {

                                    dir = (PUPPIimageDirection)Enum.Parse(typeof(PUPPIimageDirection), chichi.InnerText);

                                }
                                if (chichi.Name == "Text")
                                {

                                    text = chichi.InnerText;

                                }
                                if (chichi.Name == "TextHeight")
                                {

                                    textHeight = Convert.ToDouble(chichi.InnerText);

                                }
                                if (chichi.Name == "Layer")
                                {

                                    layer = Convert.ToInt16(chichi.InnerText);

                                }

                            }
                            if (Caption2Dcount < captions2D.Count)
                            {
                                updateCaption2D(Caption2Dcount, text, sx, sy, textHeight, re, gr, bl, dir, layer);

                            }
                            Caption2Dcount++;
                        }



                        if (chi.Name == "CustomImage3D")
                        {
                            byte al = 0;
                            byte re = 0;
                            byte gr = 0;
                            byte bl = 0;
                            double sx = 0;
                            double sy = 0;
                            double sz = 0;

                            double iHeight = 0;
                            double iWidth = 0;
                            PUPPICustomRenderer.PUPPIimageDirection dir = 0;
                            PUPPICustomRenderer.PUPPIimageOrientation orient = 0;
                            string filePath = "";

                            string[] sep = { "_" };
                            string[] vs;
                            for (int j = 0; j < chi.ChildNodes.Count; j++)
                            {
                                XmlNode chichi = chi.ChildNodes[j];
                                if (chichi.Name == "ColorARGB")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    al = Convert.ToByte(vs[0]);
                                    re = Convert.ToByte(vs[1]);
                                    gr = Convert.ToByte(vs[2]);
                                    bl = Convert.ToByte(vs[3]);
                                }
                                if (chichi.Name == "Position")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    sx = Convert.ToDouble(vs[0]);
                                    sy = Convert.ToDouble(vs[1]);
                                    sz = Convert.ToDouble(vs[2]);

                                }
                                if (chichi.Name == "Direction")
                                {

                                    dir = (PUPPIimageDirection)Enum.Parse(typeof(PUPPIimageDirection), chichi.InnerText);

                                }
                                if (chichi.Name == "Orientation")
                                {

                                    orient = (PUPPIimageOrientation)Enum.Parse(typeof(PUPPIimageOrientation), chichi.InnerText);

                                }

                                if (chichi.Name == "Height")
                                {

                                    iHeight = Convert.ToDouble(chichi.InnerText);

                                }
                                if (chichi.Name == "Width")
                                {

                                    iWidth = Convert.ToDouble(chichi.InnerText);

                                }

                                if (chichi.Name == "FilePath")
                                {

                                    filePath = chichi.InnerText;

                                }


                            }
                            if (Image3Dcount < images3D.Count)
                            {
                                updateImage3D(Image3Dcount, filePath, sx, sy, sz, iHeight, iWidth, dir, orient);

                            }
                            Image3Dcount++;
                        }
                        if (chi.Name == "CustomImage2D")
                        {
                            byte al = 0;
                            byte re = 0;
                            byte gr = 0;
                            byte bl = 0;
                            double sx = 0;
                            double sy = 0;
                            double iHeight = 0;
                            double iWidth = 0;
                            string filePath = "";

                            PUPPICustomRenderer.PUPPIimageDirection dir = 0;
                            int layer = 0;

                            string[] sep = { "_" };
                            string[] vs;
                            for (int j = 0; j < chi.ChildNodes.Count; j++)
                            {
                                XmlNode chichi = chi.ChildNodes[j];
                                if (chichi.Name == "ColorARGB")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    al = Convert.ToByte(vs[0]);
                                    re = Convert.ToByte(vs[1]);
                                    gr = Convert.ToByte(vs[2]);
                                    bl = Convert.ToByte(vs[3]);
                                }
                                if (chichi.Name == "Position")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    sx = Convert.ToDouble(vs[0]);
                                    sy = Convert.ToDouble(vs[1]);


                                }

                                if (chichi.Name == "Orientation")
                                {

                                    dir = (PUPPIimageDirection)Enum.Parse(typeof(PUPPIimageDirection), chichi.InnerText);

                                }
                                if (chichi.Name == "FilePath")
                                {

                                    filePath = chichi.InnerText;

                                }
                                if (chichi.Name == "Height")
                                {

                                    iHeight = Convert.ToDouble(chichi.InnerText);

                                }
                                if (chichi.Name == "Width")
                                {

                                    iWidth = Convert.ToDouble(chichi.InnerText);

                                }
                                if (chichi.Name == "Layer")
                                {

                                    layer = Convert.ToInt16(chichi.InnerText);

                                }

                            }
                            if (Image2Dcount < images2D.Count)
                            {
                                updateImage2D(Image2Dcount, filePath, sx, sy, iWidth, iHeight, dir, layer);

                            }
                            Image2Dcount++;
                        }

                        if (chi.Name == "CustomPipe3D")
                        {
                            byte al = 0;
                            byte re = 0;
                            byte gr = 0;
                            byte bl = 0;
                            double sx = 0;
                            double sy = 0;
                            double sz = 0;
                            double ex = 0;
                            double ey = 0;
                            double ez = 0;
                            double diam = 0;
                            string[] sep = { "_" };
                            string[] vs;
                            for (int j = 0; j < chi.ChildNodes.Count; j++)
                            {
                                XmlNode chichi = chi.ChildNodes[j];
                                if (chichi.Name == "ColorARGB")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    al = Convert.ToByte(vs[0]);
                                    re = Convert.ToByte(vs[1]);
                                    gr = Convert.ToByte(vs[2]);
                                    bl = Convert.ToByte(vs[3]);
                                }
                                if (chichi.Name == "StartPoint")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    sx = Convert.ToDouble(vs[0]);
                                    sy = Convert.ToDouble(vs[1]);
                                    sz = Convert.ToDouble(vs[2]);

                                }
                                if (chichi.Name == "EndPoint")
                                {
                                    vs = chichi.InnerText.Split(sep, StringSplitOptions.None);
                                    ex = Convert.ToDouble(vs[0]);
                                    ey = Convert.ToDouble(vs[1]);
                                    ez = Convert.ToDouble(vs[2]);

                                }
                                if (chichi.Name == "Diameter")
                                {

                                    diam = Convert.ToDouble(chichi.InnerText);

                                }


                            }
                            if (Pipe3Dcount < pipes3D.Count)
                            {
                                updatePipe3D(Pipe3Dcount, sx, sy, sz, ex, ey, ez, diam, re, gr, bl);

                            }
                            Pipe3Dcount++;
                        }
                        if (chi.Name == "FileModelVisual3D")
                        {
                            string fs = "";
                            for (int j = 0; j < chi.ChildNodes.Count; j++)
                            {
                                XmlNode chichi = chi.ChildNodes[j];
                                if (chichi.Name == "Source")
                                {

                                    fs = chichi.InnerText;

                                }
                            }
                            if (FileVisual3Dcount < fileVisuals3D.Count)
                            {
                                updateFile3D(FileVisual3Dcount, fs);

                            }
                            FileVisual3Dcount++;
                        }


                    }

                }
                catch (Exception exy)
                {

                    throw new Exception("Invalid renderer data: " + exy.ToString());

                }
            }
            needsRender = true;
        }

        /// <summary>
        /// Saves the custom renderer state to a string containing XML code.
        /// </summary>
        /// <returns>XML string</returns>
        public string saveCustomRendererStateToXML()
        {
            XmlDocument doc = new XmlDocument();
            XmlNode mn = doc.CreateNode(XmlNodeType.Element, "savedRendererState", "");
            XmlNode n;

            foreach (CustomBox3D cb3 in boxes3D)
            {
                CustomBox3D c = cb3;
                n = doc.CreateNode(XmlNodeType.Element, "CustomBox3D", "");
                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "ColorARGB", "");
                dispeleme.InnerText = c.myBoxColor.A.ToString() + "_" + c.myBoxColor.R.ToString() + "_" + c.myBoxColor.G.ToString() + "_" + c.myBoxColor.B.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "StartPosition", "");
                dispeleme.InnerText = c.myBoxStartPosition.X.ToString() + "_" + c.myBoxStartPosition.Y.ToString() + "_" + c.myBoxStartPosition.Z.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "Diagonal", "");
                dispeleme.InnerText = c.myBoxDiagonal.X.ToString() + "_" + c.myBoxDiagonal.Y.ToString() + "_" + c.myBoxDiagonal.Z.ToString();
                n.AppendChild(dispeleme);
                mn.AppendChild(n);
            }

            foreach (CustomRoundedBox3D cb3 in roundedboxes3D)
            {
                CustomRoundedBox3D c = cb3;
                n = doc.CreateNode(XmlNodeType.Element, "CustomRoundedBox3D", "");
                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "ColorARGB", "");
                dispeleme.InnerText = c.myBoxColor.A.ToString() + "_" + c.myBoxColor.R.ToString() + "_" + c.myBoxColor.G.ToString() + "_" + c.myBoxColor.B.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "StartPosition", "");
                dispeleme.InnerText = c.myBoxStartPosition.X.ToString() + "_" + c.myBoxStartPosition.Y.ToString() + "_" + c.myBoxStartPosition.Z.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "Diagonal", "");
                dispeleme.InnerText = c.myBoxDiagonal.X.ToString() + "_" + c.myBoxDiagonal.Y.ToString() + "_" + c.myBoxDiagonal.Z.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "CornerRadius", "");
                dispeleme.InnerText = c.myBoxCornerRadius.ToString();
                n.AppendChild(dispeleme);


                mn.AppendChild(n);
            }

            foreach (WireCustomBox3D cb3 in wireBoxes3D)
            {
                WireCustomBox3D c = cb3;
                n = doc.CreateNode(XmlNodeType.Element, "WireCustomBox3D", "");
                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "ColorARGB", "");
                dispeleme.InnerText = c.myBoxColor.A.ToString() + "_" + c.myBoxColor.R.ToString() + "_" + c.myBoxColor.G.ToString() + "_" + c.myBoxColor.B.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "StartPosition", "");
                dispeleme.InnerText = c.myBoxStartPosition.X.ToString() + "_" + c.myBoxStartPosition.Y.ToString() + "_" + c.myBoxStartPosition.Z.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "Diagonal", "");
                dispeleme.InnerText = c.myBoxDiagonal.X.ToString() + "_" + c.myBoxDiagonal.Y.ToString() + "_" + c.myBoxDiagonal.Z.ToString();
                n.AppendChild(dispeleme);
                mn.AppendChild(n);
            }


            foreach (CustomRectangle2D cb3 in rectangles2D)
            {
                CustomRectangle2D c = cb3;
                n = doc.CreateNode(XmlNodeType.Element, "CustomRectangle2D", "");
                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "ColorARGB", "");
                dispeleme.InnerText = c.myRectColor.A.ToString() + "_" + c.myRectColor.R.ToString() + "_" + c.myRectColor.G.ToString() + "_" + c.myRectColor.B.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "StartPosition", "");
                dispeleme.InnerText = c.myRectStartPosition.X.ToString() + "_" + c.myRectStartPosition.Y.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "Diagonal", "");
                dispeleme.InnerText = c.myRectDiagonal.X.ToString() + "_" + c.myRectDiagonal.Y.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "Layer", "");
                dispeleme.InnerText = c.layer.ToString();
                n.AppendChild(dispeleme);

                mn.AppendChild(n);

            }


            foreach (CustomTriangle2D cb3 in triangles2D)
            {
                CustomTriangle2D c = cb3;
                n = doc.CreateNode(XmlNodeType.Element, "CustomTriangle2D", "");
                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "ColorARGB", "");
                dispeleme.InnerText = c.myTriangleColor.A.ToString() + "_" + c.myTriangleColor.R.ToString() + "_" + c.myTriangleColor.G.ToString() + "_" + c.myTriangleColor.B.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "P1", "");
                dispeleme.InnerText = c.p1.X.ToString() + "_" + c.p1.Y.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "P2", "");
                dispeleme.InnerText = c.p2.X.ToString() + "_" + c.p2.Y.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "P3", "");
                dispeleme.InnerText = c.p3.X.ToString() + "_" + c.p3.Y.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "Layer", "");
                dispeleme.InnerText = c.layer.ToString();
                n.AppendChild(dispeleme);

                mn.AppendChild(n);

            }


            foreach (CustomTriangle3D cb3 in triangles3D)
            {
                CustomTriangle3D c = cb3;
                n = doc.CreateNode(XmlNodeType.Element, "CustomTriangle3D", "");
                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "ColorARGB", "");
                dispeleme.InnerText = c.myTriangleColor.A.ToString() + "_" + c.myTriangleColor.R.ToString() + "_" + c.myTriangleColor.G.ToString() + "_" + c.myTriangleColor.B.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "P1", "");
                dispeleme.InnerText = c.p1.X.ToString() + "_" + c.p1.Y.ToString() + "_" + c.p1.Z.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "P2", "");
                dispeleme.InnerText = c.p2.X.ToString() + "_" + c.p2.Y.ToString() + "_" + c.p2.Z.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "P3", "");
                dispeleme.InnerText = c.p3.X.ToString() + "_" + c.p3.Y.ToString() + "_" + c.p3.Z.ToString();
                n.AppendChild(dispeleme);


                mn.AppendChild(n);

            }


            foreach (CustomRoundedRectangle2D cb3 in roundedrectangles2D)
            {
                CustomRoundedRectangle2D c = cb3;
                n = doc.CreateNode(XmlNodeType.Element, "CustomRoundedRectangle2D", "");
                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "ColorARGB", "");
                dispeleme.InnerText = c.myRectColor.A.ToString() + "_" + c.myRectColor.R.ToString() + "_" + c.myRectColor.G.ToString() + "_" + c.myRectColor.B.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "StartPosition", "");
                dispeleme.InnerText = c.myRectStartPosition.X.ToString() + "_" + c.myRectStartPosition.Y.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "Diagonal", "");
                dispeleme.InnerText = c.myRectDiagonal.X.ToString() + "_" + c.myRectDiagonal.Y.ToString();
                n.AppendChild(dispeleme);
                dispeleme = doc.CreateNode(XmlNodeType.Element, "CornerRadius", "");
                dispeleme.InnerText = c.myCornerRadius.ToString();
                n.AppendChild(dispeleme);


                dispeleme = doc.CreateNode(XmlNodeType.Element, "Layer", "");
                dispeleme.InnerText = c.layer.ToString();
                n.AppendChild(dispeleme);

                mn.AppendChild(n);

            }

            foreach (CustomCaption3D cb3 in captions3D)
            {
                CustomCaption3D c = cb3;
                n = doc.CreateNode(XmlNodeType.Element, "CustomCaption3D", "");
                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "ColorARGB", "");
                dispeleme.InnerText = c.myCaptionColor.A.ToString() + "_" + c.myCaptionColor.R.ToString() + "_" + c.myCaptionColor.G.ToString() + "_" + c.myCaptionColor.B.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "Position", "");
                dispeleme.InnerText = c.myCaptionPosition.X.ToString() + "_" + c.myCaptionPosition.Y.ToString() + "_" + c.myCaptionPosition.Z.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "Direction", "");
                dispeleme.InnerText = c.myCaptionDir.ToString();
                n.AppendChild(dispeleme);


                dispeleme = doc.CreateNode(XmlNodeType.Element, "Orientation", "");
                dispeleme.InnerText = c.myCaptionOrient.ToString();
                n.AppendChild(dispeleme);


                dispeleme = doc.CreateNode(XmlNodeType.Element, "Text", "");
                dispeleme.InnerText = c.myCaptionText;
                n.AppendChild(dispeleme);


                dispeleme = doc.CreateNode(XmlNodeType.Element, "TextHeight", "");
                dispeleme.InnerText = c.myCaptionTextHeight.ToString();
                n.AppendChild(dispeleme);

                mn.AppendChild(n);

            }
            foreach (CustomCaption2D cb3 in captions2D)
            {
                CustomCaption2D c = cb3;
                n = doc.CreateNode(XmlNodeType.Element, "CustomCaption2D", "");
                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "ColorARGB", "");
                dispeleme.InnerText = c.myCaptionColor.A.ToString() + "_" + c.myCaptionColor.R.ToString() + "_" + c.myCaptionColor.G.ToString() + "_" + c.myCaptionColor.B.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "Position", "");
                dispeleme.InnerText = c.myCaptionPosition.X.ToString() + "_" + c.myCaptionPosition.Y.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "Direction", "");
                dispeleme.InnerText = c.myCaptionDir.ToString();
                n.AppendChild(dispeleme);


                dispeleme = doc.CreateNode(XmlNodeType.Element, "Text", "");
                dispeleme.InnerText = c.myCaptionText;
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "TextHeight", "");
                dispeleme.InnerText = c.myCaptionTextHeight.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "Layer", "");
                dispeleme.InnerText = c.layer.ToString();
                n.AppendChild(dispeleme);

                mn.AppendChild(n);
            }
            foreach (CustomSphere3D cb3 in spheres3D)
            {
                CustomSphere3D c = cb3;

                n = doc.CreateNode(XmlNodeType.Element, "CustomSphere3D", "");
                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "ColorARGB", "");
                dispeleme.InnerText = c.mySphereColor.A.ToString() + "_" + c.mySphereColor.R.ToString() + "_" + c.mySphereColor.G.ToString() + "_" + c.mySphereColor.B.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "Center", "");
                dispeleme.InnerText = c.mySphereCenter.X.ToString() + "_" + c.mySphereCenter.Y.ToString() + "_" + c.mySphereCenter.Z.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "Radius", "");
                dispeleme.InnerText = c.mySphereRadius.ToString();
                n.AppendChild(dispeleme);

                mn.AppendChild(n);
            }
            foreach (CustomCircle2D cb3 in circles2D)
            {
                CustomCircle2D c = cb3;
                n = doc.CreateNode(XmlNodeType.Element, "CustomCircle2D", "");
                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "ColorARGB", "");
                dispeleme.InnerText = c.myCircleColor.A.ToString() + "_" + c.myCircleColor.R.ToString() + "_" + c.myCircleColor.G.ToString() + "_" + c.myCircleColor.B.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "Center", "");
                dispeleme.InnerText = c.myCircleCenter.X.ToString() + "_" + c.myCircleCenter.Y.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "Radius", "");
                dispeleme.InnerText = c.myCircleRadius.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "Layer", "");
                dispeleme.InnerText = c.layer.ToString();
                n.AppendChild(dispeleme);

                mn.AppendChild(n);
            }
            foreach (CustomPipe3D cb3 in pipes3D)
            {
                CustomPipe3D c = cb3;


                n = doc.CreateNode(XmlNodeType.Element, "CustomPipe3D", "");
                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "ColorARGB", "");
                dispeleme.InnerText = c.myPipeColor.A.ToString() + "_" + c.myPipeColor.R.ToString() + "_" + c.myPipeColor.G.ToString() + "_" + c.myPipeColor.B.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "StartPoint", "");
                dispeleme.InnerText = c.myPipeStartPoint.X.ToString() + "_" + c.myPipeStartPoint.Y.ToString() + "_" + c.myPipeStartPoint.Z.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "EndPoint", "");
                dispeleme.InnerText = c.myPipeEndPoint.X.ToString() + "_" + c.myPipeEndPoint.Y.ToString() + "_" + c.myPipeEndPoint.Z.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "Diameter", "");
                dispeleme.InnerText = c.myPipeDiameter.ToString();
                n.AppendChild(dispeleme);

                mn.AppendChild(n);

            }
            foreach (FileModelVisual3D cb3 in fileVisuals3D)
            {
                FileModelVisual3D c = new FileModelVisual3D();
                n = doc.CreateNode(XmlNodeType.Element, "FileModelVisual3D", "");
                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "Source", "");
                dispeleme.InnerText = c.Source;
                n.AppendChild(dispeleme);

            }
            foreach (CustomImage3D cb3 in images3D)
            {
                CustomImage3D c = cb3;


                n = doc.CreateNode(XmlNodeType.Element, "CustomImage3D", "");


                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "Position", "");
                dispeleme.InnerText = c.myImagePosition.X.ToString() + "_" + c.myImagePosition.Y.ToString() + "_" + c.myImagePosition.Z.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "Direction", "");
                dispeleme.InnerText = c.myImageDirection.ToString();
                n.AppendChild(dispeleme);


                dispeleme = doc.CreateNode(XmlNodeType.Element, "Orientation", "");
                dispeleme.InnerText = c.myImageOrient.ToString();
                n.AppendChild(dispeleme);


                dispeleme = doc.CreateNode(XmlNodeType.Element, "Height", "");
                dispeleme.InnerText = c.myImageHeight.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "Width", "");
                dispeleme.InnerText = c.myImageWidth.ToString();
                n.AppendChild(dispeleme);


                dispeleme = doc.CreateNode(XmlNodeType.Element, "FilePath", "");
                dispeleme.InnerText = c.myImageFilePath;
                n.AppendChild(dispeleme);


                mn.AppendChild(n);
            }
            foreach (CustomImage2D cb2 in images2D)
            {
                CustomImage2D c = cb2;

                n = doc.CreateNode(XmlNodeType.Element, "CustomImage2D", "");


                XmlNode dispeleme = doc.CreateNode(XmlNodeType.Element, "Position", "");
                dispeleme.InnerText = c.myImagePosition.X.ToString() + "_" + c.myImagePosition.Y.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "Direction", "");
                dispeleme.InnerText = c.myImageDirection.ToString();
                n.AppendChild(dispeleme);



                dispeleme = doc.CreateNode(XmlNodeType.Element, "Height", "");
                dispeleme.InnerText = c.myImageHeight.ToString();
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "Width", "");
                dispeleme.InnerText = c.myImageWidth.ToString();
                n.AppendChild(dispeleme);


                dispeleme = doc.CreateNode(XmlNodeType.Element, "FilePath", "");
                dispeleme.InnerText = c.myImageFilePath;
                n.AppendChild(dispeleme);

                dispeleme = doc.CreateNode(XmlNodeType.Element, "Layer", "");
                dispeleme.InnerText = c.layer.ToString();
                n.AppendChild(dispeleme);

                mn.AppendChild(n);
            }


            return mn.OuterXml;
        }
        //hopefully better cache / delete /change
        public static ImageSource BitmapFromFile(string imageFilePath)
        {
            var bitmap = new BitmapImage();
            var stream = File.OpenRead(imageFilePath);
            bitmap.BeginInit();
            bitmap.CacheOption = BitmapCacheOption.OnLoad;
            bitmap.StreamSource = stream;
            bitmap.EndInit();
            stream.Close();
            stream.Dispose();
            return bitmap;
        }
        public static ImageSource BitmapFromUri(Uri source)
        {
            var bitmap = new BitmapImage();
            bitmap.BeginInit();
            bitmap.UriSource = source;

            bitmap.CacheOption = BitmapCacheOption.OnLoad;
            bitmap.EndInit();
            return bitmap;
        }


        //generates the model centered at 0
        internal bool renderCustom()
        {
            try
            {
                bbox = Rect3D.Empty;
                if (use2D)
                {
                    model2D.Children.Clear();
                    for (int i = 0; i < rectangles2D.Count; i++)
                    {
                        //make rectangle like a box
                        CustomRectangle2D c2 = rectangles2D[i];
                        CustomBox3D c3 = new CustomBox3D();
                        c3.myBoxColor = c2.myRectColor;
                        c3.myBoxDiagonal = new Vector3D(c2.myRectDiagonal.X, c2.myRectDiagonal.Y, PUPPIGUISettings.textRaise);
                        c3.myBoxStartPosition = new Point3D(c2.myRectStartPosition.X, c2.myRectStartPosition.Y, c2.layer * PUPPIGUISettings.textRaise - PUPPIGUISettings.textRaise);
                        ModelVisual3D bv = renderMyCustomBox3D(c3);
                        if (bbox.getDiagonal() == 0) bbox = bv.Content.Bounds;
                        bbox.Union(bv.Content.Bounds);
                        model2D.Children.Add(bv);

                    }
                    for (int i = 0; i < triangles2D.Count; i++)
                    {
                        CustomTriangle2D c2 = triangles2D[i];
                        CustomTriangle3D c3 = new CustomTriangle3D();
                        c3.myTriangleColor = c2.myTriangleColor;
                        c3.p1 = new Point3D(c2.p1.X, c2.p1.Y, c2.layer * PUPPIGUISettings.textRaise - PUPPIGUISettings.textRaise);
                        c3.p2 = new Point3D(c2.p2.X, c2.p2.Y, c2.layer * PUPPIGUISettings.textRaise - PUPPIGUISettings.textRaise);
                        c3.p3 = new Point3D(c2.p3.X, c2.p3.Y, c2.layer * PUPPIGUISettings.textRaise - PUPPIGUISettings.textRaise);
                        ModelVisual3D bv = renderMyCustomTriangle3D(c3);
                        if (bbox.getDiagonal() == 0) bbox = bv.Content.Bounds;
                        bbox.Union(bv.Content.Bounds);
                        model2D.Children.Add(bv);
                    }
                    for (int i = 0; i < roundedrectangles2D.Count; i++)
                    {
                        //make rectangle like a box
                        CustomRoundedRectangle2D c2 = roundedrectangles2D[i];
                        CustomRoundedBox3D c3 = new CustomRoundedBox3D();
                        c3.myBoxColor = c2.myRectColor;
                        c3.myBoxDiagonal = new Vector3D(c2.myRectDiagonal.X, c2.myRectDiagonal.Y, PUPPIGUISettings.textRaise);
                        c3.myBoxStartPosition = new Point3D(c2.myRectStartPosition.X, c2.myRectStartPosition.Y, c2.layer * PUPPIGUISettings.textRaise - PUPPIGUISettings.textRaise);
                        c3.myBoxCornerRadius = c2.myCornerRadius;
                        ModelVisual3D bv = renderMyCustomRoundedBox3D(c3);
                        if (bbox.getDiagonal() == 0) bbox = bv.Content.Bounds;
                        bbox.Union(bv.Content.Bounds);
                        model2D.Children.Add(bv);

                    }

                    for (int i = 0; i < borders2D.Count; i++)
                    {
                        //make rectangle like a box
                        CustomBorder2D c2 = borders2D[i];
                        WireCustomBox3D c3 = new WireCustomBox3D();
                        c3.myBoxColor = c2.myBorderColor;
                        c3.myBoxDiagonal = new Vector3D(c2.myBorderDiagonal.X, c2.myBorderDiagonal.Y, PUPPIGUISettings.textRaise);
                        c3.myBoxStartPosition = new Point3D(c2.myBorderStartPosition.X, c2.myBorderStartPosition.Y, c2.layer * PUPPIGUISettings.textRaise - PUPPIGUISettings.textRaise);
                        ModelVisual3D bv = renderMyWireCustomBox3D(c3);
                        if (bbox.getDiagonal() == 0) bbox = bv.Content.Bounds;
                        bbox.Union(bv.Content.Bounds);
                        model2D.Children.Add(bv);

                    }

                    for (int i = 0; i < images2D.Count; i++)
                    {

                        CustomImage2D c = images2D[i];
                        RectangleVisual3D r = new RectangleVisual3D();

                        //upside down horiz
                        if (c.myImageDirection == PUPPIimageDirection.negativeXDirection)
                        {


                            r.LengthDirection = new Vector3D(0, 1, 0);

                            r.Normal = new Vector3D(0, 0, 1);

                        }
                        //right side up horiz
                        if (c.myImageDirection == PUPPIimageDirection.positiveXDirection)
                        {

                            r.LengthDirection = new Vector3D(0, -1, 0);

                            r.Normal = new Vector3D(0, 0, 1);

                        }
                        //upside down vertical
                        if (c.myImageDirection == PUPPIimageDirection.negativeYDirection)
                        {

                            r.LengthDirection = new Vector3D(1, 0, 0);

                            r.Normal = new Vector3D(0, 0, 1);

                        }
                        //right side up horiz
                        if (c.myImageDirection == PUPPIimageDirection.positiveYDirection)
                        {

                            r.LengthDirection = new Vector3D(-1, 0, 0);

                            r.Normal = new Vector3D(0, 0, 1);

                        }
                        r.DivLength = 2;
                        r.DivWidth = 2;
                        r.Length = c.myImageHeight;
                        r.Width = c.myImageWidth;

                        r.Origin = new Point3D(c.myImagePosition.X, c.myImagePosition.Y, c.layer * PUPPIGUISettings.textRaise);


                        //BitmapSource bi = new BitmapImage(new Uri(c.myImageFilePath, UriKind.RelativeOrAbsolute));
                        try
                        {
                            //ImageSource bi = BitmapFromUri(new Uri(c.myImageFilePath, UriKind.RelativeOrAbsolute));
                            ImageSource bi = BitmapFromFile(c.myImageFilePath);
                            ImageBrush ii = new ImageBrush(bi);


                            r.Fill = ii;
                        }
                        catch
                        {
                            r.Fill = Brushes.Red;
                        }
                        //r.Fill.Transform = 
                        r.UpdateModel();
                        //r.BackMaterial = MaterialHelper.CreateImageMaterial(bi,1.0);  
                        bbox.Union(r.Content.Bounds);
                        model2D.Children.Add(r);



                    }
                    for (int i = 0; i < circles2D.Count; i++)
                    {
                        //make Circle like a box
                        CustomCircle2D c2 = circles2D[i];

                        CustomPipe3D cb = new CustomPipe3D();
                        cb.myPipeColor = c2.myCircleColor;
                        cb.myPipeDiameter = c2.myCircleRadius * 2;
                        cb.myPipeStartPoint = new Point3D(c2.myCircleCenter.X, c2.myCircleCenter.Y, c2.layer * PUPPIGUISettings.textRaise - PUPPIGUISettings.textRaise);
                        cb.myPipeEndPoint = new Point3D(c2.myCircleCenter.X, c2.myCircleCenter.Y, c2.layer * PUPPIGUISettings.textRaise);

                        ModelVisual3D bv = renderMyCustomPipe3D(cb);
                        if (bbox.getDiagonal() == 0) bbox = bv.Content.Bounds;
                        bbox.Union(bv.Content.Bounds);
                        model2D.Children.Add(bv);

                    }
                    for (int i = 0; i < captions2D.Count; i++)
                    {
                        CustomCaption2D c = captions2D[i];
                        if (c.myCaptionText != "" && c.myCaptionText != String.Empty)
                        {
                            TextVisual3D iT = new TextVisual3D();
                            //upside down horiz
                            if (c.myCaptionDir == PUPPIimageDirection.negativeXDirection)
                            {

                                iT.TextDirection = new Vector3D(-1, 0, 0);

                                iT.UpDirection = new Vector3D(0, -1, 0);

                            }
                            //right side up horiz
                            if (c.myCaptionDir == PUPPIimageDirection.positiveXDirection)
                            {

                                iT.TextDirection = new Vector3D(1, 0, 0);

                                iT.UpDirection = new Vector3D(0, 1, 0);

                            }
                            //upside down vertical
                            if (c.myCaptionDir == PUPPIimageDirection.negativeYDirection)
                            {

                                iT.TextDirection = new Vector3D(0, -1, 0);

                                iT.UpDirection = new Vector3D(1, 0, 0);

                            }
                            //right side up horiz
                            if (c.myCaptionDir == PUPPIimageDirection.positiveYDirection)
                            {

                                iT.TextDirection = new Vector3D(0, 1, 0);

                                iT.UpDirection = new Vector3D(-1, 0, 0);

                            }

                            iT.Height = c.myCaptionTextHeight;
                            iT.Text = c.myCaptionText;
                            iT.Position = new Point3D(c.myCaptionPosition.X, c.myCaptionPosition.Y, c.layer * PUPPIGUISettings.textRaise + PUPPIGUISettings.textRaise * 0.5);
                            // c3.myBoxStartPosition = new Point3D(c2.myRectStartPosition.X, c2.myRectStartPosition.Y, c2.layer * PUPPIGUISettings.textRaise - PUPPIGUISettings.textRaise);

                            iT.Foreground = new SolidColorBrush(c.myCaptionColor);
                            bbox.Union(iT.Content.Bounds);
                            model2D.Children.Add(iT);
                        }

                    }
                    for (int i = 0; i < modelVisuals2D.Count; i++)
                    {
                        ModelVisual3D mv = modelVisuals2D[i];

                        if (bbox.getDiagonal() == 0) bbox = mv.getBBRecursive();
                        bbox.Union(mv.getBBRecursive());
                        if (mv.Content != null)
                        {
                            ModelVisual3D mao = new ModelVisual3D();
                            mao.Content = mv.Content.Clone();
                            model2D.Children.Add(mao);
                        }
                        for (int j = 0; j < mv.Children.Count; j++)
                        {


                            ModelVisual3D lll = mv.Children[j] as ModelVisual3D;
                            model2D.Children.Add(lll.cloneVisualAndChildren());
                        }
                        //model2D.Children.Add(mv);
                    }

                }
                if (use3D)
                {
                    model3D.Children.Clear();

                    for (int i = 0; i < triangles3D.Count; i++)
                    {
                        CustomTriangle3D c2 = triangles3D[i];
                        ModelVisual3D bv = renderMyCustomTriangle3D(c2);
                        if (bbox.getDiagonal() == 0) bbox = bv.Content.Bounds;
                        bbox.Union(bv.Content.Bounds);
                        model3D.Children.Add(bv);

                    }

                    for (int i = 0; i < pipes3D.Count; i++)
                    {
                        CustomPipe3D cb = pipes3D[i];
                        ModelVisual3D bv = renderMyCustomPipe3D(cb);
                        if (bbox.getDiagonal() == 0) bbox = bv.Content.Bounds;
                        bbox.Union(bv.Content.Bounds);
                        model3D.Children.Add(bv);
                    }
                    for (int i = 0; i < boxes3D.Count; i++)
                    {
                        CustomBox3D cb = boxes3D[i];
                        ModelVisual3D bv = renderMyCustomBox3D(cb);
                        if (bbox.getDiagonal() == 0) bbox = bv.Content.Bounds;
                        bbox.Union(bv.Content.Bounds);
                        model3D.Children.Add(bv);
                    }

                    for (int i = 0; i < roundedboxes3D.Count; i++)
                    {
                        CustomRoundedBox3D cb = roundedboxes3D[i];
                        ModelVisual3D bv = renderMyCustomRoundedBox3D(cb);

                        if (bbox.getDiagonal() == 0) bbox = bv.Content.Bounds;
                        bbox.Union(bv.Content.Bounds);
                        model3D.Children.Add(bv);
                    }

                    for (int i = 0; i < wireBoxes3D.Count; i++)
                    {
                        WireCustomBox3D cb = wireBoxes3D[i];
                        ModelVisual3D bv = renderMyWireCustomBox3D(cb);
                        if (bbox.getDiagonal() == 0) bbox = bv.Content.Bounds;
                        bbox.Union(bv.Content.Bounds);
                        model3D.Children.Add(bv);
                    }
                    for (int i = 0; i < spheres3D.Count; i++)
                    {
                        CustomSphere3D cb = spheres3D[i];
                        var meshBuilder = new MeshBuilder(false, false);
                        meshBuilder.AddSphere(cb.mySphereCenter, cb.mySphereRadius);
                        var mesh = meshBuilder.ToMesh(true);
                        GeometryModel3D newModel = new GeometryModel3D();
                        newModel.Geometry = mesh;
                        newModel.Material = new DiffuseMaterial(new SolidColorBrush(cb.mySphereColor));
                        ModelVisual3D bv = new ModelVisual3D();
                        bv.Content = newModel;
                        if (bbox.getDiagonal() == 0) bbox = newModel.Bounds;
                        bbox.Union(newModel.Bounds);
                        model3D.Children.Add(bv);
                    }
                    for (int i = 0; i < modelVisuals3D.Count; i++)
                    {
                        ModelVisual3D mv = modelVisuals3D[i];

                        if (bbox.getDiagonal() == 0) bbox = mv.getBBRecursive();
                        bbox.Union(mv.getBBRecursive());
                        if (mv.Content != null)
                        {
                            ModelVisual3D mao = new ModelVisual3D();
                            mao.Content = mv.Content.Clone();
                            model3D.Children.Add(mao);
                        }
                        for (int j = 0; j < mv.Children.Count; j++)
                        {

                            ModelVisual3D lll = mv.Children[j] as ModelVisual3D;
                            model3D.Children.Add(lll.cloneVisualAndChildren());
                        }
                        //model3D.Children.Add(mv);
                    }
                    for (int i = 0; i < fileVisuals3D.Count; i++)
                    {
                        FileModelVisual3D fv = fileVisuals3D[i];
                        if (fv.Source != null)
                        {
                            if (bbox.getDiagonal() == 0) bbox = Visual3DHelper.FindBounds(fv, Transform3D.Identity);
                            bbox.Union(Visual3DHelper.FindBounds(fv, Transform3D.Identity));
                            Model3DGroup ga = Visual3DModelPropertyInfo.GetValue(fv, null) as Model3DGroup;
                            foreach (Model3D m in ga.Children)
                            {
                                ModelVisual3D g = new ModelVisual3D();
                                g.Content = m;
                                model3D.Children.Add(g);
                            }





                        }
                    }
                    for (int i = 0; i < captions3D.Count; i++)
                    {
                        CustomCaption3D c = captions3D[i];

                        if (c.myCaptionText != "" && c.myCaptionText != String.Empty)
                        {
                            TextVisual3D iT = new TextVisual3D();
                            //upside down horiz
                            if (c.myCaptionDir == PUPPIimageDirection.negativeXDirection)
                            {

                                iT.TextDirection = new Vector3D(-1, 0, 0);
                                if (c.myCaptionOrient == PUPPIimageOrientation.horizontal)
                                {
                                    iT.UpDirection = new Vector3D(0, -1, 0);
                                }
                                else
                                {
                                    iT.UpDirection = new Vector3D(0, 0, -1);
                                }
                            }
                            //right side up horiz
                            if (c.myCaptionDir == PUPPIimageDirection.positiveXDirection)
                            {

                                iT.TextDirection = new Vector3D(1, 0, 0);
                                if (c.myCaptionOrient == PUPPIimageOrientation.horizontal)
                                {
                                    iT.UpDirection = new Vector3D(0, 1, 0);
                                }
                                else
                                {
                                    iT.UpDirection = new Vector3D(0, 0, 1);
                                }
                            }
                            //upside down vertical
                            if (c.myCaptionDir == PUPPIimageDirection.negativeYDirection)
                            {

                                iT.TextDirection = new Vector3D(0, -1, 0);
                                if (c.myCaptionOrient == PUPPIimageOrientation.horizontal)
                                {
                                    iT.UpDirection = new Vector3D(1, 0, 0);
                                }
                                else
                                {
                                    iT.UpDirection = new Vector3D(0, 0, 1);
                                }
                            }
                            //right side up horiz
                            if (c.myCaptionDir == PUPPIimageDirection.positiveYDirection)
                            {

                                iT.TextDirection = new Vector3D(0, 1, 0);
                                if (c.myCaptionOrient == PUPPIimageOrientation.horizontal)
                                {
                                    iT.UpDirection = new Vector3D(-1, 0, 0);
                                }
                                else
                                {
                                    iT.UpDirection = new Vector3D(0, 0, -1);
                                }
                            }

                            iT.Height = c.myCaptionTextHeight;
                            iT.Text = c.myCaptionText;
                            iT.Position = c.myCaptionPosition;

                            iT.Foreground = new SolidColorBrush(c.myCaptionColor);
                            bbox.Union(iT.Content.Bounds);
                            model3D.Children.Add(iT);
                        }

                    }

                    for (int i = 0; i < images3D.Count; i++)
                    {
                        CustomImage3D c = images3D[i];
                        RectangleVisual3D r = new RectangleVisual3D();

                        //upside down horiz
                        if (c.myImageDirection == PUPPIimageDirection.negativeXDirection)
                        {


                            r.LengthDirection = new Vector3D(0, 1, 0);
                            if (c.myImageOrient == PUPPIimageOrientation.horizontal)
                            {
                                r.Normal = new Vector3D(0, 0, 1);
                            }
                            else
                            {
                                r.Normal = new Vector3D(1, 0, 0);
                            }
                        }
                        //right side up horiz
                        if (c.myImageDirection == PUPPIimageDirection.positiveXDirection)
                        {

                            r.LengthDirection = new Vector3D(0, -1, 0);
                            if (c.myImageOrient == PUPPIimageOrientation.horizontal)
                            {
                                r.Normal = new Vector3D(0, 0, 1);
                            }
                            else
                            {
                                r.Normal = new Vector3D(-1, 0, 0);
                            }
                        }
                        //upside down vertical
                        if (c.myImageDirection == PUPPIimageDirection.negativeYDirection)
                        {

                            r.LengthDirection = new Vector3D(1, 0, 0);
                            if (c.myImageOrient == PUPPIimageOrientation.horizontal)
                            {
                                r.Normal = new Vector3D(0, 0, 1);
                            }
                            else
                            {
                                r.Normal = new Vector3D(0, -1, 0);
                            }
                        }
                        //right side up horiz
                        if (c.myImageDirection == PUPPIimageDirection.positiveYDirection)
                        {

                            r.LengthDirection = new Vector3D(-1, 0, 0);
                            if (c.myImageOrient == PUPPIimageOrientation.horizontal)
                            {
                                r.Normal = new Vector3D(0, 0, 1);
                            }
                            else
                            {
                                r.Normal = new Vector3D(0, 1, 0);
                            }
                        }
                        r.DivLength = 2;
                        r.DivWidth = 2;
                        r.Length = c.myImageWidth;
                        r.Width = c.myImageHeight;

                        r.Origin = c.myImagePosition;

                        // Create source.
                        //BitmapImage bi = new BitmapImage();
                        //// BitmapImage.UriSource must be in a BeginInit/EndInit block.
                        //bi.BeginInit();
                        //bi.UriSource = new Uri(c.myImageFilePath ,UriKind.RelativeOrAbsolute);
                        //bi.EndInit();
                        ////                    ImageSource sisi;
                        //                    sisi =new     


                        //BitmapSource bi = new BitmapImage(new Uri(c.myImageFilePath, UriKind.RelativeOrAbsolute));
                        //ImageBrush ii = new ImageBrush(bi);



                        //RotateTransform rT = new RotateTransform();
                        //rT.CenterX = 0;
                        //rT.CenterY = 0;
                        //rT.Angle = 90;
                        //TransformGroup tg = new TransformGroup();
                        //tg.Children.Add(rT);

                        //ii.RelativeTransform = tg;

                        //r.Fill = ii;
                        //r.Fill.Transform = 

                        try
                        {
                            //ImageSource bi = BitmapFromUri(new Uri(c.myImageFilePath, UriKind.RelativeOrAbsolute));
                            ImageSource bi = BitmapFromFile(c.myImageFilePath);
                            ImageBrush ii = new ImageBrush(bi);


                            r.Fill = ii;
                        }
                        catch
                        {
                            r.Fill = Brushes.Red;
                        }

                        r.UpdateModel();
                        //r.BackMaterial = MaterialHelper.CreateImageMaterial(bi,1.0);  
                        bbox.Union(r.Content.Bounds);
                        model3D.Children.Add(r);


                    }
                }
                //to make sure when in 2d boundingbox goes all the way down
                if (use2D)
                {
                    Point3D p = bbox.rectcenter();
                    p.Z = 0;
                    bbox.Union(p);
                }

                displacedBbox = bbox;
                //nothing in it
                if (bbox.IsEmpty || Double.IsNaN(bbox.Location.X) || Double.IsNaN(bbox.Location.Y) || Double.IsNaN(bbox.Location.Z) || Double.IsNaN(bbox.SizeX) || Double.IsNaN(bbox.SizeY) || Double.IsNaN(bbox.SizeZ))
                {
                    needsRender = true;
                    return false;


                }
                else
                {
                    if (recalcNormsOnRender)
                    {
                        if (model2D != null) model2D.RecalVisNo();
                        if (model3D != null) model3D.RecalVisNo();
                    }
                    needsRender = false;
                    return true;
                }
            }
            catch (Exception exy)
            {
                return false;
            }
        }
        /// <summary>
        /// Activates the rendering operation which places the objects added to the custom renderer in 
        /// </summary>
        public void forceRender()
        {
            renderCustom();
        }

        internal ModelVisual3D renderMyCustomBox3D(CustomBox3D cb)
        {
            ModelVisual3D bv = new ModelVisual3D();
            var meshBuilder = new MeshBuilder(false, false);
            Point3D center = Point3D.Add(cb.myBoxStartPosition, Vector3D.Multiply(0.5, cb.myBoxDiagonal));
            meshBuilder.AddBox(center, cb.myBoxDiagonal.X, cb.myBoxDiagonal.Y, cb.myBoxDiagonal.Z);
            var mesh = meshBuilder.ToMesh(true);
            GeometryModel3D newModel = new GeometryModel3D();
            newModel.Geometry = mesh;
            newModel.Material = new DiffuseMaterial(new SolidColorBrush(cb.myBoxColor));

            bv.Content = newModel;
            return bv;
        }

        internal ModelVisual3D renderMyCustomRoundedBox3D(CustomRoundedBox3D cb)
        {
            ModelVisual3D bv = new ModelVisual3D();
            var meshBuilder = new MeshBuilder(false, false);
            Point3D p0 = Point3D.Add(cb.myBoxStartPosition, Vector3D.Multiply(0.5, new Vector3D(cb.myBoxDiagonal.X, cb.myBoxDiagonal.Y, 0)));
            Point3D p1 = Point3D.Add(cb.myBoxStartPosition, Vector3D.Multiply(0.5, new Vector3D(cb.myBoxDiagonal.X, cb.myBoxDiagonal.Y, cb.myBoxDiagonal.Z * 2)));

            Visual3DExtensions.makeverticalextrusion(meshBuilder, Visual3DExtensions.makeroundedrect(cb.myBoxDiagonal.X, cb.myBoxDiagonal.Y, cb.myBoxCornerRadius), p0, p1);


            var mesh = meshBuilder.ToMesh(true);
            GeometryModel3D newModel = new GeometryModel3D();
            newModel.Geometry = mesh;
            newModel.Material = new DiffuseMaterial(new SolidColorBrush(cb.myBoxColor));

            bv.Content = newModel;
            return bv;
        }

        internal ModelVisual3D renderMyCustomTriangle3D(CustomTriangle3D tb)
        {
            ModelVisual3D bv = new ModelVisual3D();
            var meshBuilder = new MeshBuilder(false, false);
            meshBuilder.AddTriangle(tb.p1, tb.p2, tb.p3);
            var mesh = meshBuilder.ToMesh(true);
            GeometryModel3D newModel = new GeometryModel3D();
            newModel.Geometry = mesh;
            newModel.Material = new DiffuseMaterial(new SolidColorBrush(tb.myTriangleColor));
            newModel.BackMaterial = new DiffuseMaterial(new SolidColorBrush(tb.myTriangleColor));
            bv.Content = newModel;
            return bv;
        }

        internal ModelVisual3D renderMyWireCustomBox3D(WireCustomBox3D cb)
        {
            ModelVisual3D bv = new ModelVisual3D();
            var meshBuilder = new MeshBuilder(false, false);
            Point3D center = Point3D.Add(cb.myBoxStartPosition, Vector3D.Multiply(0.5, cb.myBoxDiagonal));
            Rect3D makeBo = center.makeSizeBox(cb.myBoxDiagonal.X, cb.myBoxDiagonal.Y, cb.myBoxDiagonal.Z);
            meshBuilder.AddBoundingBox(makeBo, PUPPIGUISettings.solidConnectionSize);
            var mesh = meshBuilder.ToMesh(true);
            GeometryModel3D newModel = new GeometryModel3D();
            newModel.Geometry = mesh;
            newModel.Material = new DiffuseMaterial(new SolidColorBrush(cb.myBoxColor));

            bv.Content = newModel;
            return bv;
        }

        internal ModelVisual3D renderMyCustomPipe3D(CustomPipe3D cp)
        {
            ModelVisual3D bv = new ModelVisual3D();
            var meshBuilder = new MeshBuilder(false, false);

            meshBuilder.AddPipe(cp.myPipeStartPoint, cp.myPipeEndPoint, 0, cp.myPipeDiameter, PUPPIGUISettings.customRendererCircleSides);
            var mesh = meshBuilder.ToMesh(true);
            GeometryModel3D newModel = new GeometryModel3D();
            newModel.Geometry = mesh;
            newModel.Material = new DiffuseMaterial(new SolidColorBrush(cp.myPipeColor));
            bv.Content = newModel;
            return bv;
        }



    }
    /// <summary>
    /// Custom renderer applied to nodes by module type, allows the programmer to define and alter at runtime the appearance of the node.
    /// </summary>
    public class PUPPINodeCustomRenderer : PUPPICustomRenderer
    {
        /// <summary>
        /// If this is false, child nodes cannot be dropped on this node.
        /// </summary>
        public bool acceptsNodesAbove { get; set; }
        /// <summary>
        /// Name of the Node Custom Renderer used for retrieval from Custom Renderer Dictionary;
        /// </summary>
        public string name { get; set; }
        /// <summary>
        /// Must match the number of inputs of the node this node renderer is applied to.
        /// </summary>
        public int numberInputPositions { get; internal set; }
        /// <summary>
        /// Must match the number of outputs of the node this node renderer is applied to.
        /// </summary>
        public int numberOutputPositions { get; internal set; }
        internal List<PUPPICustomRenderer> inputPositions;
        internal List<PUPPICustomRenderer> outputPositions;
        /// <summary>
        /// Adds an input Custom Renderer object to replace the node input box corresponding to that input index .0,0,0 is considered the center of the node 
        /// </summary>
        /// <param name="inputRenderer">a PUPPICustomRenderer object</param>
        public void addCustomInputRenderer(PUPPICustomRenderer inputRenderer)
        {
            inputPositions.Add(inputRenderer);
            numberInputPositions++;
        }
        /// <summary>
        /// Adds an output Custom Renderer object to replace the node output box corresponding to that output index .0,0,0 is considered the center of the node 
        /// </summary>
        /// <param name="outputRenderer">a PUPPICustomRenderer object</param>
        public void addCustomOutputRenderer(PUPPICustomRenderer outputRenderer)
        {
            outputPositions.Add(outputRenderer);
            numberOutputPositions++;
        }
        /// <summary>
        /// Initializes a new PUPPINodeCustomRenderer
        /// </summary>
        /// <param name="uniqueName">Unique Name fr a node render, not used by other node renderer</param>
        public PUPPINodeCustomRenderer(string uniqueName)
            : base()
        {
            acceptsNodesAbove = true;
            name = uniqueName;
            if (name == "") throw new Exception("Invalid renderer name!");
            numberInputPositions = 0;
            numberOutputPositions = 0;
            inputPositions = new List<PUPPICustomRenderer>();
            outputPositions = new List<PUPPICustomRenderer>();
        }

        //for serailzaition
        internal PUPPINodeCustomRenderer()
            : base()
        {
            //generate random string
            var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
            var random = new Random();
            var result = new string(
                Enumerable.Repeat(chars, 8)
                          .Select(s => s[random.Next(s.Length)])
                          .ToArray());
            name = result;
            acceptsNodesAbove = true;
            numberInputPositions = 0;
            numberOutputPositions = 0;
            inputPositions = new List<PUPPICustomRenderer>();
            outputPositions = new List<PUPPICustomRenderer>();
        }
        /// <summary>
        /// Applies the renderer to a PUPPI module on that canvas
        /// </summary>
        /// <param name="myProgCanvas">an initialized PUPPIProgramCanvas</param>
        public void applyRendererToModule(Type PUPPIModuleType, PUPPIGUIController.PUPPIProgramCanvas myProgCanvas)
        {
            if (myProgCanvas.pcanvas.moduleRenderers.ContainsKey(PUPPIModuleType)) throw new Exception("Module Type Renderer Dictionary already contains PUPPIModule Type " + PUPPIModuleType.Name);
            myProgCanvas.pcanvas.moduleRenderers.Add(PUPPIModuleType, this.name);
        }
        /// <summary>
        /// Applies the renderer 
        /// </summary>
        /// <param name="myProgCanvas">an initialized PUPPIProgramCanvas</param>
        public void addRendererToCanvas(PUPPIGUIController.PUPPIProgramCanvas myProgCanvas)
        {
            if (myProgCanvas.pcanvas.customRenderers.ContainsKey(name)) throw new Exception("Custom Renderer Dictionary already contains key " + name);
            myProgCanvas.pcanvas.customRenderers.Add(name, this);
        }
        internal PUPPINodeCustomRenderer cloneMyPUPPINodeCustomRenderer()
        {
            PUPPINodeCustomRenderer pn = new PUPPINodeCustomRenderer();
            PUPPICustomRenderer pc = pn as PUPPICustomRenderer;
            cloneMyPUPPICustomRenderer(ref pc);
            pn.name = name;
            pn.numberInputPositions = numberInputPositions;
            pn.numberOutputPositions = numberOutputPositions;
            pn.acceptsNodesAbove = acceptsNodesAbove;
            for (int i = 0; i < numberInputPositions; i++)
            {
                PUPPICustomRenderer pi = new PUPPICustomRenderer();
                PUPPICustomRenderer ii = inputPositions[i];
                ii.cloneMyPUPPICustomRenderer(ref pi);
                pn.inputPositions.Add(pi);
            }
            for (int i = 0; i < numberOutputPositions; i++)
            {
                PUPPICustomRenderer pi = new PUPPICustomRenderer();
                PUPPICustomRenderer ii = outputPositions[i];
                ii.cloneMyPUPPICustomRenderer(ref pi);
                pn.outputPositions.Add(pi);
            }
            return pn;


        }
    }

    ///// <summary>
    ///// A visual element that shows a model loaded from a file.
    ///// </summary>
    ///// <remarks>
    ///// Supported file formats: .3ds .obj .lwo .stl .off
    ///// </remarks>
    //public class FileModelVisual3D : UIElement3D
    //{
    //    /// <summary>
    //    /// Identifies the <see cref="DefaultMaterial"/> dependency property.
    //    /// </summary>
    //    public static readonly DependencyProperty DefaultMaterialProperty =
    //        DependencyProperty.Register(
    //            "DefaultMaterial", typeof(Material), typeof(FileModelVisual3D), new PropertyMetadata(null, SourceChanged));

    //    /// <summary>
    //    /// Identifies the <see cref="Source"/> dependency property.
    //    /// </summary>
    //    public static readonly DependencyProperty SourceProperty = DependencyProperty.Register(
    //        "Source", typeof(string), typeof(FileModelVisual3D), new UIPropertyMetadata(null, SourceChanged));

    //    /// <summary>
    //    /// The model loaded event.
    //    /// </summary>
    //    private static readonly RoutedEvent ModelLoadedEvent = EventManager.RegisterRoutedEvent(
    //        "ModelLoaded", RoutingStrategy.Bubble, typeof(RoutedEventHandler), typeof(FileModelVisual3D));

    //    /// <summary>
    //    /// Occurs when the model has been loaded.
    //    /// </summary>
    //    public event RoutedEventHandler ModelLoaded
    //    {
    //        add
    //        {
    //            this.AddHandler(ModelLoadedEvent, value);
    //        }

    //        remove
    //        {
    //            this.RemoveHandler(ModelLoadedEvent, value);
    //        }
    //    }

    //    /// <summary>
    //    /// Gets or sets the default material.
    //    /// </summary>
    //    /// <value>
    //    /// The default material.
    //    /// </value>
    //    public Material DefaultMaterial
    //    {
    //        get
    //        {
    //            return (Material)this.GetValue(DefaultMaterialProperty);
    //        }

    //        set
    //        {
    //            this.SetValue(DefaultMaterialProperty, value);
    //        }
    //    }

    //    /// <summary>
    //    /// Gets or sets the source file name.
    //    /// </summary>
    //    /// <value> The source file name. </value>
    //    public string Source
    //    {
    //        get
    //        {
    //            return (string)this.GetValue(SourceProperty);
    //        }

    //        set
    //        {
    //            this.SetValue(SourceProperty, value);
    //        }
    //    }

    //    /// <summary>
    //    /// The source changed.
    //    /// </summary>
    //    /// <param name="obj">
    //    /// The sender.
    //    /// </param>
    //    /// <param name="args">
    //    /// The args.
    //    /// </param>
    //    protected static void SourceChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args)
    //    {
    //        ((FileModelVisual3D)obj).SourceChanged();
    //    }

    //    /// <summary>
    //    /// Called when the model has been loaded.
    //    /// </summary>
    //    protected virtual void OnModelLoaded()
    //    {
    //        var args = new RoutedEventArgs { RoutedEvent = ModelLoadedEvent };
    //        this.RaiseEvent(args);
    //    }

    //    /// <summary>
    //    /// Called when the source or default material changed.
    //    /// </summary>
    //    protected virtual void SourceChanged()
    //    {
    //        var importer = new ModelImporter { DefaultMaterial = this.DefaultMaterial };
    //        this.Visual3DModel = this.Source != null ? importer.Load(this.Source) : null;
    //        this.OnModelLoaded();
    //    }
    //}


    internal class MATraMu : ModelVisual3D
    {

        /// <summary>
        /// Identifies the <see cref="CanTranslateX"/> dependency property.
        /// </summary>
        internal static readonly DependencyProperty CanTranslateXProperty = DependencyProperty.Register(
            "CanTranslateX", typeof(bool), typeof(MATraMu), new UIPropertyMetadata(true, ChildrenChanged));


        /// <summary>
        /// Identifies the <see cref="CanTranslateX"/> dependency property.
        /// </summary>
        internal static readonly DependencyProperty CanTranslateXYProperty = DependencyProperty.Register(
            "CanTranslateXY", typeof(bool), typeof(MATraMu), new UIPropertyMetadata(true, ChildrenChanged));

        /// <summary>
        /// Identifies the <see cref="CanTranslateX"/> dependency property.
        /// </summary>
        internal static readonly DependencyProperty CanTranslateYXProperty = DependencyProperty.Register(
            "CanTranslateYX", typeof(bool), typeof(MATraMu), new UIPropertyMetadata(true, ChildrenChanged));


        /// <summary>
        /// Identifies the <see cref="CanTranslateY"/> dependency property.
        /// </summary>
        internal static readonly DependencyProperty CanTranslateYProperty = DependencyProperty.Register(
            "CanTranslateY", typeof(bool), typeof(MATraMu), new UIPropertyMetadata(true, ChildrenChanged));

        /// <summary>
        /// Identifies the <see cref="CanTranslateZ"/> dependency property.
        /// </summary>
        internal static readonly DependencyProperty CanTranslateZProperty = DependencyProperty.Register(
            "CanTranslateZ", typeof(bool), typeof(MATraMu), new UIPropertyMetadata(true, ChildrenChanged));

        /// <summary>
        /// Identifies the <see cref="Diameter"/> dependency property.
        /// </summary>
        internal static readonly DependencyProperty DiameterProperty = DependencyProperty.Register(
            "Diameter", typeof(double), typeof(MATraMu), new UIPropertyMetadata(0.1, DiameterChanged));

        /// <summary>
        /// Identifies the <see cref="Length"/> dependency property.
        /// </summary>
        internal static readonly DependencyProperty LengthProperty = DependencyProperty.Register(
            "Length", typeof(double), typeof(MATraMu), new UIPropertyMetadata(1.0, LengthChanged));


        /// <summary>
        /// Identifies the <see cref="TargetTransform"/> dependency property.
        /// </summary>
        internal static readonly DependencyProperty TargetTransformProperty =
            DependencyProperty.Register(
                "TargetTransform",
                typeof(Transform3D),
                typeof(MATraMu),
                new FrameworkPropertyMetadata(
                    Transform3D.Identity, FrameworkPropertyMetadataOptions.BindsTwoWayByDefault));


        /// <summary>
        /// The translate xy manipulator.
        /// </summary>
        private readonly TranslateManipulator translateXYManipulator;

        /// <summary>
        /// The translate yx manipulator.
        /// </summary>
        private readonly TranslateManipulator translateYXManipulator;

        /// <summary>
        /// The translate x manipulator.
        /// </summary>
        private readonly TranslateManipulator translateXManipulator;

        /// <summary>
        /// The translate y manipulator.
        /// </summary>
        private readonly TranslateManipulator translateYManipulator;

        /// <summary>
        /// The translate z manipulator.
        /// </summary>
        private readonly TranslateManipulator translateZManipulator;

        public double initialL;
        public double initialD;

        /// <summary>
        /// Initializes a new instance of the <see cref="MATraMu" /> class.
        /// </summary>
        internal MATraMu()
        {
            this.translateXManipulator = new TranslateManipulator
            {
                Direction = new Vector3D(1, 0, 0),
                Color = Colors.Red
            };
            this.translateYManipulator = new TranslateManipulator
            {
                Direction = new Vector3D(0, 1, 0),
                Color = Colors.Green
            };
            this.translateZManipulator = new TranslateManipulator
            {
                Direction = new Vector3D(0, 0, 1),
                Color = Colors.Blue
            };

            this.translateXYManipulator = new TranslateManipulator
            {
                Direction = new Vector3D(1, 1, 0),
                Color = Colors.DarkOrchid
            };

            this.translateYXManipulator = new TranslateManipulator
            {
                Direction = new Vector3D(-1, 1, 0),
                Color = Colors.DarkOrange
            };
            BindingOperations.SetBinding(this, TransformProperty, new Binding("TargetTransform") { Source = this });

            BindingOperations.SetBinding(
                this.translateXManipulator,
                Manipulator.TargetTransformProperty,
                new Binding("TargetTransform") { Source = this });
            BindingOperations.SetBinding(
                this.translateYManipulator,
                Manipulator.TargetTransformProperty,
                new Binding("TargetTransform") { Source = this });
            BindingOperations.SetBinding(
                this.translateZManipulator,
                Manipulator.TargetTransformProperty,
                new Binding("TargetTransform") { Source = this });
            BindingOperations.SetBinding(
                 this.translateXYManipulator,
                 Manipulator.TargetTransformProperty,
                 new Binding("TargetTransform") { Source = this });

            BindingOperations.SetBinding(
                 this.translateYXManipulator,
                 Manipulator.TargetTransformProperty,
                 new Binding("TargetTransform") { Source = this });

            initialL = translateXManipulator.Length;
            initialD = translateXManipulator.Diameter;

            this.OnChildrenChanged();
        }



        /// <summary>
        /// Gets or sets a value indicating whether this instance can translate X.
        /// </summary>
        /// <value> <c>true</c> if this instance can translate X; otherwise, <c>false</c> . </value>
        internal bool CanTranslateX
        {
            get
            {
                return (bool)this.GetValue(CanTranslateXProperty);
            }

            set
            {
                this.SetValue(CanTranslateXProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether this instance can translate Y.
        /// </summary>
        /// <value> <c>true</c> if this instance can translate Y; otherwise, <c>false</c> . </value>
        internal bool CanTranslateY
        {
            get
            {
                return (bool)this.GetValue(CanTranslateYProperty);
            }

            set
            {
                this.SetValue(CanTranslateYProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether this instance can translate Z.
        /// </summary>
        /// <value> <c>true</c> if this instance can translate Z; otherwise, <c>false</c> . </value>
        internal bool CanTranslateZ
        {
            get
            {
                return (bool)this.GetValue(CanTranslateZProperty);
            }

            set
            {
                this.SetValue(CanTranslateZProperty, value);
            }
        }


        /// <summary>
        /// Gets or sets a value indicating whether this instance can translate XY.
        /// </summary>
        /// <value> <c>true</c> if this instance can translate XY; otherwise, <c>false</c> . </value>
        internal bool CanTranslateXY
        {
            get
            {
                return (bool)this.GetValue(CanTranslateXYProperty);
            }

            set
            {
                this.SetValue(CanTranslateXYProperty, value);
            }
        }


        /// <summary>
        /// Gets or sets a value indicating whether this instance can translate YX.
        /// </summary>
        /// <value> <c>true</c> if this instance can translate YX; otherwise, <c>false</c> . </value>
        internal bool CanTranslateYX
        {
            get
            {
                return (bool)this.GetValue(CanTranslateYXProperty);
            }

            set
            {
                this.SetValue(CanTranslateYXProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the diameter.
        /// </summary>
        /// <value> The diameter. </value>
        internal double Diameter
        {
            get
            {
                return (double)this.GetValue(DiameterProperty);
            }

            set
            {
                this.SetValue(DiameterProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the length.
        /// </summary>
        /// <value> The length. </value>
        internal double Length
        {
            get
            {
                return (double)this.GetValue(LengthProperty);
            }

            set
            {
                this.SetValue(LengthProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the offset of the visual (this vector is added to the Position point).
        /// </summary>
        /// <value> The offset. </value>
        internal Vector3D Offset
        {
            get
            {
                return this.translateXManipulator.Offset;
            }

            set
            {
                this.translateXManipulator.Offset = value;
                this.translateYManipulator.Offset = value;
                this.translateZManipulator.Offset = value;
                this.translateXYManipulator.Offset = value;
                this.translateYXManipulator.Offset = value;

            }
        }



        /// <summary>
        /// Gets or sets the position of the manipulator.
        /// </summary>
        /// <value> The position. </value>
        internal Point3D Position
        {
            get
            {
                return this.translateXManipulator.Position;
            }

            set
            {
                this.translateXManipulator.Position = value;
                this.translateYManipulator.Position = value;
                this.translateZManipulator.Position = value;
                this.translateXYManipulator.Position = value;
                this.translateYXManipulator.Position = value;

            }
        }

        /// <summary>
        /// Gets or sets the target transform.
        /// </summary>
        /// <value> The target transform. </value>
        internal Transform3D TargetTransform
        {
            get
            {
                return (Transform3D)this.GetValue(TargetTransformProperty);
            }

            set
            {
                this.SetValue(TargetTransformProperty, value);
            }
        }

        /// <summary>
        /// Binds this manipulator to a given Visual3D.
        /// </summary>
        /// <param name="source">
        /// Source Visual3D which receives the manipulator transforms.
        /// </param>
        internal virtual void Bind(ModelVisual3D source)
        {
            BindingOperations.SetBinding(this, TargetTransformProperty, new Binding("Transform") { Source = source });
            BindingOperations.SetBinding(this, TransformProperty, new Binding("Transform") { Source = source });
        }

        /// <summary>
        /// Releases the binding of this manipulator.
        /// </summary>
        internal virtual void UnBind()
        {
            BindingOperations.ClearBinding(this, TargetTransformProperty);
            BindingOperations.ClearBinding(this, TransformProperty);
        }

        /// <summary>
        /// The on children changed.
        /// </summary>
        protected virtual void OnChildrenChanged()
        {
            this.Children.Clear();
            if (this.CanTranslateX)
            {
                this.Children.Add(this.translateXManipulator);
            }

            if (this.CanTranslateY)
            {
                this.Children.Add(this.translateYManipulator);
            }

            if (this.CanTranslateZ)
            {
                this.Children.Add(this.translateZManipulator);
            }


            if (this.CanTranslateXY)
            {
                this.Children.Add(this.translateXYManipulator);
            }

            if (this.CanTranslateYX)
            {
                this.Children.Add(this.translateYXManipulator);
            }

        }

        /// <summary>
        /// The on diameter changed.
        /// </summary>
        protected virtual void OnDiameterChanged()
        {
            this.translateXManipulator.Diameter = Diameter;
            this.translateYManipulator.Diameter = Diameter;
            this.translateZManipulator.Diameter = Diameter;
            this.translateXYManipulator.Diameter = Diameter;
            this.translateYXManipulator.Diameter = Diameter;
        }

        /// <summary>
        /// The on length changed.
        /// </summary>
        protected virtual void OnLengthChanged()
        {
            this.translateXManipulator.Length = Length;
            this.translateYManipulator.Length = Length;
            this.translateZManipulator.Length = Length;
            this.translateXYManipulator.Length = Length;
            this.translateYXManipulator.Length = Length;
        }

        /// <summary>
        /// The children changed.
        /// </summary>
        /// <param name="d">
        /// The d.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        private static void ChildrenChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            ((MATraMu)d).OnChildrenChanged();
        }

        /// <summary>
        /// The diameter changed.
        /// </summary>
        /// <param name="d">
        /// The d.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        private static void DiameterChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            ((MATraMu)d).OnDiameterChanged();
        }
        /// <summary>
        /// The length changed.
        /// </summary>
        /// <param name="l">
        /// The l.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        private static void LengthChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            ((MATraMu)d).OnLengthChanged();
        }
    }
}